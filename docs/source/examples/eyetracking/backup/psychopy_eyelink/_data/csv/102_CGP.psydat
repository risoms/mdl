ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005csr38553\u005cDesktop\u005cnew task\u005ctask\u005cdata/csv/102_CGP
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'CGP'
p11
sS'dataNames'
p12
(lp13
S'block_key.keys'
p14
aS'block_key.rt'
p15
aS'Break_key.keys'
p16
aS'Break_key.rt'
p17
asS'autoLog'
p18
I01
sS'extraInfo'
p19
(dp20
S'date'
p21
V2016_May_18_1435
p22
sS'frameRate'
p23
cnumpy.core.multiarray
scalar
p24
(cnumpy
dtype
p25
(S'f8'
I0
I1
tRp26
(I3
S'<'
NNNI-1
I-1
I0
tbS'\xf3[!\xd8\xeb\xfb]@'
tRp27
sS'expName'
p28
g11
sVParticipant
p29
V102
p30
ssS'loopsUnfinished'
p31
(lp32
sS'saveWideText'
p33
I01
sS'thisEntry'
p34
(dp35
sS'version'
p36
S''
sS'_paramNamesSoFar'
p37
(lp38
S'order'
p39
aS'block_display'
p40
aS'block_file'
p41
aS'break_display'
p42
aS'valmean'
p43
aS'valence'
p44
aS'scenestim'
p45
aS'arousal'
p46
aS'outliers'
p47
aS'blocknum'
p48
aS'arousalmean'
p49
asS'entries'
p50
(lp51
(dp52
S'Trial_Loop.thisTrialN'
p53
I0
sg48
g24
(g25
(S'i8'
I0
I1
tRp54
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp55
sg15
F5.17504649463649
sS'block_loop.thisIndex'
p56
g24
(g25
(S'i4'
I0
I1
tRp57
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00'
tRp58
sg14
S'space'
p59
sg42
S'break'
p60
sg23
g27
sS'Trial_Loop.thisN'
p61
I0
sg21
g22
sS'Trial_Loop.thisIndex'
p62
g24
(g57
S'\x13\x00\x00\x00'
tRp63
sg46
S'Low'
p64
sg29
g30
sS'Trial_Loop.thisRepN'
p65
I0
sg40
S'inst_2'
p66
sg49
g24
(g26
S'\xe1z\x14\xaeG\xe1\n@'
tRp67
sS'block_loop.thisRepN'
p68
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp69
sg45
S'2235.bmp'
p70
sS'block_loop.thisN'
p71
I0
sg41
S'procedure\\0.csv'
p72
sS'block_loop.thisTrialN'
p73
I0
sg43
g24
(g26
S'\x8f\xc2\xf5(\\\x8f\x16@'
tRp74
sg28
g11
sg44
S'Neutral'
p75
sg39
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp76
sa(dp77
S'Trial_Loop.thisTrialN'
p78
I1
sg40
g66
sg45
S'2030.bmp'
p79
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p80
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p81
g24
(g57
S'\x00\x00\x00\x00'
tRp82
sg46
S'High'
p83
sg29
g30
sS'Trial_Loop.thisRepN'
p84
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp85
sg49
g24
(g26
S')\\\x8f\xc2\xf5(\x12@'
tRp86
sS'block_loop.thisRepN'
p87
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp88
sS'block_loop.thisIndex'
p89
g58
sS'block_loop.thisN'
p90
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\xd7\xa3p=\n\xd7\x1a@'
tRp91
sg28
g11
sg44
S'Positive'
p92
sS'block_loop.thisTrialN'
p93
I0
sa(dp94
S'Trial_Loop.thisTrialN'
p95
I2
sg40
g66
sg45
S'8120.bmp'
p96
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p97
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p98
g24
(g57
S'\x0b\x00\x00\x00'
tRp99
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p100
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp101
sg49
g24
(g26
S'ffffff\x13@'
tRp102
sS'block_loop.thisRepN'
p103
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp104
sS'block_loop.thisIndex'
p105
g58
sS'block_loop.thisN'
p106
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\\\x8f\xc2\xf5(\\\x1c@'
tRp107
sg28
g11
sg44
g92
sS'block_loop.thisTrialN'
p108
I0
sa(dp109
S'Trial_Loop.thisTrialN'
p110
I3
sg40
g66
sg45
S'9340.bmp'
p111
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p112
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p113
g24
(g57
S'\x0e\x00\x00\x00'
tRp114
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p115
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp116
sg49
g24
(g26
S'\xa4p=\n\xd7\xa3\x14@'
tRp117
sS'block_loop.thisRepN'
p118
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp119
sS'block_loop.thisIndex'
p120
g58
sS'block_loop.thisN'
p121
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'H\xe1z\x14\xaeG\x03@'
tRp122
sg28
g11
sg44
S'Negative'
p123
sS'block_loop.thisTrialN'
p124
I0
sa(dp125
S'Trial_Loop.thisTrialN'
p126
I4
sg40
g66
sg45
S'2360.bmp'
p127
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p128
I4
sg21
g22
sS'Trial_Loop.thisIndex'
p129
g24
(g57
S'\x14\x00\x00\x00'
tRp130
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p131
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp132
sg49
g24
(g26
S'H\xe1z\x14\xaeG\r@'
tRp133
sS'block_loop.thisRepN'
p134
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp135
sS'block_loop.thisIndex'
p136
g58
sS'block_loop.thisN'
p137
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\xcd\xcc\xcc\xcc\xcc\xcc\x1e@'
tRp138
sg28
g11
sg44
g92
sS'block_loop.thisTrialN'
p139
I0
sa(dp140
S'Trial_Loop.thisTrialN'
p141
I5
sg40
g66
sg45
S'5600.bmp'
p142
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p143
I5
sg21
g22
sS'Trial_Loop.thisIndex'
p144
g24
(g57
S'\t\x00\x00\x00'
tRp145
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p146
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp147
sg49
g24
(g26
S'\xc3\xf5(\\\x8f\xc2\x14@'
tRp148
sS'block_loop.thisRepN'
p149
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp150
sS'block_loop.thisIndex'
p151
g58
sS'block_loop.thisN'
p152
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'H\xe1z\x14\xaeG\x1e@'
tRp153
sg28
g11
sg44
g92
sS'block_loop.thisTrialN'
p154
I0
sa(dp155
S'Trial_Loop.thisTrialN'
p156
I6
sg40
g66
sg45
S'8503.bmp'
p157
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p158
I6
sg21
g22
sS'Trial_Loop.thisIndex'
p159
g24
(g57
S'\x0c\x00\x00\x00'
tRp160
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p161
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp162
sg49
g24
(g26
S'\xe1z\x14\xaeG\xe1\x14@'
tRp163
sS'block_loop.thisRepN'
p164
I0
sg47
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp165
sS'block_loop.thisIndex'
p166
g58
sS'block_loop.thisN'
p167
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\x14\xaeG\xe1z\x14\x1c@'
tRp168
sg28
g11
sg44
g92
sS'block_loop.thisTrialN'
p169
I0
sa(dp170
S'Trial_Loop.thisTrialN'
p171
I7
sg40
g66
sg45
S'2393.bmp'
p172
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p173
I7
sg21
g22
sS'Trial_Loop.thisIndex'
p174
g24
(g57
S'\x15\x00\x00\x00'
tRp175
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p176
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp177
sg49
g24
(g26
S'q=\n\xd7\xa3p\x07@'
tRp178
sS'block_loop.thisRepN'
p179
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp180
sS'block_loop.thisIndex'
p181
g58
sS'block_loop.thisN'
p182
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'{\x14\xaeG\xe1z\x13@'
tRp183
sg28
g11
sg44
g75
sS'block_loop.thisTrialN'
p184
I0
sa(dp185
S'Trial_Loop.thisTrialN'
p186
I8
sg40
g66
sg45
S'1910.bmp'
p187
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p188
I8
sg21
g22
sS'Trial_Loop.thisIndex'
p189
g24
(g57
S'\x0f\x00\x00\x00'
tRp190
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p191
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp192
sg49
g24
(g26
S'R\xb8\x1e\x85\xebQ\n@'
tRp193
sS'block_loop.thisRepN'
p194
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp195
sS'block_loop.thisIndex'
p196
g58
sS'block_loop.thisN'
p197
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\xd7\xa3p=\n\xd7\x1a@'
tRp198
sg28
g11
sg44
g92
sS'block_loop.thisTrialN'
p199
I0
sa(dp200
S'Trial_Loop.thisTrialN'
p201
I9
sg40
g66
sg45
S'2491.bmp'
p202
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p203
I9
sg21
g22
sS'Trial_Loop.thisIndex'
p204
g24
(g57
S'\x16\x00\x00\x00'
tRp205
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p206
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp207
sg49
g24
(g26
S'H\xe1z\x14\xaeG\x0b@'
tRp208
sS'block_loop.thisRepN'
p209
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp210
sS'block_loop.thisIndex'
p211
g58
sS'block_loop.thisN'
p212
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\x8f\xc2\xf5(\\\x8f\x10@'
tRp213
sg28
g11
sg44
g75
sS'block_loop.thisTrialN'
p214
I0
sa(dp215
S'Trial_Loop.thisTrialN'
p216
I10
sg40
g66
sg45
S'2560.bmp'
p217
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p218
I10
sg21
g22
sS'Trial_Loop.thisIndex'
p219
g24
(g57
S'\x17\x00\x00\x00'
tRp220
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p221
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp222
sg49
g24
(g26
S'\xecQ\xb8\x1e\x85\xeb\x0b@'
tRp223
sS'block_loop.thisRepN'
p224
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp225
sS'block_loop.thisIndex'
p226
g58
sS'block_loop.thisN'
p227
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\\\x8f\xc2\xf5(\\\x19@'
tRp228
sg28
g11
sg44
g92
sS'block_loop.thisTrialN'
p229
I0
sa(dp230
S'Trial_Loop.thisTrialN'
p231
I11
sg40
g66
sg45
S'7550.bmp'
p232
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p233
I11
sg21
g22
sS'Trial_Loop.thisIndex'
p234
g24
(g57
S'\x19\x00\x00\x00'
tRp235
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p236
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp237
sg49
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\x0f@'
tRp238
sS'block_loop.thisRepN'
p239
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp240
sS'block_loop.thisIndex'
p241
g58
sS'block_loop.thisN'
p242
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\x14\xaeG\xe1z\x14\x15@'
tRp243
sg28
g11
sg44
g75
sS'block_loop.thisTrialN'
p244
I0
sa(dp245
S'Trial_Loop.thisTrialN'
p246
I12
sg40
g66
sg45
S'2020.bmp'
p247
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p248
I12
sg21
g22
sS'Trial_Loop.thisIndex'
p249
g24
(g57
S'\x10\x00\x00\x00'
tRp250
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p251
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp252
sg49
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\n@'
tRp253
sS'block_loop.thisRepN'
p254
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp255
sS'block_loop.thisIndex'
p256
g58
sS'block_loop.thisN'
p257
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x16@'
tRp258
sg28
g11
sg44
g75
sS'block_loop.thisTrialN'
p259
I0
sa(dp260
S'Trial_Loop.thisTrialN'
p261
I13
sg40
g66
sg45
S'2120.bmp'
p262
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p263
I13
sg21
g22
sS'Trial_Loop.thisIndex'
p264
g24
(g57
S'\x01\x00\x00\x00'
tRp265
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p266
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp267
sg49
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x14@'
tRp268
sS'block_loop.thisRepN'
p269
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp270
sS'block_loop.thisIndex'
p271
g58
sS'block_loop.thisN'
p272
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\n@'
tRp273
sg28
g11
sg44
g123
sS'block_loop.thisTrialN'
p274
I0
sa(dp275
S'Trial_Loop.thisTrialN'
p276
I14
sg40
g66
sg45
S'3181.bmp'
p277
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p278
I14
sg21
g22
sS'Trial_Loop.thisIndex'
p279
g24
(g57
S'\x06\x00\x00\x00'
tRp280
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p281
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp282
sg49
g24
(g26
S'=\n\xd7\xa3p=\x14@'
tRp283
sS'block_loop.thisRepN'
p284
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp285
sS'block_loop.thisIndex'
p286
g58
sS'block_loop.thisN'
p287
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'ffffff\x02@'
tRp288
sg28
g11
sg44
g123
sS'block_loop.thisTrialN'
p289
I0
sa(dp290
S'Trial_Loop.thisTrialN'
p291
I15
sg40
g66
sg45
S'2215.bmp'
p292
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p293
I15
sg21
g22
sS'Trial_Loop.thisIndex'
p294
g24
(g57
S'\x12\x00\x00\x00'
tRp295
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p296
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp297
sg49
g24
(g26
S'\n\xd7\xa3p=\n\x0b@'
tRp298
sS'block_loop.thisRepN'
p299
I0
sg47
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp300
sS'block_loop.thisIndex'
p301
g58
sS'block_loop.thisN'
p302
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x12@'
tRp303
sg28
g11
sg44
g75
sS'block_loop.thisTrialN'
p304
I0
sa(dp305
S'Trial_Loop.thisTrialN'
p306
I16
sg40
g66
sg45
S'2890.bmp'
p307
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p308
I16
sg21
g22
sS'Trial_Loop.thisIndex'
p309
g24
(g57
S'\x18\x00\x00\x00'
tRp310
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p311
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp312
sg49
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\x07@'
tRp313
sS'block_loop.thisRepN'
p314
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp315
sS'block_loop.thisIndex'
p316
g58
sS'block_loop.thisN'
p317
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\xcd\xcc\xcc\xcc\xcc\xcc\x13@'
tRp318
sg28
g11
sg44
g75
sS'block_loop.thisTrialN'
p319
I0
sa(dp320
S'Trial_Loop.thisTrialN'
p321
I17
sg40
g66
sg45
S'9220.bmp'
p322
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p323
I17
sg21
g22
sS'Trial_Loop.thisIndex'
p324
g24
(g57
S'\x1c\x00\x00\x00'
tRp325
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p326
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp327
sg49
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x10@'
tRp328
sS'block_loop.thisRepN'
p329
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp330
sS'block_loop.thisIndex'
p331
g58
sS'block_loop.thisN'
p332
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'{\x14\xaeG\xe1z\x00@'
tRp333
sg28
g11
sg44
g123
sS'block_loop.thisTrialN'
p334
I0
sa(dp335
S'Trial_Loop.thisTrialN'
p336
I18
sg40
g66
sg45
S'2205.bmp'
p337
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p338
I18
sg21
g22
sS'Trial_Loop.thisIndex'
p339
g24
(g57
S'\x02\x00\x00\x00'
tRp340
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p341
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp342
sg49
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x12@'
tRp343
sS'block_loop.thisRepN'
p344
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp345
sS'block_loop.thisIndex'
p346
g58
sS'block_loop.thisN'
p347
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'333333\xff?'
tRp348
sg28
g11
sg44
g123
sS'block_loop.thisTrialN'
p349
I0
sa(dp350
S'Trial_Loop.thisTrialN'
p351
I19
sg40
g66
sg45
S'3210.bmp'
p352
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p353
I19
sg21
g22
sS'Trial_Loop.thisIndex'
p354
g24
(g57
S'\x07\x00\x00\x00'
tRp355
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p356
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp357
sg49
g24
(g26
S'\x8f\xc2\xf5(\\\x8f\x15@'
tRp358
sS'block_loop.thisRepN'
p359
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp360
sS'block_loop.thisIndex'
p361
g58
sS'block_loop.thisN'
p362
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\xf6(\\\x8f\xc2\xf5\x11@'
tRp363
sg28
g11
sg44
g75
sS'block_loop.thisTrialN'
p364
I0
sa(dp365
S'Trial_Loop.thisTrialN'
p366
I20
sg40
g66
sg45
S'9041.bmp'
p367
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p368
I20
sg21
g22
sS'Trial_Loop.thisIndex'
p369
g24
(g57
S'\r\x00\x00\x00'
tRp370
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p371
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp372
sg49
g24
(g26
S'\x8f\xc2\xf5(\\\x8f\x12@'
tRp373
sS'block_loop.thisRepN'
p374
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp375
sS'block_loop.thisIndex'
p376
g58
sS'block_loop.thisN'
p377
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\xd7\xa3p=\n\xd7\x07@'
tRp378
sg28
g11
sg44
g123
sS'block_loop.thisTrialN'
p379
I0
sa(dp380
S'Trial_Loop.thisTrialN'
p381
I21
sg40
g66
sg45
S'8330.bmp'
p382
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p383
I21
sg21
g22
sS'Trial_Loop.thisIndex'
p384
g24
(g57
S'\x1a\x00\x00\x00'
tRp385
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p386
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp387
sg49
g24
(g26
S'=\n\xd7\xa3p=\x10@'
tRp388
sS'block_loop.thisRepN'
p389
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp390
sS'block_loop.thisIndex'
p391
g58
sS'block_loop.thisN'
p392
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\x1a@'
tRp393
sg28
g11
sg44
g92
sS'block_loop.thisTrialN'
p394
I0
sa(dp395
S'Trial_Loop.thisTrialN'
p396
I22
sg40
g66
sg45
S'2214.bmp'
p397
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p398
I22
sg21
g22
sS'Trial_Loop.thisIndex'
p399
g24
(g57
S'\x11\x00\x00\x00'
tRp400
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p401
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp402
sg49
g24
(g26
S'\xaeG\xe1z\x14\xae\x0b@'
tRp403
sS'block_loop.thisRepN'
p404
I0
sg47
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp405
sS'block_loop.thisIndex'
p406
g58
sS'block_loop.thisN'
p407
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\n\xd7\xa3p=\n\x14@'
tRp408
sg28
g11
sg44
g75
sS'block_loop.thisTrialN'
p409
I0
sa(dp410
S'Trial_Loop.thisTrialN'
p411
I23
sg40
g66
sg45
S'2800.bmp'
p412
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p413
I23
sg21
g22
sS'Trial_Loop.thisIndex'
p414
g24
(g57
S'\x05\x00\x00\x00'
tRp415
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p416
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp417
sg49
g24
(g26
S'\xf6(\\\x8f\xc2\xf5\x15@'
tRp418
sS'block_loop.thisRepN'
p419
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp420
sS'block_loop.thisIndex'
p421
g58
sS'block_loop.thisN'
p422
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'{\x14\xaeG\xe1z\xfc?'
tRp423
sg28
g11
sg44
g123
sS'block_loop.thisTrialN'
p424
I0
sa(dp425
S'Trial_Loop.thisTrialN'
p426
I24
sg40
g66
sg45
S'9210.bmp'
p427
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p428
I24
sg21
g22
sS'Trial_Loop.thisIndex'
p429
g24
(g57
S'\x1b\x00\x00\x00'
tRp430
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p431
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp432
sg49
g24
(g26
S'\xa4p=\n\xd7\xa3\x08@'
tRp433
sS'block_loop.thisRepN'
p434
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp435
sS'block_loop.thisIndex'
p436
g58
sS'block_loop.thisN'
p437
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x12@'
tRp438
sg28
g11
sg44
g75
sS'block_loop.thisTrialN'
p439
I0
sa(dp440
S'Trial_Loop.thisTrialN'
p441
I25
sg40
g66
sg45
S'9341.bmp'
p442
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p443
I25
sg21
g22
sS'Trial_Loop.thisIndex'
p444
g24
(g57
S'\x1d\x00\x00\x00'
tRp445
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p446
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp447
sg49
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x12@'
tRp448
sS'block_loop.thisRepN'
p449
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp450
sS'block_loop.thisIndex'
p451
g58
sS'block_loop.thisN'
p452
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\n\xd7\xa3p=\n\x0b@'
tRp453
sg28
g11
sg44
g123
sS'block_loop.thisTrialN'
p454
I0
sa(dp455
S'Trial_Loop.thisTrialN'
p456
I26
sg40
g66
sg45
S'3301.bmp'
p457
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p458
I26
sg21
g22
sS'Trial_Loop.thisIndex'
p459
g24
(g57
S'\x08\x00\x00\x00'
tRp460
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p461
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp462
sg49
g24
(g26
S'\xd7\xa3p=\n\xd7\x14@'
tRp463
sS'block_loop.thisRepN'
p464
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp465
sS'block_loop.thisIndex'
p466
g58
sS'block_loop.thisN'
p467
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\xcd\xcc\xcc\xcc\xcc\xcc\xfc?'
tRp468
sg28
g11
sg44
g123
sS'block_loop.thisTrialN'
p469
I0
sa(dp470
S'Trial_Loop.thisTrialN'
p471
I27
sg40
g66
sg45
S'2703.bmp'
p472
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p473
I27
sg21
g22
sS'Trial_Loop.thisIndex'
p474
g24
(g57
S'\x04\x00\x00\x00'
tRp475
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p476
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp477
sg49
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x17@'
tRp478
sS'block_loop.thisRepN'
p479
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp480
sS'block_loop.thisIndex'
p481
g58
sS'block_loop.thisN'
p482
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\x8f\xc2\xf5(\\\x8f\xfe?'
tRp483
sg28
g11
sg44
g123
sS'block_loop.thisTrialN'
p484
I0
sa(dp485
S'Trial_Loop.thisTrialN'
p486
I28
sg40
g66
sg45
S'2655.bmp'
p487
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p488
I28
sg21
g22
sS'Trial_Loop.thisIndex'
p489
g24
(g57
S'\x03\x00\x00\x00'
tRp490
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p491
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp492
sg49
g24
(g26
S'H\xe1z\x14\xaeG\x12@'
tRp493
sS'block_loop.thisRepN'
p494
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp495
sS'block_loop.thisIndex'
p496
g58
sS'block_loop.thisN'
p497
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x1b@'
tRp498
sg28
g11
sg44
g92
sS'block_loop.thisTrialN'
p499
I0
sa(dp500
S'Trial_Loop.thisTrialN'
p501
I29
sg40
g66
sg45
S'8090.bmp'
p502
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p503
I29
sg21
g22
sS'Trial_Loop.thisIndex'
p504
g24
(g57
S'\n\x00\x00\x00'
tRp505
sg46
g83
sg29
g30
sS'Trial_Loop.thisRepN'
p506
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp507
sg49
g24
(g26
S'\xd7\xa3p=\n\xd7\x16@'
tRp508
sS'block_loop.thisRepN'
p509
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp510
sS'block_loop.thisIndex'
p511
g58
sS'block_loop.thisN'
p512
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\x14\xaeG\xe1z\x14\x1c@'
tRp513
sg28
g11
sg44
g92
sS'block_loop.thisTrialN'
p514
I0
sa(dp515
S'block_loop.thisRepN'
p516
I0
sg29
g30
sS'Break_loop.thisTrialN'
p517
I0
sg40
g66
sS'block_loop.thisIndex'
p518
g58
sg16
S'space'
p519
sg23
g27
sS'block_loop.thisN'
p520
I0
sg41
g72
sg39
g76
sS'Break_loop.thisRepN'
p521
I0
sg28
g11
sg42
g60
sg21
g22
sS'Break_loop.thisIndex'
p522
g24
(g57
S'\x00\x00\x00\x00'
tRp523
sS'Break_loop.thisN'
p524
I0
sg17
F2.4667325340683419
sS'Break_loop.thisTrial'
p525
NsS'block_loop.thisTrialN'
p526
I0
sa(dp527
S'block_loop.thisRepN'
p528
I0
sg29
g30
sS'block_loop.thisIndex'
p529
g58
sg23
g27
sS'block_loop.thisN'
p530
I0
sg41
g72
sS'block_loop.thisTrialN'
p531
I0
sg28
g11
sg42
g60
sg21
g22
sg39
g76
sg40
g66
sa(dp532
S'Trial_Loop.thisTrialN'
p533
I0
sS'blocknum'
p534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp535
sg15
F3.3333759534168621
sS'block_loop.thisIndex'
p536
g24
(g57
S'\x01\x00\x00\x00'
tRp537
sg14
S'space'
p538
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p539
I0
sg21
g22
sS'Trial_Loop.thisIndex'
p540
g24
(g57
S'\x0b\x00\x00\x00'
tRp541
sS'arousal'
p542
S'High'
p543
sg29
g30
sS'Trial_Loop.thisRepN'
p544
I0
sg40
S'cont_inst'
p545
sS'arousalmean'
p546
g24
(g26
S')\\\x8f\xc2\xf5(\x14@'
tRp547
sS'block_loop.thisRepN'
p548
I0
sS'outliers'
p549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp550
sS'scenestim'
p551
S'9421.bmp'
p552
sS'block_loop.thisN'
p553
I1
sg41
S'procedure\\1.csv'
p554
sS'block_loop.thisTrialN'
p555
I1
sS'valmean'
p556
g24
(g26
S'\xaeG\xe1z\x14\xae\x01@'
tRp557
sg28
g11
sS'valence'
p558
S'Negative'
p559
sg39
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp560
sa(dp561
S'Trial_Loop.thisTrialN'
p562
I1
sg40
g545
sg551
S'2750.bmp'
p563
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p564
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p565
g24
(g57
S'\x1a\x00\x00\x00'
tRp566
sg542
S'Low'
p567
sg29
g30
sS'Trial_Loop.thisRepN'
p568
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp569
sg546
g24
(g26
S'=\n\xd7\xa3p=\x11@'
tRp570
sS'block_loop.thisRepN'
p571
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp572
sS'block_loop.thisIndex'
p573
g537
sS'block_loop.thisN'
p574
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'{\x14\xaeG\xe1z\x04@'
tRp575
sg28
g11
sg558
g559
sS'block_loop.thisTrialN'
p576
I1
sa(dp577
S'Trial_Loop.thisTrialN'
p578
I2
sg40
g545
sg551
S'8280.bmp'
p579
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p580
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p581
g24
(g57
S'\x08\x00\x00\x00'
tRp582
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p583
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp584
sg546
g24
(g26
S'333333\x14@'
tRp585
sS'block_loop.thisRepN'
p586
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp587
sS'block_loop.thisIndex'
p588
g537
sS'block_loop.thisN'
p589
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x19@'
tRp590
sg28
g11
sg558
S'Positive'
p591
sS'block_loop.thisTrialN'
p592
I1
sa(dp593
S'Trial_Loop.thisTrialN'
p594
I3
sg40
g545
sg551
S'2208.bmp'
p595
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p596
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p597
g24
(g57
S'\x00\x00\x00\x00'
tRp598
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p599
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp600
sg546
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x16@'
tRp601
sS'block_loop.thisRepN'
p602
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp603
sS'block_loop.thisIndex'
p604
g537
sS'block_loop.thisN'
p605
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'ffffff\x1d@'
tRp606
sg28
g11
sg558
g591
sS'block_loop.thisTrialN'
p607
I1
sa(dp608
S'Trial_Loop.thisTrialN'
p609
I4
sg40
g545
sg551
S'9040.bmp'
p610
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p611
I4
sg21
g22
sS'Trial_Loop.thisIndex'
p612
g24
(g57
S'\n\x00\x00\x00'
tRp613
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p614
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp615
sg546
g24
(g26
S'H\xe1z\x14\xaeG\x17@'
tRp616
sS'block_loop.thisRepN'
p617
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp618
sS'block_loop.thisIndex'
p619
g537
sS'block_loop.thisN'
p620
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\xfa?'
tRp621
sg28
g11
sg558
g559
sS'block_loop.thisTrialN'
p622
I1
sa(dp623
S'Trial_Loop.thisTrialN'
p624
I5
sg40
g545
sg551
S'9101.bmp'
p625
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p626
I5
sg21
g22
sS'Trial_Loop.thisIndex'
p627
g24
(g57
S'\x1d\x00\x00\x00'
tRp628
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p629
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp630
sg546
g24
(g26
S'\x14\xaeG\xe1z\x14\x10@'
tRp631
sS'block_loop.thisRepN'
p632
I0
sg549
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp633
sS'block_loop.thisIndex'
p634
g537
sS'block_loop.thisN'
p635
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\xf6(\\\x8f\xc2\xf5\x0c@'
tRp636
sg28
g11
sg558
g559
sS'block_loop.thisTrialN'
p637
I1
sa(dp638
S'Trial_Loop.thisTrialN'
p639
I6
sg40
g545
sg551
S'2220.bmp'
p640
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p641
I6
sg21
g22
sS'Trial_Loop.thisIndex'
p642
g24
(g57
S'\x01\x00\x00\x00'
tRp643
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p644
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp645
sg546
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x13@'
tRp646
sS'block_loop.thisRepN'
p647
I0
sg549
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp648
sS'block_loop.thisIndex'
p649
g537
sS'block_loop.thisN'
p650
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x14@'
tRp651
sg28
g11
sg558
S'Neutral'
p652
sS'block_loop.thisTrialN'
p653
I1
sa(dp654
S'Trial_Loop.thisTrialN'
p655
I7
sg40
g545
sg551
S'6838.bmp'
p656
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p657
I7
sg21
g22
sS'Trial_Loop.thisIndex'
p658
g24
(g57
S'\x06\x00\x00\x00'
tRp659
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p660
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp661
sg546
g24
(g26
S'333333\x17@'
tRp662
sS'block_loop.thisRepN'
p663
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp664
sS'block_loop.thisIndex'
p665
g537
sS'block_loop.thisN'
p666
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\x03@'
tRp667
sg28
g11
sg558
g559
sS'block_loop.thisTrialN'
p668
I1
sa(dp669
S'Trial_Loop.thisTrialN'
p670
I8
sg40
g545
sg551
S'2493.bmp'
p671
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p672
I8
sg21
g22
sS'Trial_Loop.thisIndex'
p673
g24
(g57
S'\x14\x00\x00\x00'
tRp674
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p675
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp676
sg546
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\n@'
tRp677
sS'block_loop.thisRepN'
p678
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp679
sS'block_loop.thisIndex'
p680
g537
sS'block_loop.thisN'
p681
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'H\xe1z\x14\xaeG\x13@'
tRp682
sg28
g11
sg558
g652
sS'block_loop.thisTrialN'
p683
I1
sa(dp684
S'Trial_Loop.thisTrialN'
p685
I9
sg40
g545
sg551
S'2650.bmp'
p686
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p687
I9
sg21
g22
sS'Trial_Loop.thisIndex'
p688
g24
(g57
S'\x18\x00\x00\x00'
tRp689
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p690
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp691
sg546
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x11@'
tRp692
sS'block_loop.thisRepN'
p693
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp694
sS'block_loop.thisIndex'
p695
g537
sS'block_loop.thisN'
p696
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\x14\xaeG\xe1z\x14\x1d@'
tRp697
sg28
g11
sg558
g591
sS'block_loop.thisTrialN'
p698
I1
sa(dp699
S'Trial_Loop.thisTrialN'
p700
I10
sg40
g545
sg551
S'2501.bmp'
p701
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p702
I10
sg21
g22
sS'Trial_Loop.thisIndex'
p703
g24
(g57
S'\x15\x00\x00\x00'
tRp704
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p705
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp706
sg546
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x08@'
tRp707
sS'block_loop.thisRepN'
p708
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp709
sS'block_loop.thisIndex'
p710
g537
sS'block_loop.thisN'
p711
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\x8f\xc2\xf5(\\\x8f\x1b@'
tRp712
sg28
g11
sg558
g591
sS'block_loop.thisTrialN'
p713
I1
sa(dp714
S'Trial_Loop.thisTrialN'
p715
I11
sg40
g545
sg551
S'8371.bmp'
p716
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p717
I11
sg21
g22
sS'Trial_Loop.thisIndex'
p718
g24
(g57
S'\t\x00\x00\x00'
tRp719
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p720
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp721
sg546
g24
(g26
S'{\x14\xaeG\xe1z\x14@'
tRp722
sS'block_loop.thisRepN'
p723
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp724
sS'block_loop.thisIndex'
p725
g537
sS'block_loop.thisN'
p726
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'H\xe1z\x14\xaeG\x1b@'
tRp727
sg28
g11
sg558
g591
sS'block_loop.thisTrialN'
p728
I1
sa(dp729
S'Trial_Loop.thisTrialN'
p730
I12
sg40
g545
sg551
S'3180.bmp'
p731
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p732
I12
sg21
g22
sS'Trial_Loop.thisIndex'
p733
g24
(g57
S'\x03\x00\x00\x00'
tRp734
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p735
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp736
sg546
g24
(g26
S'\x14\xaeG\xe1z\x14\x17@'
tRp737
sS'block_loop.thisRepN'
p738
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp739
sS'block_loop.thisIndex'
p740
g537
sS'block_loop.thisN'
p741
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\xfe?'
tRp742
sg28
g11
sg558
g559
sS'block_loop.thisTrialN'
p743
I1
sa(dp744
S'Trial_Loop.thisTrialN'
p745
I13
sg40
g545
sg551
S'6311.bmp'
p746
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p747
I13
sg21
g22
sS'Trial_Loop.thisIndex'
p748
g24
(g57
S'\x05\x00\x00\x00'
tRp749
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p750
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp751
sg546
g24
(g26
S'\xcd\xcc\xcc\xcc\xcc\xcc\x13@'
tRp752
sS'block_loop.thisRepN'
p753
I0
sg549
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp754
sS'block_loop.thisIndex'
p755
g537
sS'block_loop.thisN'
p756
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\xa4p=\n\xd7\xa3\x04@'
tRp757
sg28
g11
sg558
g559
sS'block_loop.thisTrialN'
p758
I1
sa(dp759
S'Trial_Loop.thisTrialN'
p760
I14
sg40
g545
sg551
S'4640.bmp'
p761
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p762
I14
sg21
g22
sS'Trial_Loop.thisIndex'
p763
g24
(g57
S'\x04\x00\x00\x00'
tRp764
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p765
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp766
sg546
g24
(g26
S'\x14\xaeG\xe1z\x14\x16@'
tRp767
sS'block_loop.thisRepN'
p768
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp769
sS'block_loop.thisIndex'
p770
g537
sS'block_loop.thisN'
p771
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x1c@'
tRp772
sg28
g11
sg558
g591
sS'block_loop.thisTrialN'
p773
I1
sa(dp774
S'Trial_Loop.thisTrialN'
p775
I15
sg40
g545
sg551
S'9560.bmp'
p776
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p777
I15
sg21
g22
sS'Trial_Loop.thisIndex'
p778
g24
(g57
S'\r\x00\x00\x00'
tRp779
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p780
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp781
sg546
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x16@'
tRp782
sS'block_loop.thisRepN'
p783
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp784
sS'block_loop.thisIndex'
p785
g537
sS'block_loop.thisN'
p786
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\xf6(\\\x8f\xc2\xf5\x00@'
tRp787
sg28
g11
sg558
g559
sS'block_loop.thisTrialN'
p788
I1
sa(dp789
S'Trial_Loop.thisTrialN'
p790
I16
sg40
g545
sg551
S'2441.bmp'
p791
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p792
I16
sg21
g22
sS'Trial_Loop.thisIndex'
p793
g24
(g57
S'\x13\x00\x00\x00'
tRp794
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p795
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp796
sg546
g24
(g26
S'\xf6(\\\x8f\xc2\xf5\x0c@'
tRp797
sS'block_loop.thisRepN'
p798
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp799
sS'block_loop.thisIndex'
p800
g537
sS'block_loop.thisN'
p801
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\x8f\xc2\xf5(\\\x8f\x12@'
tRp802
sg28
g11
sg558
g652
sS'block_loop.thisTrialN'
p803
I1
sa(dp804
S'Trial_Loop.thisTrialN'
p805
I17
sg40
g545
sg551
S'2850.bmp'
p806
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p807
I17
sg21
g22
sS'Trial_Loop.thisIndex'
p808
g24
(g57
S'\x1b\x00\x00\x00'
tRp809
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p810
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp811
sg546
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x08@'
tRp812
sS'block_loop.thisRepN'
p813
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp814
sS'block_loop.thisIndex'
p815
g537
sS'block_loop.thisN'
p816
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\xe1z\x14\xaeG\xe1\x14@'
tRp817
sg28
g11
sg558
g652
sS'block_loop.thisTrialN'
p818
I1
sa(dp819
S'Trial_Loop.thisTrialN'
p820
I18
sg40
g545
sg551
S'9435.bmp'
p821
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p822
I18
sg21
g22
sS'Trial_Loop.thisIndex'
p823
g24
(g57
S'\x0c\x00\x00\x00'
tRp824
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p825
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp826
sg546
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x14@'
tRp827
sS'block_loop.thisRepN'
p828
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp829
sS'block_loop.thisIndex'
p830
g537
sS'block_loop.thisN'
p831
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S')\\\x8f\xc2\xf5(\x02@'
tRp832
sg28
g11
sg558
g559
sS'block_loop.thisTrialN'
p833
I1
sa(dp834
S'Trial_Loop.thisTrialN'
p835
I19
sg40
g545
sg551
S'2383.bmp'
p836
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p837
I19
sg21
g22
sS'Trial_Loop.thisIndex'
p838
g24
(g57
S'\x12\x00\x00\x00'
tRp839
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p840
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp841
sg546
g24
(g26
S'H\xe1z\x14\xaeG\x0b@'
tRp842
sS'block_loop.thisRepN'
p843
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp844
sS'block_loop.thisIndex'
p845
g537
sS'block_loop.thisN'
p846
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\xe1z\x14\xaeG\xe1\x12@'
tRp847
sg28
g11
sg558
g652
sS'block_loop.thisTrialN'
p848
I1
sa(dp849
S'Trial_Loop.thisTrialN'
p850
I20
sg40
g545
sg551
S'2514.bmp'
p851
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p852
I20
sg21
g22
sS'Trial_Loop.thisIndex'
p853
g24
(g57
S'\x16\x00\x00\x00'
tRp854
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p855
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp856
sg546
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x0c@'
tRp857
sS'block_loop.thisRepN'
p858
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp859
sS'block_loop.thisIndex'
p860
g537
sS'block_loop.thisN'
p861
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\xc3\xf5(\\\x8f\xc2\x14@'
tRp862
sg28
g11
sg558
g652
sS'block_loop.thisTrialN'
p863
I1
sa(dp864
S'Trial_Loop.thisTrialN'
p865
I21
sg40
g545
sg551
S'2749.bmp'
p866
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p867
I21
sg21
g22
sS'Trial_Loop.thisIndex'
p868
g24
(g57
S'\x19\x00\x00\x00'
tRp869
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p870
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp871
sg546
g24
(g26
S'\x14\xaeG\xe1z\x14\x0e@'
tRp872
sS'block_loop.thisRepN'
p873
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp874
sS'block_loop.thisIndex'
p875
g537
sS'block_loop.thisN'
p876
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S')\\\x8f\xc2\xf5(\x14@'
tRp877
sg28
g11
sg558
g652
sS'block_loop.thisTrialN'
p878
I1
sa(dp879
S'Trial_Loop.thisTrialN'
p880
I22
sg40
g545
sg551
S'2200.bmp'
p881
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p882
I22
sg21
g22
sS'Trial_Loop.thisIndex'
p883
g24
(g57
S'\x0f\x00\x00\x00'
tRp884
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p885
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp886
sg546
g24
(g26
S'q=\n\xd7\xa3p\t@'
tRp887
sS'block_loop.thisRepN'
p888
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp889
sS'block_loop.thisIndex'
p890
g537
sS'block_loop.thisN'
p891
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S')\\\x8f\xc2\xf5(\x13@'
tRp892
sg28
g11
sg558
g652
sS'block_loop.thisTrialN'
p893
I1
sa(dp894
S'Trial_Loop.thisTrialN'
p895
I23
sg40
g545
sg551
S'2311.bmp'
p896
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p897
I23
sg21
g22
sS'Trial_Loop.thisIndex'
p898
g24
(g57
S'\x11\x00\x00\x00'
tRp899
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p900
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp901
sg546
g24
(g26
S'\xaeG\xe1z\x14\xae\x11@'
tRp902
sS'block_loop.thisRepN'
p903
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp904
sS'block_loop.thisIndex'
p905
g537
sS'block_loop.thisN'
p906
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S')\\\x8f\xc2\xf5(\x1e@'
tRp907
sg28
g11
sg558
g591
sS'block_loop.thisTrialN'
p908
I1
sa(dp909
S'Trial_Loop.thisTrialN'
p910
I24
sg40
g545
sg551
S'2520.bmp'
p911
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p912
I24
sg21
g22
sS'Trial_Loop.thisIndex'
p913
g24
(g57
S'\x17\x00\x00\x00'
tRp914
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p915
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp916
sg546
g24
(g26
S'\xe1z\x14\xaeG\xe1\x10@'
tRp917
sS'block_loop.thisRepN'
p918
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp919
sS'block_loop.thisIndex'
p920
g537
sS'block_loop.thisN'
p921
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x10@'
tRp922
sg28
g11
sg558
g652
sS'block_loop.thisTrialN'
p923
I1
sa(dp924
S'Trial_Loop.thisTrialN'
p925
I25
sg40
g545
sg551
S'2550.bmp'
p926
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p927
I25
sg21
g22
sS'Trial_Loop.thisIndex'
p928
g24
(g57
S'\x02\x00\x00\x00'
tRp929
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p930
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp931
sg546
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x12@'
tRp932
sS'block_loop.thisRepN'
p933
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp934
sS'block_loop.thisIndex'
p935
g537
sS'block_loop.thisN'
p936
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\x14\xaeG\xe1z\x14\x1f@'
tRp937
sg28
g11
sg558
g591
sS'block_loop.thisTrialN'
p938
I1
sa(dp939
S'Trial_Loop.thisTrialN'
p940
I26
sg40
g545
sg551
S'7480.bmp'
p941
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p942
I26
sg21
g22
sS'Trial_Loop.thisIndex'
p943
g24
(g57
S'\x07\x00\x00\x00'
tRp944
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p945
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp946
sg546
g24
(g26
S'333333\x12@'
tRp947
sS'block_loop.thisRepN'
p948
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp949
sS'block_loop.thisIndex'
p950
g537
sS'block_loop.thisN'
p951
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'R\xb8\x1e\x85\xebQ\x1c@'
tRp952
sg28
g11
sg558
g591
sS'block_loop.thisTrialN'
p953
I1
sa(dp954
S'Trial_Loop.thisTrialN'
p955
I27
sg40
g545
sg551
S'9830.bmp'
p956
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p957
I27
sg21
g22
sS'Trial_Loop.thisIndex'
p958
g24
(g57
S'\x0e\x00\x00\x00'
tRp959
sg542
g543
sg29
g30
sS'Trial_Loop.thisRepN'
p960
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp961
sg546
g24
(g26
S'q=\n\xd7\xa3p\x13@'
tRp962
sS'block_loop.thisRepN'
p963
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp964
sS'block_loop.thisIndex'
p965
g537
sS'block_loop.thisN'
p966
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'R\xb8\x1e\x85\xebQ\x04@'
tRp967
sg28
g11
sg558
g559
sS'block_loop.thisTrialN'
p968
I1
sa(dp969
S'Trial_Loop.thisTrialN'
p970
I28
sg40
g545
sg551
S'2221.bmp'
p971
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p972
I28
sg21
g22
sS'Trial_Loop.thisIndex'
p973
g24
(g57
S'\x10\x00\x00\x00'
tRp974
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p975
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp976
sg546
g24
(g26
S'\x8f\xc2\xf5(\\\x8f\x08@'
tRp977
sS'block_loop.thisRepN'
p978
I0
sg549
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp979
sS'block_loop.thisIndex'
p980
g537
sS'block_loop.thisN'
p981
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'\x8f\xc2\xf5(\\\x8f\x11@'
tRp982
sg28
g11
sg558
g652
sS'block_loop.thisTrialN'
p983
I1
sa(dp984
S'Trial_Loop.thisTrialN'
p985
I29
sg40
g545
sg551
S'5750.bmp'
p986
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p987
I29
sg21
g22
sS'Trial_Loop.thisIndex'
p988
g24
(g57
S'\x1c\x00\x00\x00'
tRp989
sg542
g567
sg29
g30
sS'Trial_Loop.thisRepN'
p990
I0
sg534
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp991
sg546
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\t@'
tRp992
sS'block_loop.thisRepN'
p993
I0
sg549
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp994
sS'block_loop.thisIndex'
p995
g537
sS'block_loop.thisN'
p996
I1
sg41
g554
sg39
g560
sg556
g24
(g26
S'ffffff\x1a@'
tRp997
sg28
g11
sg558
g591
sS'block_loop.thisTrialN'
p998
I1
sa(dp999
S'block_loop.thisRepN'
p1000
I0
sg29
g30
sS'Break_loop.thisTrialN'
p1001
I0
sg40
g545
sS'block_loop.thisIndex'
p1002
g537
sg16
S'space'
p1003
sg23
g27
sS'block_loop.thisN'
p1004
I1
sg41
g554
sg39
g560
sS'Break_loop.thisRepN'
p1005
I0
sg28
g11
sg42
g60
sg21
g22
sS'Break_loop.thisIndex'
p1006
g24
(g57
S'\x00\x00\x00\x00'
tRp1007
sS'Break_loop.thisN'
p1008
I0
sg17
F3.0917746006443849
sS'Break_loop.thisTrial'
p1009
NsS'block_loop.thisTrialN'
p1010
I1
sa(dp1011
S'block_loop.thisRepN'
p1012
I0
sg29
g30
sS'block_loop.thisIndex'
p1013
g537
sg23
g27
sS'block_loop.thisN'
p1014
I1
sg41
g554
sS'block_loop.thisTrialN'
p1015
I1
sg28
g11
sg42
g60
sg21
g22
sg39
g560
sg40
g545
sa(dp1016
S'Trial_Loop.thisTrialN'
p1017
I0
sS'blocknum'
p1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1019
sg15
F3.0917552278788207
sS'block_loop.thisIndex'
p1020
g24
(g57
S'\x02\x00\x00\x00'
tRp1021
sg14
S'space'
p1022
sg42
S'blank'
p1023
sg23
g27
sS'Trial_Loop.thisN'
p1024
I0
sg21
g22
sS'Trial_Loop.thisIndex'
p1025
g24
(g57
S'\x06\x00\x00\x00'
tRp1026
sS'arousal'
p1027
S'High'
p1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1029
I0
sg40
g545
sS'arousalmean'
p1030
g24
(g26
S'\xa4p=\n\xd7\xa3\x15@'
tRp1031
sS'block_loop.thisRepN'
p1032
I0
sS'outliers'
p1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1034
sS'scenestim'
p1035
S'3230.bmp'
p1036
sS'block_loop.thisN'
p1037
I2
sg41
S'procedure\\2.csv'
p1038
sS'block_loop.thisTrialN'
p1039
I2
sS'valmean'
p1040
g24
(g26
S')\\\x8f\xc2\xf5(\x00@'
tRp1041
sg28
g11
sS'valence'
p1042
S'Negative'
p1043
sg39
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1044
sa(dp1045
S'Trial_Loop.thisTrialN'
p1046
I1
sg40
g545
sg1035
S'4653.bmp'
p1047
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1048
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p1049
g24
(g57
S'\t\x00\x00\x00'
tRp1050
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1051
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1052
sg1030
g24
(g26
S'R\xb8\x1e\x85\xebQ\x17@'
tRp1053
sS'block_loop.thisRepN'
p1054
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1055
sS'block_loop.thisIndex'
p1056
g1021
sS'block_loop.thisN'
p1057
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'=\n\xd7\xa3p=\x1a@'
tRp1058
sg28
g11
sg1042
S'Positive'
p1059
sS'block_loop.thisTrialN'
p1060
I2
sa(dp1061
S'Trial_Loop.thisTrialN'
p1062
I2
sg40
g545
sg1035
S'2579.bmp'
p1063
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1064
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p1065
g24
(g57
S'\x17\x00\x00\x00'
tRp1066
sg1027
S'Low'
p1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1068
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1069
sg1030
g24
(g26
S'\xcd\xcc\xcc\xcc\xcc\xcc\x0e@'
tRp1070
sS'block_loop.thisRepN'
p1071
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1072
sS'block_loop.thisIndex'
p1073
g1021
sS'block_loop.thisN'
p1074
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x16@'
tRp1075
sg28
g11
sg1042
S'Neutral'
p1076
sS'block_loop.thisTrialN'
p1077
I2
sa(dp1078
S'Trial_Loop.thisTrialN'
p1079
I3
sg40
g545
sg1035
S'9530.bmp'
p1080
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1081
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p1082
g24
(g57
S'\x0e\x00\x00\x00'
tRp1083
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1084
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1085
sg1030
g24
(g26
S'\xcd\xcc\xcc\xcc\xcc\xcc\x14@'
tRp1086
sS'block_loop.thisRepN'
p1087
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1088
sS'block_loop.thisIndex'
p1089
g1021
sS'block_loop.thisN'
p1090
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'q=\n\xd7\xa3p\x07@'
tRp1091
sg28
g11
sg1042
g1043
sS'block_loop.thisTrialN'
p1092
I2
sa(dp1093
S'Trial_Loop.thisTrialN'
p1094
I4
sg40
g545
sg1035
S'7234.bmp'
p1095
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1096
I4
sg21
g22
sS'Trial_Loop.thisIndex'
p1097
g24
(g57
S'\x1c\x00\x00\x00'
tRp1098
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1099
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1100
sg1030
g24
(g26
S'\xaeG\xe1z\x14\xae\x07@'
tRp1101
sS'block_loop.thisRepN'
p1102
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1103
sS'block_loop.thisIndex'
p1104
g1021
sS'block_loop.thisN'
p1105
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\xecQ\xb8\x1e\x85\xeb\x10@'
tRp1106
sg28
g11
sg1042
g1076
sS'block_loop.thisTrialN'
p1107
I2
sa(dp1108
S'Trial_Loop.thisTrialN'
p1109
I5
sg40
g545
sg1035
S'2250.bmp'
p1110
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1111
I5
sg21
g22
sS'Trial_Loop.thisIndex'
p1112
g24
(g57
S'\x12\x00\x00\x00'
tRp1113
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1114
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1115
sg1030
g24
(g26
S'\xc3\xf5(\\\x8f\xc2\x10@'
tRp1116
sS'block_loop.thisRepN'
p1117
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1118
sS'block_loop.thisIndex'
p1119
g1021
sS'block_loop.thisN'
p1120
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\x8f\xc2\xf5(\\\x8f\x1a@'
tRp1121
sg28
g11
sg1042
g1059
sS'block_loop.thisTrialN'
p1122
I2
sa(dp1123
S'Trial_Loop.thisTrialN'
p1124
I6
sg40
g545
sg1035
S'2455.bmp'
p1125
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1126
I6
sg21
g22
sS'Trial_Loop.thisIndex'
p1127
g24
(g57
S'\x16\x00\x00\x00'
tRp1128
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1129
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1130
sg1030
g24
(g26
S'\xd7\xa3p=\n\xd7\x11@'
tRp1131
sS'block_loop.thisRepN'
p1132
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1133
sS'block_loop.thisIndex'
p1134
g1021
sS'block_loop.thisN'
p1135
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\xaeG\xe1z\x14\xae\x07@'
tRp1136
sg28
g11
sg1042
g1043
sS'block_loop.thisTrialN'
p1137
I2
sa(dp1138
S'Trial_Loop.thisTrialN'
p1139
I7
sg40
g545
sg1035
S'2190.bmp'
p1140
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1141
I7
sg21
g22
sS'Trial_Loop.thisIndex'
p1142
g24
(g57
S'\x10\x00\x00\x00'
tRp1143
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1144
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1145
sg1030
g24
(g26
S'H\xe1z\x14\xaeG\x03@'
tRp1146
sS'block_loop.thisRepN'
p1147
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1148
sS'block_loop.thisIndex'
p1149
g1021
sS'block_loop.thisN'
p1150
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'R\xb8\x1e\x85\xebQ\x13@'
tRp1151
sg28
g11
sg1042
g1076
sS'block_loop.thisTrialN'
p1152
I2
sa(dp1153
S'Trial_Loop.thisTrialN'
p1154
I8
sg40
g545
sg1035
S'2272.bmp'
p1155
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1156
I8
sg21
g22
sS'Trial_Loop.thisIndex'
p1157
g24
(g57
S'\x14\x00\x00\x00'
tRp1158
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1159
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1160
sg1030
g24
(g26
S'\xecQ\xb8\x1e\x85\xeb\r@'
tRp1161
sS'block_loop.thisRepN'
p1162
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1163
sS'block_loop.thisIndex'
p1164
g1021
sS'block_loop.thisN'
p1165
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x12@'
tRp1166
sg28
g11
sg1042
g1076
sS'block_loop.thisTrialN'
p1167
I2
sa(dp1168
S'Trial_Loop.thisTrialN'
p1169
I9
sg40
g545
sg1035
S'8380.bmp'
p1170
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1171
I9
sg21
g22
sS'Trial_Loop.thisIndex'
p1172
g24
(g57
S'\x0c\x00\x00\x00'
tRp1173
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1174
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1175
sg1030
g24
(g26
S'\xf6(\\\x8f\xc2\xf5\x16@'
tRp1176
sS'block_loop.thisRepN'
p1177
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1178
sS'block_loop.thisIndex'
p1179
g1021
sS'block_loop.thisN'
p1180
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'=\n\xd7\xa3p=\x1e@'
tRp1181
sg28
g11
sg1042
g1059
sS'block_loop.thisTrialN'
p1182
I2
sa(dp1183
S'Trial_Loop.thisTrialN'
p1184
I10
sg40
g545
sg1035
S'2810.bmp'
p1185
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1186
I10
sg21
g22
sS'Trial_Loop.thisIndex'
p1187
g24
(g57
S'\x1a\x00\x00\x00'
tRp1188
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1189
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1190
sg1030
g24
(g26
S'\xe1z\x14\xaeG\xe1\x11@'
tRp1191
sS'block_loop.thisRepN'
p1192
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1193
sS'block_loop.thisIndex'
p1194
g1021
sS'block_loop.thisN'
p1195
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'=\n\xd7\xa3p=\x11@'
tRp1196
sg28
g11
sg1042
g1076
sS'block_loop.thisTrialN'
p1197
I2
sa(dp1198
S'Trial_Loop.thisTrialN'
p1199
I11
sg40
g545
sg1035
S'2799.bmp'
p1200
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1201
I11
sg21
g22
sS'Trial_Loop.thisIndex'
p1202
g24
(g57
S'\x04\x00\x00\x00'
tRp1203
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1204
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1205
sg1030
g24
(g26
S'\x14\xaeG\xe1z\x14\x14@'
tRp1206
sS'block_loop.thisRepN'
p1207
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1208
sS'block_loop.thisIndex'
p1209
g1021
sS'block_loop.thisN'
p1210
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\\\x8f\xc2\xf5(\\\x03@'
tRp1211
sg28
g11
sg1042
g1043
sS'block_loop.thisTrialN'
p1212
I2
sa(dp1213
S'Trial_Loop.thisTrialN'
p1214
I12
sg40
g545
sg1035
S'2210.bmp'
p1215
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1216
I12
sg21
g22
sS'Trial_Loop.thisIndex'
p1217
g24
(g57
S'\x11\x00\x00\x00'
tRp1218
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1219
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1220
sg1030
g24
(g26
S'{\x14\xaeG\xe1z\x0c@'
tRp1221
sS'block_loop.thisRepN'
p1222
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1223
sS'block_loop.thisIndex'
p1224
g1021
sS'block_loop.thisN'
p1225
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x11@'
tRp1226
sg28
g11
sg1042
g1076
sS'block_loop.thisTrialN'
p1227
I2
sa(dp1228
S'Trial_Loop.thisTrialN'
p1229
I13
sg40
g545
sg1035
S'2900.bmp'
p1230
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1231
I13
sg21
g22
sS'Trial_Loop.thisIndex'
p1232
g24
(g57
S'\x05\x00\x00\x00'
tRp1233
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1234
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1235
sg1030
g24
(g26
S'\\\x8f\xc2\xf5(\\\x14@'
tRp1236
sS'block_loop.thisRepN'
p1237
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1238
sS'block_loop.thisIndex'
p1239
g1021
sS'block_loop.thisN'
p1240
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\x03@'
tRp1241
sg28
g11
sg1042
g1043
sS'block_loop.thisTrialN'
p1242
I2
sa(dp1243
S'Trial_Loop.thisTrialN'
p1244
I14
sg40
g545
sg1035
S'2590.bmp'
p1245
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1246
I14
sg21
g22
sS'Trial_Loop.thisIndex'
p1247
g24
(g57
S'\x18\x00\x00\x00'
tRp1248
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1249
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1250
sg1030
g24
(g26
S'q=\n\xd7\xa3p\x0f@'
tRp1251
sS'block_loop.thisRepN'
p1252
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1253
sS'block_loop.thisIndex'
p1254
g1021
sS'block_loop.thisN'
p1255
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\x14\xaeG\xe1z\x14\n@'
tRp1256
sg28
g11
sg1042
g1043
sS'block_loop.thisTrialN'
p1257
I2
sa(dp1258
S'Trial_Loop.thisTrialN'
p1259
I15
sg40
g545
sg1035
S'8465.bmp'
p1260
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1261
I15
sg21
g22
sS'Trial_Loop.thisIndex'
p1262
g24
(g57
S'\x1d\x00\x00\x00'
tRp1263
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1264
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1265
sg1030
g24
(g26
S'\xd7\xa3p=\n\xd7\xf7?'
tRp1266
sS'block_loop.thisRepN'
p1267
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1268
sS'block_loop.thisIndex'
p1269
g1021
sS'block_loop.thisN'
p1270
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\xd7\xa3p=\n\xd7\x17@'
tRp1271
sg28
g11
sg1042
g1059
sS'block_loop.thisTrialN'
p1272
I2
sa(dp1273
S'Trial_Loop.thisTrialN'
p1274
I16
sg40
g545
sg1035
S'8041.bmp'
p1275
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1276
I16
sg21
g22
sS'Trial_Loop.thisIndex'
p1277
g24
(g57
S'\x0b\x00\x00\x00'
tRp1278
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1279
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1280
sg1030
g24
(g26
S'\xf6(\\\x8f\xc2\xf5\x15@'
tRp1281
sS'block_loop.thisRepN'
p1282
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1283
sS'block_loop.thisIndex'
p1284
g1021
sS'block_loop.thisN'
p1285
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\x1a@'
tRp1286
sg28
g11
sg1042
g1059
sS'block_loop.thisTrialN'
p1287
I2
sa(dp1288
S'Trial_Loop.thisTrialN'
p1289
I17
sg40
g545
sg1035
S'4599.bmp'
p1290
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1291
I17
sg21
g22
sS'Trial_Loop.thisIndex'
p1292
g24
(g57
S'\x07\x00\x00\x00'
tRp1293
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1294
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1295
sg1030
g24
(g26
S'\xc3\xf5(\\\x8f\xc2\x16@'
tRp1296
sS'block_loop.thisRepN'
p1297
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1298
sS'block_loop.thisIndex'
p1299
g1021
sS'block_loop.thisN'
p1300
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'{\x14\xaeG\xe1z\x1c@'
tRp1301
sg28
g11
sg1042
g1059
sS'block_loop.thisTrialN'
p1302
I2
sa(dp1303
S'Trial_Loop.thisTrialN'
p1304
I18
sg40
g545
sg1035
S'2870.bmp'
p1305
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1306
I18
sg21
g22
sS'Trial_Loop.thisIndex'
p1307
g24
(g57
S'\x1b\x00\x00\x00'
tRp1308
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1309
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1310
sg1030
g24
(g26
S'\x14\xaeG\xe1z\x14\x08@'
tRp1311
sS'block_loop.thisRepN'
p1312
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1313
sS'block_loop.thisIndex'
p1314
g1021
sS'block_loop.thisN'
p1315
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'=\n\xd7\xa3p=\x15@'
tRp1316
sg28
g11
sg1042
g1076
sS'block_loop.thisTrialN'
p1317
I2
sa(dp1318
S'Trial_Loop.thisTrialN'
p1319
I19
sg40
g545
sg1035
S'8420.bmp'
p1320
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1321
I19
sg21
g22
sS'Trial_Loop.thisIndex'
p1322
g24
(g57
S'\r\x00\x00\x00'
tRp1323
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1324
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1325
sg1030
g24
(g26
S'=\n\xd7\xa3p=\x16@'
tRp1326
sS'block_loop.thisRepN'
p1327
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1328
sS'block_loop.thisIndex'
p1329
g1021
sS'block_loop.thisN'
p1330
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\n\xd7\xa3p=\n\x1f@'
tRp1331
sg28
g11
sg1042
g1059
sS'block_loop.thisTrialN'
p1332
I2
sa(dp1333
S'Trial_Loop.thisTrialN'
p1334
I20
sg40
g545
sg1035
S'5455.bmp'
p1335
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1336
I20
sg21
g22
sS'Trial_Loop.thisIndex'
p1337
g24
(g57
S'\n\x00\x00\x00'
tRp1338
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1339
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1340
sg1030
g24
(g26
S'=\n\xd7\xa3p=\x12@'
tRp1341
sS'block_loop.thisRepN'
p1342
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1343
sS'block_loop.thisIndex'
p1344
g1021
sS'block_loop.thisN'
p1345
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S')\\\x8f\xc2\xf5(\x17@'
tRp1346
sg28
g11
sg1042
g1076
sS'block_loop.thisTrialN'
p1347
I2
sa(dp1348
S'Trial_Loop.thisTrialN'
p1349
I21
sg40
g545
sg1035
S'1601.bmp'
p1350
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1351
I21
sg21
g22
sS'Trial_Loop.thisIndex'
p1352
g24
(g57
S'\x0f\x00\x00\x00'
tRp1353
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1354
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1355
sg1030
g24
(g26
S'\\\x8f\xc2\xf5(\\\x0f@'
tRp1356
sS'block_loop.thisRepN'
p1357
I0
sg1033
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1358
sS'block_loop.thisIndex'
p1359
g1021
sS'block_loop.thisN'
p1360
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'q=\n\xd7\xa3p\x1b@'
tRp1361
sg28
g11
sg1042
g1059
sS'block_loop.thisTrialN'
p1362
I2
sa(dp1363
S'Trial_Loop.thisTrialN'
p1364
I22
sg40
g545
sg1035
S'2095.bmp'
p1365
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1366
I22
sg21
g22
sS'Trial_Loop.thisIndex'
p1367
g24
(g57
S'\x00\x00\x00\x00'
tRp1368
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1369
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1370
sg1030
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x15@'
tRp1371
sS'block_loop.thisRepN'
p1372
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1373
sS'block_loop.thisIndex'
p1374
g1021
sS'block_loop.thisN'
p1375
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\xa4p=\n\xd7\xa3\xfc?'
tRp1376
sg28
g11
sg1042
g1043
sS'block_loop.thisTrialN'
p1377
I2
sa(dp1378
S'Trial_Loop.thisTrialN'
p1379
I23
sg40
g545
sg1035
S'2745.1.bmp'
p1380
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1381
I23
sg21
g22
sS'Trial_Loop.thisIndex'
p1382
g24
(g57
S'\x19\x00\x00\x00'
tRp1383
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1384
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1385
sg1030
g24
(g26
S'\x14\xaeG\xe1z\x14\n@'
tRp1386
sS'block_loop.thisRepN'
p1387
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1388
sS'block_loop.thisIndex'
p1389
g1021
sS'block_loop.thisN'
p1390
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'=\n\xd7\xa3p=\x15@'
tRp1391
sg28
g11
sg1042
g1076
sS'block_loop.thisTrialN'
p1392
I2
sa(dp1393
S'Trial_Loop.thisTrialN'
p1394
I24
sg40
g545
sg1035
S'4617.bmp'
p1395
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1396
I24
sg21
g22
sS'Trial_Loop.thisIndex'
p1397
g24
(g57
S'\x08\x00\x00\x00'
tRp1398
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1399
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1400
sg1030
g24
(g26
S'\xc3\xf5(\\\x8f\xc2\x14@'
tRp1401
sS'block_loop.thisRepN'
p1402
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1403
sS'block_loop.thisIndex'
p1404
g1021
sS'block_loop.thisN'
p1405
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'ffffff\x1a@'
tRp1406
sg28
g11
sg1042
g1059
sS'block_loop.thisTrialN'
p1407
I2
sa(dp1408
S'Trial_Loop.thisTrialN'
p1409
I25
sg40
g545
sg1035
S'2410.bmp'
p1410
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1411
I25
sg21
g22
sS'Trial_Loop.thisIndex'
p1412
g24
(g57
S'\x15\x00\x00\x00'
tRp1413
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1414
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1415
sg1030
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x10@'
tRp1416
sS'block_loop.thisRepN'
p1417
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1418
sS'block_loop.thisIndex'
p1419
g1021
sS'block_loop.thisN'
p1420
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'{\x14\xaeG\xe1z\x12@'
tRp1421
sg28
g11
sg1042
g1076
sS'block_loop.thisTrialN'
p1422
I2
sa(dp1423
S'Trial_Loop.thisTrialN'
p1424
I26
sg40
g545
sg1035
S'2691.bmp'
p1425
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1426
I26
sg21
g22
sS'Trial_Loop.thisIndex'
p1427
g24
(g57
S'\x03\x00\x00\x00'
tRp1428
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1429
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1430
sg1030
g24
(g26
S'ffffff\x17@'
tRp1431
sS'block_loop.thisRepN'
p1432
I0
sg1033
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1433
sS'block_loop.thisIndex'
p1434
g1021
sS'block_loop.thisN'
p1435
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'R\xb8\x1e\x85\xebQ\x08@'
tRp1436
sg28
g11
sg1042
g1043
sS'block_loop.thisTrialN'
p1437
I2
sa(dp1438
S'Trial_Loop.thisTrialN'
p1439
I27
sg40
g545
sg1035
S'2260.bmp'
p1440
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1441
I27
sg21
g22
sS'Trial_Loop.thisIndex'
p1442
g24
(g57
S'\x13\x00\x00\x00'
tRp1443
sg1027
g1067
sg29
g30
sS'Trial_Loop.thisRepN'
p1444
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1445
sg1030
g24
(g26
S'\n\xd7\xa3p=\n\x11@'
tRp1446
sS'block_loop.thisRepN'
p1447
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1448
sS'block_loop.thisIndex'
p1449
g1021
sS'block_loop.thisN'
p1450
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e @'
tRp1451
sg28
g11
sg1042
g1059
sS'block_loop.thisTrialN'
p1452
I2
sa(dp1453
S'Trial_Loop.thisTrialN'
p1454
I28
sg40
g545
sg1035
S'2375.1.bmp'
p1455
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1456
I28
sg21
g22
sS'Trial_Loop.thisIndex'
p1457
g24
(g57
S'\x02\x00\x00\x00'
tRp1458
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1459
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1460
sg1030
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x13@'
tRp1461
sS'block_loop.thisRepN'
p1462
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1463
sS'block_loop.thisIndex'
p1464
g1021
sS'block_loop.thisN'
p1465
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\x01@'
tRp1466
sg28
g11
sg1042
g1043
sS'block_loop.thisTrialN'
p1467
I2
sa(dp1468
S'Trial_Loop.thisTrialN'
p1469
I29
sg40
g545
sg1035
S'2278.bmp'
p1470
sg42
g1023
sg23
g27
sS'Trial_Loop.thisN'
p1471
I29
sg21
g22
sS'Trial_Loop.thisIndex'
p1472
g24
(g57
S'\x01\x00\x00\x00'
tRp1473
sg1027
g1028
sg29
g30
sS'Trial_Loop.thisRepN'
p1474
I0
sg1018
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1475
sg1030
g24
(g26
S'333333\x12@'
tRp1476
sS'block_loop.thisRepN'
p1477
I0
sg1033
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1478
sS'block_loop.thisIndex'
p1479
g1021
sS'block_loop.thisN'
p1480
I2
sg41
g1038
sg39
g1044
sg1040
g24
(g26
S'\xe1z\x14\xaeG\xe1\n@'
tRp1481
sg28
g11
sg1042
g1043
sS'block_loop.thisTrialN'
p1482
I2
sa(dp1483
S'block_loop.thisRepN'
p1484
I0
sg29
g30
sS'Break_loop.thisTrialN'
p1485
I0
sg40
g545
sS'block_loop.thisIndex'
p1486
g1021
sg16
Nsg23
g27
sS'block_loop.thisN'
p1487
I2
sg41
g1038
sS'block_loop.thisTrialN'
p1488
I2
sS'Break_loop.thisRepN'
p1489
I0
sg28
g11
sg42
g1023
sg21
g22
sS'Break_loop.thisIndex'
p1490
g24
(g57
S'\x00\x00\x00\x00'
tRp1491
sS'Break_loop.thisN'
p1492
I0
sS'Break_loop.thisTrial'
p1493
Nsg39
g1044
sa(dp1494
S'block_loop.thisRepN'
p1495
I0
sg29
g30
sS'block_loop.thisIndex'
p1496
g1021
sg23
g27
sS'block_loop.thisN'
p1497
I2
sg41
g1038
sS'block_loop.thisTrialN'
p1498
I2
sg28
g11
sg42
g1023
sg21
g22
sg39
g1044
sg40
g545
sasS'loops'
p1499
(lp1500
g1
(cpsychopy.data
TrialHandler
p1501
g3
NtRp1502
(dp1503
S'origin'
p1504
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p1505
sS'thisTrial'
p1506
(lp1507
sS'_exp'
p1508
I397136080
sg10
S'Introduction_Loop'
p1509
sg6
S'C:/Users/sr38553/Desktop/new task/task/new_task.py'
p1510
sS'thisRepN'
p1511
I1
sg18
I01
sg19
g20
sS'data'
p1512
g1
(cpsychopy.data
DataHandler
p1513
c__builtin__
dict
p1514
(dp1515
S'ran'
p1516
cnumpy.ma.core
_mareconstruct
p1517
(cnumpy.ma.core
MaskedArray
p1518
cnumpy
ndarray
p1519
(I0
tp1520
S'b'
tRp1521
(I1
(I1
I1
tg25
(S'f4'
I0
I1
tRp1522
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?'
S'\x00'
NtbsS'order'
p1523
g1517
(g1518
g1519
g1520
S'b'
tRp1524
(I1
(I1
I1
tg1522
I00
S'\x00\x00\x00\x00'
S'\x00'
NtbstRp1525
(dp1526
S'isNumeric'
p1527
(dp1528
g1516
I01
sg1523
I01
ssS'trials'
p1529
g1502
sS'dataTypes'
p1530
(lp1531
g1516
ag1523
asS'dataShape'
p1532
(lp1533
I1
aI1
asbsS'method'
p1534
S'sequential'
p1535
sS'sequenceIndices'
p1536
cnumpy.core.multiarray
_reconstruct
p1537
(g1519
(I0
tS'b'
tRp1538
(I1
(I1
I1
tg57
I00
S'\x00\x00\x00\x00'
tbsS'finished'
p1539
I01
sS'nReps'
p1540
I1
sS'nRemaining'
p1541
I-1
sS'trialList'
p1542
(lp1543
g1
(cpsychopy.data
TrialType
p1544
g1514
(dp1545
S'Introduction_image'
p1546
S'inst_1'
p1547
stRp1548
asS'seed'
p1549
NsS'thisIndex'
p1550
g24
(g57
S'\x00\x00\x00\x00'
tRp1551
sS'thisN'
p1552
I1
sS'thisTrialN'
p1553
I0
sS'nTotal'
p1554
I1
sS'_warnUseOfNext'
p1555
I01
sbag1
(g1501
g3
NtRp1556
(dp1557
g1504
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p1558
sg1506
(lp1559
sg1508
I397136080
sg10
S'block_loop'
p1560
sg6
g1510
sg1511
I1
sg18
I01
sg19
g20
sg1512
g1
(g1513
g1514
(dp1561
g1516
g1517
(g1518
g1519
g1520
S'b'
tRp1562
(I1
(I3
I1
tg1522
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00'
Ntbsg14
g1537
(g1519
(I0
tS'b'
tRp1563
(I1
(I3
I1
tg25
(S'O4'
I0
I1
tRp1564
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp1565
g59
ag538
ag1022
atbsg1523
g1517
(g1518
g1519
g1520
S'b'
tRp1566
(I1
(I3
I1
tg1522
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@'
S'\x00\x00\x00'
Ntbsg15
g1517
(g1518
g1519
g1520
S'b'
tRp1567
(I1
(I3
I1
tg1522
I00
S'\xfb\x99\xa5@\x08VU@Q\xdfE@'
S'\x00\x00\x00'
NtbstRp1568
(dp1569
g1527
(dp1570
g1516
I01
sg14
I00
sg1523
I01
sg15
I01
ssg1529
g1556
sg1530
(lp1571
g1516
ag1523
ag14
ag15
asg1532
(lp1572
I3
aI1
asbsg1534
g1535
sg1536
g1537
(g1519
(I0
tS'b'
tRp1573
(I1
(I3
I1
tg57
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00'
tbsg1539
I01
sg1540
I1
sg1541
I-1
sg1542
(lp1574
g1
(g1544
g1514
(dp1575
g42
g60
sg39
g76
sg41
g72
sg40
g66
stRp1576
ag1
(g1544
g1514
(dp1577
g42
g60
sg39
g560
sg41
g554
sg40
g545
stRp1578
ag1
(g1544
g1514
(dp1579
g42
g1023
sg39
g1044
sg41
g1038
sg40
g545
stRp1580
asg1549
Nsg1550
g1021
sg1552
I3
sg1553
I0
sg1554
I3
sg1555
I01
sbag1
(g1501
g3
NtRp1581
(dp1582
g1504
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p1583
sg1506
(lp1584
sg1508
I397136080
sg10
S'Trial_Loop'
p1585
sg6
g1510
sg1511
I1
sg18
I01
sg19
g20
sg1512
g1
(g1513
g1514
(dp1586
g1516
g1517
(g1518
g1519
g1520
S'b'
tRp1587
(I1
(I30
I1
tg1522
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1523
g1517
(g1518
g1519
g1520
S'b'
tRp1588
(I1
(I30
I1
tg1522
I00
S'\x00\x00\x80?\x00\x00PA\x00\x00\x90A\x00\x00\xe0A\x00\x00\xd8A\x00\x00\xb8A\x00\x00`A\x00\x00\x98A\x00\x00\xd0A\x00\x00\xa0@\x00\x00\xe8A\x00\x00\x00@\x00\x00\xc0@\x00\x00\xa0A\x00\x00@@\x00\x00\x00A\x00\x00@A\x00\x00\xb0A\x00\x00pA\x00\x00\x00\x00\x00\x00\x80@\x00\x00\xe0@\x00\x00\x10A\x00\x00 A\x00\x00\x80A\x00\x000A\x00\x00\xa8A\x00\x00\xc0A\x00\x00\x88A\x00\x00\xc8A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1589
(dp1590
g1527
(dp1591
g1516
I01
sg1523
I01
ssg1529
g1581
sg1530
(lp1592
g1516
ag1523
asg1532
(lp1593
I30
aI1
asbsg1534
S'random'
p1594
sg1536
g1537
(g1519
(I0
tS'b'
tRp1595
(I1
(I30
I1
tg57
I01
S'\x13\x00\x00\x00\x00\x00\x00\x00\x0b\x00\x00\x00\x0e\x00\x00\x00\x14\x00\x00\x00\t\x00\x00\x00\x0c\x00\x00\x00\x15\x00\x00\x00\x0f\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x19\x00\x00\x00\x10\x00\x00\x00\x01\x00\x00\x00\x06\x00\x00\x00\x12\x00\x00\x00\x18\x00\x00\x00\x1c\x00\x00\x00\x02\x00\x00\x00\x07\x00\x00\x00\r\x00\x00\x00\x1a\x00\x00\x00\x11\x00\x00\x00\x05\x00\x00\x00\x1b\x00\x00\x00\x1d\x00\x00\x00\x08\x00\x00\x00\x04\x00\x00\x00\x03\x00\x00\x00\n\x00\x00\x00'
tbsg1539
I01
sg1540
I1
sg1541
I-1
sg1542
(lp1596
g1
(g1544
g1514
(dp1597
g43
g91
sg47
g88
sg45
g79
sg46
g83
sg44
g92
sg48
g85
sg49
g86
stRp1598
ag1
(g1544
g1514
(dp1599
g43
g273
sg47
g270
sg45
g262
sg46
g83
sg44
g123
sg48
g267
sg49
g268
stRp1600
ag1
(g1544
g1514
(dp1601
g43
g348
sg47
g345
sg45
g337
sg46
g83
sg44
g123
sg48
g342
sg49
g343
stRp1602
ag1
(g1544
g1514
(dp1603
g43
g498
sg47
g495
sg45
g487
sg46
g83
sg44
g92
sg48
g492
sg49
g493
stRp1604
ag1
(g1544
g1514
(dp1605
g43
g483
sg47
g480
sg45
g472
sg46
g83
sg44
g123
sg48
g477
sg49
g478
stRp1606
ag1
(g1544
g1514
(dp1607
g43
g423
sg47
g420
sg45
g412
sg46
g83
sg44
g123
sg48
g417
sg49
g418
stRp1608
ag1
(g1544
g1514
(dp1609
g43
g288
sg47
g285
sg45
g277
sg46
g83
sg44
g123
sg48
g282
sg49
g283
stRp1610
ag1
(g1544
g1514
(dp1611
g43
g363
sg47
g360
sg45
g352
sg46
g83
sg44
g75
sg48
g357
sg49
g358
stRp1612
ag1
(g1544
g1514
(dp1613
g43
g468
sg47
g465
sg45
g457
sg46
g83
sg44
g123
sg48
g462
sg49
g463
stRp1614
ag1
(g1544
g1514
(dp1615
g43
g153
sg47
g150
sg45
g142
sg46
g83
sg44
g92
sg48
g147
sg49
g148
stRp1616
ag1
(g1544
g1514
(dp1617
g43
g513
sg47
g510
sg45
g502
sg46
g83
sg44
g92
sg48
g507
sg49
g508
stRp1618
ag1
(g1544
g1514
(dp1619
g43
g107
sg47
g104
sg45
g96
sg46
g83
sg44
g92
sg48
g101
sg49
g102
stRp1620
ag1
(g1544
g1514
(dp1621
g43
g168
sg47
g165
sg45
g157
sg46
g83
sg44
g92
sg48
g162
sg49
g163
stRp1622
ag1
(g1544
g1514
(dp1623
g43
g378
sg47
g375
sg45
g367
sg46
g83
sg44
g123
sg48
g372
sg49
g373
stRp1624
ag1
(g1544
g1514
(dp1625
g43
g122
sg47
g119
sg45
g111
sg46
g83
sg44
g123
sg48
g116
sg49
g117
stRp1626
ag1
(g1544
g1514
(dp1627
g43
g198
sg47
g195
sg45
g187
sg46
g64
sg44
g92
sg48
g192
sg49
g193
stRp1628
ag1
(g1544
g1514
(dp1629
g43
g258
sg47
g255
sg45
g247
sg46
g64
sg44
g75
sg48
g252
sg49
g253
stRp1630
ag1
(g1544
g1514
(dp1631
g43
g408
sg47
g405
sg45
g397
sg46
g64
sg44
g75
sg48
g402
sg49
g403
stRp1632
ag1
(g1544
g1514
(dp1633
g43
g303
sg47
g300
sg45
g292
sg46
g64
sg44
g75
sg48
g297
sg49
g298
stRp1634
ag1
(g1544
g1514
(dp1635
g43
g74
sg47
g69
sg45
g70
sg46
g64
sg44
g75
sg48
g55
sg49
g67
stRp1636
ag1
(g1544
g1514
(dp1637
g43
g138
sg47
g135
sg45
g127
sg46
g64
sg44
g92
sg48
g132
sg49
g133
stRp1638
ag1
(g1544
g1514
(dp1639
g43
g183
sg47
g180
sg45
g172
sg46
g64
sg44
g75
sg48
g177
sg49
g178
stRp1640
ag1
(g1544
g1514
(dp1641
g43
g213
sg47
g210
sg45
g202
sg46
g64
sg44
g75
sg48
g207
sg49
g208
stRp1642
ag1
(g1544
g1514
(dp1643
g43
g228
sg47
g225
sg45
g217
sg46
g64
sg44
g92
sg48
g222
sg49
g223
stRp1644
ag1
(g1544
g1514
(dp1645
g43
g318
sg47
g315
sg45
g307
sg46
g64
sg44
g75
sg48
g312
sg49
g313
stRp1646
ag1
(g1544
g1514
(dp1647
g43
g243
sg47
g240
sg45
g232
sg46
g64
sg44
g75
sg48
g237
sg49
g238
stRp1648
ag1
(g1544
g1514
(dp1649
g43
g393
sg47
g390
sg45
g382
sg46
g64
sg44
g92
sg48
g387
sg49
g388
stRp1650
ag1
(g1544
g1514
(dp1651
g43
g438
sg47
g435
sg45
g427
sg46
g64
sg44
g75
sg48
g432
sg49
g433
stRp1652
ag1
(g1544
g1514
(dp1653
g43
g333
sg47
g330
sg45
g322
sg46
g64
sg44
g123
sg48
g327
sg49
g328
stRp1654
ag1
(g1544
g1514
(dp1655
g43
g453
sg47
g450
sg45
g442
sg46
g64
sg44
g123
sg48
g447
sg49
g448
stRp1656
asg1549
Nsg1550
g505
sg1552
I30
sg1553
I0
sg1554
I30
sg1555
I01
sbag1
(g1501
g3
NtRp1657
(dp1658
g1504
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p1659
sg1506
(lp1660
sg1508
I397136080
sg10
S'Break_loop'
p1661
sg6
g1510
sg1511
I1
sg18
I01
sg19
g20
sg1512
g1
(g1513
g1514
(dp1662
g1516
g1517
(g1518
g1519
g1520
S'b'
tRp1663
(I1
(I1
I1
tg1522
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg17
g1517
(g1518
g1519
g1520
S'b'
tRp1664
(I1
(I1
I1
tg1522
I00
S'\xf2\xde\x1d@'
S'\x00'
Ntbsg1523
g1517
(g1518
g1519
g1520
S'b'
tRp1665
(I1
(I1
I1
tg1522
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g1537
(g1519
(I0
tS'b'
tRp1666
(I1
(I1
I1
tg1564
I00
(lp1667
g519
atbstRp1668
(dp1669
g1527
(dp1670
g1516
I01
sg17
I01
sg1523
I01
sg16
I00
ssg1529
g1657
sg1530
(lp1671
g1516
ag1523
ag16
ag17
asg1532
(lp1672
I1
aI1
asbsg1534
g1594
sg1536
g1537
(g1519
(I0
tS'b'
tRp1673
(I1
(I1
I1
tg57
I00
S'\x00\x00\x00\x00'
tbsg1539
I01
sg1540
I1
sg1541
I-1
sg1542
(lp1674
Nasg1549
Nsg1550
g523
sg1552
I1
sg1553
I0
sg1554
I1
sg1555
I01
sbag1
(g1501
g3
NtRp1675
(dp1676
g1504
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p1677
sg1506
(lp1678
sg1508
I397136080
sg10
g1585
sg6
g1510
sg1511
I1
sg18
I01
sg19
g20
sg1512
g1
(g1513
g1514
(dp1679
g1516
g1517
(g1518
g1519
g1520
S'b'
tRp1680
(I1
(I30
I1
tg1522
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1523
g1517
(g1518
g1519
g1520
S'b'
tRp1681
(I1
(I30
I1
tg1522
I00
S'\x00\x00@@\x00\x00\xc0@\x00\x00\xc8A\x00\x00@A\x00\x00`A\x00\x00PA\x00\x00\xe0@\x00\x00\xd0A\x00\x00\x00@\x00\x000A\x00\x00\x80@\x00\x00\x00\x00\x00\x00\x90A\x00\x00pA\x00\x00\xd8A\x00\x00\xb0A\x00\x00\xe0A\x00\x00\xb8A\x00\x00\x98A\x00\x00\x80A\x00\x00\x00A\x00\x00 A\x00\x00\xa0A\x00\x00\xc0A\x00\x00\x10A\x00\x00\xa8A\x00\x00\x80?\x00\x00\x88A\x00\x00\xe8A\x00\x00\xa0@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1682
(dp1683
g1527
(dp1684
g1516
I01
sg1523
I01
ssg1529
g1675
sg1530
(lp1685
g1516
ag1523
asg1532
(lp1686
I30
aI1
asbsg1534
g1594
sg1536
g1537
(g1519
(I0
tS'b'
tRp1687
(I1
(I30
I1
tg57
I01
S'\x0b\x00\x00\x00\x1a\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\n\x00\x00\x00\x1d\x00\x00\x00\x01\x00\x00\x00\x06\x00\x00\x00\x14\x00\x00\x00\x18\x00\x00\x00\x15\x00\x00\x00\t\x00\x00\x00\x03\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\r\x00\x00\x00\x13\x00\x00\x00\x1b\x00\x00\x00\x0c\x00\x00\x00\x12\x00\x00\x00\x16\x00\x00\x00\x19\x00\x00\x00\x0f\x00\x00\x00\x11\x00\x00\x00\x17\x00\x00\x00\x02\x00\x00\x00\x07\x00\x00\x00\x0e\x00\x00\x00\x10\x00\x00\x00\x1c\x00\x00\x00'
tbsg1539
I01
sg1540
I1
sg1541
I-1
sg1542
(lp1688
g1
(g1544
g1514
(dp1689
g556
g606
sg549
g603
sg551
g595
sg542
g543
sg558
g591
sg534
g600
sg546
g601
stRp1690
ag1
(g1544
g1514
(dp1691
g556
g651
sg549
g648
sg551
g640
sg542
g543
sg558
g652
sg534
g645
sg546
g646
stRp1692
ag1
(g1544
g1514
(dp1693
g556
g937
sg549
g934
sg551
g926
sg542
g543
sg558
g591
sg534
g931
sg546
g932
stRp1694
ag1
(g1544
g1514
(dp1695
g556
g742
sg549
g739
sg551
g731
sg542
g543
sg558
g559
sg534
g736
sg546
g737
stRp1696
ag1
(g1544
g1514
(dp1697
g556
g772
sg549
g769
sg551
g761
sg542
g543
sg558
g591
sg534
g766
sg546
g767
stRp1698
ag1
(g1544
g1514
(dp1699
g556
g757
sg549
g754
sg551
g746
sg542
g543
sg558
g559
sg534
g751
sg546
g752
stRp1700
ag1
(g1544
g1514
(dp1701
g556
g667
sg549
g664
sg551
g656
sg542
g543
sg558
g559
sg534
g661
sg546
g662
stRp1702
ag1
(g1544
g1514
(dp1703
g556
g952
sg549
g949
sg551
g941
sg542
g543
sg558
g591
sg534
g946
sg546
g947
stRp1704
ag1
(g1544
g1514
(dp1705
g556
g590
sg549
g587
sg551
g579
sg542
g543
sg558
g591
sg534
g584
sg546
g585
stRp1706
ag1
(g1544
g1514
(dp1707
g556
g727
sg549
g724
sg551
g716
sg542
g543
sg558
g591
sg534
g721
sg546
g722
stRp1708
ag1
(g1544
g1514
(dp1709
g556
g621
sg549
g618
sg551
g610
sg542
g543
sg558
g559
sg534
g615
sg546
g616
stRp1710
ag1
(g1544
g1514
(dp1711
g556
g557
sg549
g550
sg551
g552
sg542
g543
sg558
g559
sg534
g535
sg546
g547
stRp1712
ag1
(g1544
g1514
(dp1713
g556
g832
sg549
g829
sg551
g821
sg542
g543
sg558
g559
sg534
g826
sg546
g827
stRp1714
ag1
(g1544
g1514
(dp1715
g556
g787
sg549
g784
sg551
g776
sg542
g543
sg558
g559
sg534
g781
sg546
g782
stRp1716
ag1
(g1544
g1514
(dp1717
g556
g967
sg549
g964
sg551
g956
sg542
g543
sg558
g559
sg534
g961
sg546
g962
stRp1718
ag1
(g1544
g1514
(dp1719
g556
g892
sg549
g889
sg551
g881
sg542
g567
sg558
g652
sg534
g886
sg546
g887
stRp1720
ag1
(g1544
g1514
(dp1721
g556
g982
sg549
g979
sg551
g971
sg542
g567
sg558
g652
sg534
g976
sg546
g977
stRp1722
ag1
(g1544
g1514
(dp1723
g556
g907
sg549
g904
sg551
g896
sg542
g567
sg558
g591
sg534
g901
sg546
g902
stRp1724
ag1
(g1544
g1514
(dp1725
g556
g847
sg549
g844
sg551
g836
sg542
g567
sg558
g652
sg534
g841
sg546
g842
stRp1726
ag1
(g1544
g1514
(dp1727
g556
g802
sg549
g799
sg551
g791
sg542
g567
sg558
g652
sg534
g796
sg546
g797
stRp1728
ag1
(g1544
g1514
(dp1729
g556
g682
sg549
g679
sg551
g671
sg542
g567
sg558
g652
sg534
g676
sg546
g677
stRp1730
ag1
(g1544
g1514
(dp1731
g556
g712
sg549
g709
sg551
g701
sg542
g567
sg558
g591
sg534
g706
sg546
g707
stRp1732
ag1
(g1544
g1514
(dp1733
g556
g862
sg549
g859
sg551
g851
sg542
g567
sg558
g652
sg534
g856
sg546
g857
stRp1734
ag1
(g1544
g1514
(dp1735
g556
g922
sg549
g919
sg551
g911
sg542
g567
sg558
g652
sg534
g916
sg546
g917
stRp1736
ag1
(g1544
g1514
(dp1737
g556
g697
sg549
g694
sg551
g686
sg542
g567
sg558
g591
sg534
g691
sg546
g692
stRp1738
ag1
(g1544
g1514
(dp1739
g556
g877
sg549
g874
sg551
g866
sg542
g567
sg558
g652
sg534
g871
sg546
g872
stRp1740
ag1
(g1544
g1514
(dp1741
g556
g575
sg549
g572
sg551
g563
sg542
g567
sg558
g559
sg534
g569
sg546
g570
stRp1742
ag1
(g1544
g1514
(dp1743
g556
g817
sg549
g814
sg551
g806
sg542
g567
sg558
g652
sg534
g811
sg546
g812
stRp1744
ag1
(g1544
g1514
(dp1745
g556
g997
sg549
g994
sg551
g986
sg542
g567
sg558
g591
sg534
g991
sg546
g992
stRp1746
ag1
(g1544
g1514
(dp1747
g556
g636
sg549
g633
sg551
g625
sg542
g567
sg558
g559
sg534
g630
sg546
g631
stRp1748
asg1549
Nsg1550
g989
sg1552
I30
sg1553
I0
sg1554
I30
sg1555
I01
sbag1
(g1501
g3
NtRp1749
(dp1750
g1504
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p1751
sg1506
(lp1752
sg1508
I397136080
sg10
g1661
sg6
g1510
sg1511
I1
sg18
I01
sg19
g20
sg1512
g1
(g1513
g1514
(dp1753
g1516
g1517
(g1518
g1519
g1520
S'b'
tRp1754
(I1
(I1
I1
tg1522
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg17
g1517
(g1518
g1519
g1520
S'b'
tRp1755
(I1
(I1
I1
tg1522
I00
S'\xa3\xdfE@'
S'\x00'
Ntbsg1523
g1517
(g1518
g1519
g1520
S'b'
tRp1756
(I1
(I1
I1
tg1522
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g1537
(g1519
(I0
tS'b'
tRp1757
(I1
(I1
I1
tg1564
I00
(lp1758
g1003
atbstRp1759
(dp1760
g1527
(dp1761
g1516
I01
sg17
I01
sg1523
I01
sg16
I00
ssg1529
g1749
sg1530
(lp1762
g1516
ag1523
ag16
ag17
asg1532
(lp1763
I1
aI1
asbsg1534
g1594
sg1536
g1537
(g1519
(I0
tS'b'
tRp1764
(I1
(I1
I1
tg57
I00
S'\x00\x00\x00\x00'
tbsg1539
I01
sg1540
I1
sg1541
I-1
sg1542
(lp1765
Nasg1549
Nsg1550
g1007
sg1552
I1
sg1553
I0
sg1554
I1
sg1555
I01
sbag1
(g1501
g3
NtRp1766
(dp1767
g1504
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p1768
sg1506
(lp1769
sg1508
I397136080
sg10
g1585
sg6
g1510
sg1511
I1
sg18
I01
sg19
g20
sg1512
g1
(g1513
g1514
(dp1770
g1516
g1517
(g1518
g1519
g1520
S'b'
tRp1771
(I1
(I30
I1
tg1522
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg1523
g1517
(g1518
g1519
g1520
S'b'
tRp1772
(I1
(I30
I1
tg1522
I00
S'\x00\x00\xb0A\x00\x00\xe8A\x00\x00\xe0A\x00\x00\xd0A\x00\x000A\x00\x00PA\x00\x00\x00\x00\x00\x00\x88A\x00\x00\xc0A\x00\x00\x80?\x00\x00\xa0A\x00\x00\x80A\x00\x00\x10A\x00\x00\x98A\x00\x00@@\x00\x00\xa8A\x00\x00\xe0@\x00\x00@A\x00\x00\xa0@\x00\x00\xd8A\x00\x00\x00A\x00\x00\xc8A\x00\x00\xc0@\x00\x00\x00@\x00\x00`A\x00\x00\xb8A\x00\x00 A\x00\x00\x90A\x00\x00\x80@\x00\x00pA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1773
(dp1774
g1527
(dp1775
g1516
I01
sg1523
I01
ssg1529
g1766
sg1530
(lp1776
g1516
ag1523
asg1532
(lp1777
I30
aI1
asbsg1534
g1594
sg1536
g1537
(g1519
(I0
tS'b'
tRp1778
(I1
(I30
I1
tg57
I01
S'\x06\x00\x00\x00\t\x00\x00\x00\x17\x00\x00\x00\x0e\x00\x00\x00\x1c\x00\x00\x00\x12\x00\x00\x00\x16\x00\x00\x00\x10\x00\x00\x00\x14\x00\x00\x00\x0c\x00\x00\x00\x1a\x00\x00\x00\x04\x00\x00\x00\x11\x00\x00\x00\x05\x00\x00\x00\x18\x00\x00\x00\x1d\x00\x00\x00\x0b\x00\x00\x00\x07\x00\x00\x00\x1b\x00\x00\x00\r\x00\x00\x00\n\x00\x00\x00\x0f\x00\x00\x00\x00\x00\x00\x00\x19\x00\x00\x00\x08\x00\x00\x00\x15\x00\x00\x00\x03\x00\x00\x00\x13\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00'
tbsg1539
I01
sg1540
I1
sg1541
I-1
sg1542
(lp1779
g1
(g1544
g1514
(dp1780
g1040
g1376
sg1033
g1373
sg1035
g1365
sg1027
g1028
sg1042
g1043
sg1018
g1370
sg1030
g1371
stRp1781
ag1
(g1544
g1514
(dp1782
g1040
g1481
sg1033
g1478
sg1035
g1470
sg1027
g1028
sg1042
g1043
sg1018
g1475
sg1030
g1476
stRp1783
ag1
(g1544
g1514
(dp1784
g1040
g1466
sg1033
g1463
sg1035
g1455
sg1027
g1028
sg1042
g1043
sg1018
g1460
sg1030
g1461
stRp1785
ag1
(g1544
g1514
(dp1786
g1040
g1436
sg1033
g1433
sg1035
g1425
sg1027
g1028
sg1042
g1043
sg1018
g1430
sg1030
g1431
stRp1787
ag1
(g1544
g1514
(dp1788
g1040
g1211
sg1033
g1208
sg1035
g1200
sg1027
g1028
sg1042
g1043
sg1018
g1205
sg1030
g1206
stRp1789
ag1
(g1544
g1514
(dp1790
g1040
g1241
sg1033
g1238
sg1035
g1230
sg1027
g1028
sg1042
g1043
sg1018
g1235
sg1030
g1236
stRp1791
ag1
(g1544
g1514
(dp1792
g1040
g1041
sg1033
g1034
sg1035
g1036
sg1027
g1028
sg1042
g1043
sg1018
g1019
sg1030
g1031
stRp1793
ag1
(g1544
g1514
(dp1794
g1040
g1301
sg1033
g1298
sg1035
g1290
sg1027
g1028
sg1042
g1059
sg1018
g1295
sg1030
g1296
stRp1795
ag1
(g1544
g1514
(dp1796
g1040
g1406
sg1033
g1403
sg1035
g1395
sg1027
g1028
sg1042
g1059
sg1018
g1400
sg1030
g1401
stRp1797
ag1
(g1544
g1514
(dp1798
g1040
g1058
sg1033
g1055
sg1035
g1047
sg1027
g1028
sg1042
g1059
sg1018
g1052
sg1030
g1053
stRp1799
ag1
(g1544
g1514
(dp1800
g1040
g1346
sg1033
g1343
sg1035
g1335
sg1027
g1028
sg1042
g1076
sg1018
g1340
sg1030
g1341
stRp1801
ag1
(g1544
g1514
(dp1802
g1040
g1286
sg1033
g1283
sg1035
g1275
sg1027
g1028
sg1042
g1059
sg1018
g1280
sg1030
g1281
stRp1803
ag1
(g1544
g1514
(dp1804
g1040
g1181
sg1033
g1178
sg1035
g1170
sg1027
g1028
sg1042
g1059
sg1018
g1175
sg1030
g1176
stRp1805
ag1
(g1544
g1514
(dp1806
g1040
g1331
sg1033
g1328
sg1035
g1320
sg1027
g1028
sg1042
g1059
sg1018
g1325
sg1030
g1326
stRp1807
ag1
(g1544
g1514
(dp1808
g1040
g1091
sg1033
g1088
sg1035
g1080
sg1027
g1028
sg1042
g1043
sg1018
g1085
sg1030
g1086
stRp1809
ag1
(g1544
g1514
(dp1810
g1040
g1361
sg1033
g1358
sg1035
g1350
sg1027
g1067
sg1042
g1059
sg1018
g1355
sg1030
g1356
stRp1811
ag1
(g1544
g1514
(dp1812
g1040
g1151
sg1033
g1148
sg1035
g1140
sg1027
g1067
sg1042
g1076
sg1018
g1145
sg1030
g1146
stRp1813
ag1
(g1544
g1514
(dp1814
g1040
g1226
sg1033
g1223
sg1035
g1215
sg1027
g1067
sg1042
g1076
sg1018
g1220
sg1030
g1221
stRp1815
ag1
(g1544
g1514
(dp1816
g1040
g1121
sg1033
g1118
sg1035
g1110
sg1027
g1067
sg1042
g1059
sg1018
g1115
sg1030
g1116
stRp1817
ag1
(g1544
g1514
(dp1818
g1040
g1451
sg1033
g1448
sg1035
g1440
sg1027
g1067
sg1042
g1059
sg1018
g1445
sg1030
g1446
stRp1819
ag1
(g1544
g1514
(dp1820
g1040
g1166
sg1033
g1163
sg1035
g1155
sg1027
g1067
sg1042
g1076
sg1018
g1160
sg1030
g1161
stRp1821
ag1
(g1544
g1514
(dp1822
g1040
g1421
sg1033
g1418
sg1035
g1410
sg1027
g1067
sg1042
g1076
sg1018
g1415
sg1030
g1416
stRp1823
ag1
(g1544
g1514
(dp1824
g1040
g1136
sg1033
g1133
sg1035
g1125
sg1027
g1067
sg1042
g1043
sg1018
g1130
sg1030
g1131
stRp1825
ag1
(g1544
g1514
(dp1826
g1040
g1075
sg1033
g1072
sg1035
g1063
sg1027
g1067
sg1042
g1076
sg1018
g1069
sg1030
g1070
stRp1827
ag1
(g1544
g1514
(dp1828
g1040
g1256
sg1033
g1253
sg1035
g1245
sg1027
g1067
sg1042
g1043
sg1018
g1250
sg1030
g1251
stRp1829
ag1
(g1544
g1514
(dp1830
g1040
g1391
sg1033
g1388
sg1035
g1380
sg1027
g1067
sg1042
g1076
sg1018
g1385
sg1030
g1386
stRp1831
ag1
(g1544
g1514
(dp1832
g1040
g1196
sg1033
g1193
sg1035
g1185
sg1027
g1067
sg1042
g1076
sg1018
g1190
sg1030
g1191
stRp1833
ag1
(g1544
g1514
(dp1834
g1040
g1316
sg1033
g1313
sg1035
g1305
sg1027
g1067
sg1042
g1076
sg1018
g1310
sg1030
g1311
stRp1835
ag1
(g1544
g1514
(dp1836
g1040
g1106
sg1033
g1103
sg1035
g1095
sg1027
g1067
sg1042
g1076
sg1018
g1100
sg1030
g1101
stRp1837
ag1
(g1544
g1514
(dp1838
g1040
g1271
sg1033
g1268
sg1035
g1260
sg1027
g1067
sg1042
g1059
sg1018
g1265
sg1030
g1266
stRp1839
asg1549
Nsg1550
g1473
sg1552
I30
sg1553
I0
sg1554
I30
sg1555
I01
sbag1
(g1501
g3
NtRp1840
(dp1841
g1504
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p1842
sg1506
(lp1843
sg1508
I397136080
sg10
g1661
sg6
g1510
sg1511
I1
sg18
I01
sg19
g20
sg1512
g1
(g1513
g1514
(dp1844
g1516
g1517
(g1518
g1519
g1520
S'b'
tRp1845
(I1
(I1
I1
tg1522
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg1523
g1517
(g1518
g1519
g1520
S'b'
tRp1846
(I1
(I1
I1
tg1522
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g1537
(g1519
(I0
tS'b'
tRp1847
(I1
(I1
I1
tg1564
I00
(lp1848
NatbstRp1849
(dp1850
g1527
(dp1851
g1516
I01
sg1523
I01
sg16
I00
ssg1529
g1840
sg1530
(lp1852
g1516
ag1523
ag16
asg1532
(lp1853
I1
aI1
asbsg1534
g1594
sg1536
g1537
(g1519
(I0
tS'b'
tRp1854
(I1
(I1
I1
tg57
I00
S'\x00\x00\x00\x00'
tbsg1539
I01
sg1540
I1
sg1541
I-1
sg1542
(lp1855
Nasg1549
Nsg1550
g1491
sg1552
I1
sg1553
I0
sg1554
I1
sg1555
I01
sbasS'savePickle'
p1856
I00
sb.