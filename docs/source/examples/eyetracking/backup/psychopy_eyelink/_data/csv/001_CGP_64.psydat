ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005csr38553\u005cDesktop\u005cnew task\u005ctask\u005c_data/csv/001_CGP
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'CGP'
p11
sS'dataNames'
p12
(lp13
S'block_key.keys'
p14
aS'block_key.rt'
p15
aS'Break_key.keys'
p16
aS'Break_key.rt'
p17
asS'autoLog'
p18
I01
sS'extraInfo'
p19
(dp20
S'date'
p21
V2016_Jul_04_1231
p22
sS'frameRate'
p23
cnumpy.core.multiarray
scalar
p24
(cnumpy
dtype
p25
(S'f8'
I0
I1
tRp26
(I3
S'<'
NNNI-1
I-1
I0
tbS'\xb9\x0c\x06\xa5m\xff]@'
tRp27
sS'expName'
p28
g11
sVParticipant
p29
V001
p30
sVDominant Eye
p31
Vl
ssS'loopsUnfinished'
p32
(lp33
g1
(cpsychopy.data
TrialHandler
p34
g3
NtRp35
(dp36
S'origin'
p37
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.04 (6/28)\u000aFrom Chris\u000a- 4 blocks\u000a	- block 1: set up baseline\u000a		- view-only block: establish baseline and SD for images\u000a		- present neutral images\u000a	- block 2-4: use baseline and adapt (trial level)\u000a		- shift baseline location (mean) and size (SD) according to fixation and feedback updates\u000a        		- if trial has no changes in feedback, shift threshold size (SD) down\u000a                 - if trial has too many changes in feedback, shift threshold size up\u000a            have this version present a version with shifts and without \u000a\u000achanges: \u000aDONE added new block. 1) this block will have the same images as succeeding blocks, but not feedback presentation\u000a                      stimuli during this block will also be present for 5 seconds\u000a                      2) pupil means will be collected during this block and used as a baseline for future blocks\u000a\u000aDONE    new baseline. 1) use the parameters setup by the new baseline (SD, mean) as thresholds for blocks 2-4.\u000a                      shift thresholds using baseline mean from fixation\u000a                      have two versions of task (shift version, no-shift version) and compare\u000a    \u000aDONE         cleanup. 1) created functions for trial-level lists, booleans, and constants\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a#eyelink-standard deviation constant\u000astdev_multi = 1\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True, units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    #if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                    if ps <= (.94*lst[-1]) and ps <= (.94*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                    if (ps >= (.94*ps_n1)) and (maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *stdev_multi)\u000a        _min = _mean - (_stdev *stdev_multi)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def cue_check(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=win) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        cue_color = self.cue_display(less_,greater_,p_min,p_max)\u000a        return cue_color\u000a    \u000a    def cue_display(self,less_,greater_,p_min,p_max):\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a    \u000a    def prepare_append(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            #ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lf_min.append(blank_event)#neg stdev from baseline mean\u000a            lf_mean.append(blank_event)#baseline mean\u000a            lf_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a            lmood.append(blank_event) #stimulus valience\u000a            lstim.append(blank_event) #stimulus name\u000a        else:\u000a            #if Block 2-4\u000a            if blockNum != 1:\u000a                #timing\u000a                #tt = eyelink.t_tracker()#tracker time\u000a                pp_t = event.getTime()#psychopy time\u000a                \u000a                #creating variables for cross-validation\u000a                lblock.append(blockNum)#block\u000a                ltrial.append(trialNum)#trial\u000a                levent.append(event_type)#baseline or stimulus\u000a                lpp_t.append(pp_t)#psychopy time\u000a                cpu_pc.append(cpu_s)#cpu\u000a                ram_pc.append(ram_s)#ram\u000a                \u000a                #fixation baseline            \u000a                lf_min.append(f_min)#neg stdev from baseline mean\u000a                lf_mean.append(f_mean)#baseline mean\u000a                lf_max.append(f_max)#pos stdev from baseline mean\u000a                #adjusted baseline\u000a                lps_min.append(ps_min)#neg stdev from baseline mean\u000a                lps_mean.append(ps_mean)#baseline mean\u000a                lps_max.append(ps_max)#pos stdev from baseline mean\u000a                \u000a                lps_uadj.append(ps_o)#unadjusted pupil size\u000a                lps_d.append(maV)#pupil size velocity\u000a                lps.append(ps_n)#adjusted pupil size\u000a                lcue.append(old_cue) #cue color\u000a                lblink.append(blink_event) #debug\u000a                lmood.append(valence) #stimulus valience\u000a                lstim.append(scenestim) #stimulus name\u000a                \u000a    def prepare_constants(self, event, stim_offset, blank_offset):\u000a        blank_event='nan'#dummy value\u000a        blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a        event_type=event #stimulus event label\u000a        old_cue = 'nan' #dummy values for time before first cue presentation\u000a        p_ma = 'nan' #dummy value for moving average\u000a        ps_n1 = 0 #n-1 pupil size\u000a        st0=0 #time between samples (st1-st0)\u000a        ct0=0 #time between cues (ct1-ct0)\u000a        maV=0 #velocity\u000a        stimulus_offset = stim_offset #time (sec)\u000a        blank_offset = blank_offset #time (sec)\u000a        Total_Samples_old=0 #no. of samples\u000a        return blink_event, event_type, old_cue,\u005c\u000a        p_ma, ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a        blank_offset, Total_Samples_old,blank_event\u000a        \u000a    def prepare_bool(self,baseline_):\u000a        first_loop = True # is first pupil sample\u000a        Window = True #window to collect samples\u000a        baseline = baseline_ #end of baseline samples\u000a        blink = False #blink occuring\u000a        ma_min = False #less than 3 samples for moving average\u000a        Cue = True #present cue\u000a        Event_draw = False #marks the zero-time in a trial\u000a        return first_loop, Window, baseline, blink, ma_min,\u005c\u000a        Cue, Event_draw\u000a\u000a    def prepare_lists(self):\u000a        lblink=[] #list of blink events\u000a        levent=[] #list of event types (baseline,trial)\u000a        lf_max=[]#list of pupil baseline max\u000a        lf_min=[]#list of pupil baseline min\u000a        lf_mean=[]#list of pupil baseline mean\u000a        lps_max=[]#list of pupil baseline max\u000a        lps_min=[]#list of pupil baseline min\u000a        lps_mean=[]#list of pupil baseline mean\u000a        lps_uadj=[] #list of unadjusted pupil samples \u000a        lps=[]#list of adjusted pupil samples\u000a        lps_d=[] #change in ps\u000a        lcue=[] #list of cue colors\u000a        lpp_t=[]#time stamp of each cue onset (psychopy)\u000a        ltrial=[]#list of trials at each cue\u000a        lblock=[]#list of trials at each cue\u000a        cpu_pc=[]#list of cpu usage, by %\u000a        ram_pc=[]#list of ram usage, by %\u000a        lstim=[] #stimulus\u000a        lmood=[] #valience\u000a        return lblink, levent,\u005c\u000a        lf_max, lf_min, lf_mean,\u005c\u000a        lps_max, lps_min, lps_mean,\u005c\u000a        lps_uadj, lps, lps_d, lcue, lpp_t, ltrial, lblock,\u005c\u000a        cpu_pc, ram_pc, lstim, lmood\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event","valence","stimulus",\u000a                          "psychopy_timestamp","cpu","ram",\u000a                          "fixation_baseline_min","fixation_baseline_mean","fixation_baseline_max",\u000a                          "stimulus_baseline_min","stimulus_baseline_mean","stimulus_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","feedback","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,lmood,lstim,\u000a                                            time_,cpu_pc,ram_pc,\u000a                                            lf_min,lf_mean,lf_max,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Block %s Image %s'" %(trialNum,blockNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.005\u000a        return cu\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000alblock_ps = []\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating per block\u000a    blockNum = blockNum + 1 #block count\u000a    if blockNum == 2:\u000a        b_min,b_max,b_mean,b_stdev = eyelink.min_max(lblock_ps)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #constants\u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('baseline',None,None)\u000a            \u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min, Cue,\u005c\u000a            Event_draw = eyelink.prepare_bool(True)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lpb_uadj, lpb, lpb_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()           \u000a            \u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    #if at least 2msec between samples\u000a                    if eyelink.t_sample(st1,st0):\u000a                        #if gaze window not achived                        \u000a                        if inbox != True: \u000a                            # eyelink-gaze contingent function\u000a                            eyelink.gc_window()   \u000a                            #eyelink-pupil size\u000a                            ps_old = eyelink.pupil_sample()\u000a                        st0 = st1\u000a                        eyelink.prepare_append(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #if gc failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect fixation baseline min max mean and stdev        \u000a            f_min,f_max,f_mean,f_stdev = eyelink.min_max(lpb_uadj)\u000a            \u000a            #if blink detected\u000a            ##check if any pupil size during gc window was less than 75% of baseline mean\u000a            blink_threshold = (.75*f_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a        \u000a        #Fixation Finished------------\u000a        #if first block\u000a        if blockNum == 1:\u000a            ps_min = f_min\u000a            ps_mean = f_mean\u000a            ps_max = f_max           \u000a        else:\u000a            ps_min = f_mean - (b_stdev *stdev_multi)\u000a            ps_mean = f_mean\u000a            ps_max = f_mean + (b_stdev *stdev_multi)\u000a            print('block: mean = %s, block min = %s, max = %s'%(b_mean, b_min, b_max))\u000a            print('fixation: mean = %s, min = %s, max = %s'%(f_mean, f_min, f_max))\u000a            print('threshold: mean = %s, min = %s, max = %s'%(ps_mean, ps_min, ps_max))\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            #stimulus and ITI duration\u000a            # if block 2-4\u000a            if blockNum == 1:\u000a                stim_offset = 5\u000a                iti_offset = 7\u000a            #else if block 1\u000a            else:\u000a                stim_offset = 10\u000a                iti_offset = 12\u000a            \u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('stimulus',stim_offset,iti_offset) #stim offset, blank offset\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min,\u005c\u000a            Cue, Event_draw = eyelink.prepare_bool(False)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lps_uadj, lps, lps_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()   \u000a     \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    win.flip()\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a\u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        #if Block 1\u000a                        if blockNum == 1:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):\u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)                    \u000a                            #if time = stimulus offset\u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                break\u000a                        #if Block 2-4                        \u000a                        else:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):                      \u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)\u000a                            #present Feedback\u000a                            if IAPSClock.getTime() >= 2:\u000a                                old_cue = eyelink.cue_check(lps,20,ps_min,ps_max)\u000a                            #End Stimulus presentation\u000a                            #if time = stimulus offset                   \u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                iaps_cue.setAutoDraw(False)\u000a                                break\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a                \u000a        if trialNum <5:\u000a            #concatinate lblock_ps with trial information\u000a            lblock_ps.extend(lps)\u000a            \u000a            #print results of block\u000a            if trialNum ==1:\u000a                trial_1 = len(lblock_ps)\u000a            if trialNum ==2:\u000a                trial_2 = len(lblock_ps) - trial_1\u000a            if trialNum ==3:\u000a                trial_3 = len(lblock_ps) - (trial_1+trial_2)\u000a            if trialNum ==4:\u000a                trial_4 = len(lblock_ps) - (trial_1+trial_2+trial_3)\u000a                \u000a            if trialNum ==4:\u000a                print('total_samples = %s' %(len(lblock_ps)))\u000a                print('trial_1 = %s,%s' %(trial_1,(len(lps))))\u000a                print('trial_2 = %s,%s' %(trial_2,(len(lps))))\u000a                print('trial_3 = %s,%s' %(trial_3,(len(lps))))\u000a                print('trial_4 = %s,%s' %(trial_4,(len(lps))))\u000a            \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p38
sS'thisTrial'
p39
g1
(cpsychopy.data
TrialType
p40
c__builtin__
dict
p41
(dp42
S'break_display'
p43
S'blank'
p44
sS'order'
p45
g24
(g25
(S'i8'
I0
I1
tRp46
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp47
sS'block_file'
p48
S'procedure\\3.csv'
p49
sS'block_display'
p50
S'cont_inst'
p51
stRp52
sS'_exp'
p53
I401540368
sg10
S'block_loop'
p54
sg6
S'C:/Users/sr38553/Desktop/new task/task/6.7.04.py'
p55
sS'thisRepN'
p56
I0
sg18
I01
sg19
g20
sS'data'
p57
g1
(cpsychopy.data
DataHandler
p58
g41
(dp59
S'ran'
p60
cnumpy.ma.core
_mareconstruct
p61
(cnumpy.ma.core
MaskedArray
p62
cnumpy
ndarray
p63
(I0
tp64
S'b'
tRp65
(I1
(I4
I1
tg25
(S'f4'
I0
I1
tRp66
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg14
cnumpy.core.multiarray
_reconstruct
p67
(g63
(I0
tS'b'
tRp68
(I1
(I4
I1
tg25
(S'O4'
I0
I1
tRp69
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp70
S'return'
p71
aS'return'
p72
aS'return'
p73
aS'return'
p74
atbsS'order'
p75
g61
(g62
g63
g64
S'b'
tRp76
(I1
(I4
I1
tg66
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@'
S'\x00\x00\x00\x00'
Ntbsg15
g61
(g62
g63
g64
S'b'
tRp77
(I1
(I4
I1
tg66
I00
S'6\xb6\xea>\xe3#"@I\n ?\xc3\x88\x90@'
S'\x00\x00\x00\x00'
NtbstRp78
(dp79
S'isNumeric'
p80
(dp81
g60
I01
sg14
I00
sg75
I01
sg15
I01
ssS'trials'
p82
g35
sS'dataTypes'
p83
(lp84
g60
ag75
ag14
ag15
asS'dataShape'
p85
(lp86
I4
aI1
asbsS'method'
p87
S'sequential'
p88
sS'sequenceIndices'
p89
g67
(g63
(I0
tS'b'
tRp90
(I1
(I4
I1
tg25
(S'i4'
I0
I1
tRp91
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'
tbsS'finished'
p92
I00
sS'nReps'
p93
I1
sS'nRemaining'
p94
I0
sS'trialList'
p95
(lp96
g1
(g40
g41
(dp97
g43
S'break'
p98
sg45
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp99
sg48
S'procedure\\0.csv'
p100
sg50
S'inst_2'
p101
stRp102
ag1
(g40
g41
(dp103
g43
g98
sg45
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp104
sg48
S'procedure\\1.csv'
p105
sg50
g51
stRp106
ag1
(g40
g41
(dp107
g43
g44
sg45
g24
(g46
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp108
sg48
S'procedure\\2.csv'
p109
sg50
g51
stRp110
ag52
asS'seed'
p111
NsS'thisIndex'
p112
g24
(g91
S'\x03\x00\x00\x00'
tRp113
sS'thisN'
p114
I3
sS'thisTrialN'
p115
I3
sS'nTotal'
p116
I4
sS'_warnUseOfNext'
p117
I01
sbag1
(g34
g3
NtRp118
(dp119
g37
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.04 (6/28)\u000aFrom Chris\u000a- 4 blocks\u000a	- block 1: set up baseline\u000a		- view-only block: establish baseline and SD for images\u000a		- present neutral images\u000a	- block 2-4: use baseline and adapt (trial level)\u000a		- shift baseline location (mean) and size (SD) according to fixation and feedback updates\u000a        		- if trial has no changes in feedback, shift threshold size (SD) down\u000a                 - if trial has too many changes in feedback, shift threshold size up\u000a            have this version present a version with shifts and without \u000a\u000achanges: \u000aDONE added new block. 1) this block will have the same images as succeeding blocks, but not feedback presentation\u000a                      stimuli during this block will also be present for 5 seconds\u000a                      2) pupil means will be collected during this block and used as a baseline for future blocks\u000a\u000aDONE    new baseline. 1) use the parameters setup by the new baseline (SD, mean) as thresholds for blocks 2-4.\u000a                      shift thresholds using baseline mean from fixation\u000a                      have two versions of task (shift version, no-shift version) and compare\u000a    \u000aDONE         cleanup. 1) created functions for trial-level lists, booleans, and constants\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a#eyelink-standard deviation constant\u000astdev_multi = 1\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True, units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    #if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                    if ps <= (.94*lst[-1]) and ps <= (.94*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                    if (ps >= (.94*ps_n1)) and (maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *stdev_multi)\u000a        _min = _mean - (_stdev *stdev_multi)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def cue_check(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=win) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        cue_color = self.cue_display(less_,greater_,p_min,p_max)\u000a        return cue_color\u000a    \u000a    def cue_display(self,less_,greater_,p_min,p_max):\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a    \u000a    def prepare_append(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            #ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lf_min.append(blank_event)#neg stdev from baseline mean\u000a            lf_mean.append(blank_event)#baseline mean\u000a            lf_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a            lmood.append(blank_event) #stimulus valience\u000a            lstim.append(blank_event) #stimulus name\u000a        else:\u000a            #if Block 2-4\u000a            if blockNum != 1:\u000a                #timing\u000a                #tt = eyelink.t_tracker()#tracker time\u000a                pp_t = event.getTime()#psychopy time\u000a                \u000a                #creating variables for cross-validation\u000a                lblock.append(blockNum)#block\u000a                ltrial.append(trialNum)#trial\u000a                levent.append(event_type)#baseline or stimulus\u000a                lpp_t.append(pp_t)#psychopy time\u000a                cpu_pc.append(cpu_s)#cpu\u000a                ram_pc.append(ram_s)#ram\u000a                \u000a                #fixation baseline            \u000a                lf_min.append(f_min)#neg stdev from baseline mean\u000a                lf_mean.append(f_mean)#baseline mean\u000a                lf_max.append(f_max)#pos stdev from baseline mean\u000a                #adjusted baseline\u000a                lps_min.append(ps_min)#neg stdev from baseline mean\u000a                lps_mean.append(ps_mean)#baseline mean\u000a                lps_max.append(ps_max)#pos stdev from baseline mean\u000a                \u000a                lps_uadj.append(ps_o)#unadjusted pupil size\u000a                lps_d.append(maV)#pupil size velocity\u000a                lps.append(ps_n)#adjusted pupil size\u000a                lcue.append(old_cue) #cue color\u000a                lblink.append(blink_event) #debug\u000a                lmood.append(valence) #stimulus valience\u000a                lstim.append(scenestim) #stimulus name\u000a                \u000a    def prepare_constants(self, event, stim_offset, blank_offset):\u000a        blank_event='nan'#dummy value\u000a        blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a        event_type=event #stimulus event label\u000a        old_cue = 'nan' #dummy values for time before first cue presentation\u000a        p_ma = 'nan' #dummy value for moving average\u000a        ps_n1 = 0 #n-1 pupil size\u000a        st0=0 #time between samples (st1-st0)\u000a        ct0=0 #time between cues (ct1-ct0)\u000a        maV=0 #velocity\u000a        stimulus_offset = stim_offset #time (sec)\u000a        blank_offset = blank_offset #time (sec)\u000a        Total_Samples_old=0 #no. of samples\u000a        return blink_event, event_type, old_cue,\u005c\u000a        p_ma, ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a        blank_offset, Total_Samples_old,blank_event\u000a        \u000a    def prepare_bool(self,baseline_):\u000a        first_loop = True # is first pupil sample\u000a        Window = True #window to collect samples\u000a        baseline = baseline_ #end of baseline samples\u000a        blink = False #blink occuring\u000a        ma_min = False #less than 3 samples for moving average\u000a        Cue = True #present cue\u000a        Event_draw = False #marks the zero-time in a trial\u000a        return first_loop, Window, baseline, blink, ma_min,\u005c\u000a        Cue, Event_draw\u000a\u000a    def prepare_lists(self):\u000a        lblink=[] #list of blink events\u000a        levent=[] #list of event types (baseline,trial)\u000a        lf_max=[]#list of pupil baseline max\u000a        lf_min=[]#list of pupil baseline min\u000a        lf_mean=[]#list of pupil baseline mean\u000a        lps_max=[]#list of pupil baseline max\u000a        lps_min=[]#list of pupil baseline min\u000a        lps_mean=[]#list of pupil baseline mean\u000a        lps_uadj=[] #list of unadjusted pupil samples \u000a        lps=[]#list of adjusted pupil samples\u000a        lps_d=[] #change in ps\u000a        lcue=[] #list of cue colors\u000a        lpp_t=[]#time stamp of each cue onset (psychopy)\u000a        ltrial=[]#list of trials at each cue\u000a        lblock=[]#list of trials at each cue\u000a        cpu_pc=[]#list of cpu usage, by %\u000a        ram_pc=[]#list of ram usage, by %\u000a        lstim=[] #stimulus\u000a        lmood=[] #valience\u000a        return lblink, levent,\u005c\u000a        lf_max, lf_min, lf_mean,\u005c\u000a        lps_max, lps_min, lps_mean,\u005c\u000a        lps_uadj, lps, lps_d, lcue, lpp_t, ltrial, lblock,\u005c\u000a        cpu_pc, ram_pc, lstim, lmood\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event","valence","stimulus",\u000a                          "psychopy_timestamp","cpu","ram",\u000a                          "fixation_baseline_min","fixation_baseline_mean","fixation_baseline_max",\u000a                          "stimulus_baseline_min","stimulus_baseline_mean","stimulus_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","feedback","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,lmood,lstim,\u000a                                            time_,cpu_pc,ram_pc,\u000a                                            lf_min,lf_mean,lf_max,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Block %s Image %s'" %(trialNum,blockNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.005\u000a        return cu\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000alblock_ps = []\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating per block\u000a    blockNum = blockNum + 1 #block count\u000a    if blockNum == 2:\u000a        b_min,b_max,b_mean,b_stdev = eyelink.min_max(lblock_ps)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #constants\u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('baseline',None,None)\u000a            \u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min, Cue,\u005c\u000a            Event_draw = eyelink.prepare_bool(True)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lpb_uadj, lpb, lpb_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()           \u000a            \u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    #if at least 2msec between samples\u000a                    if eyelink.t_sample(st1,st0):\u000a                        #if gaze window not achived                        \u000a                        if inbox != True: \u000a                            # eyelink-gaze contingent function\u000a                            eyelink.gc_window()   \u000a                            #eyelink-pupil size\u000a                            ps_old = eyelink.pupil_sample()\u000a                        st0 = st1\u000a                        eyelink.prepare_append(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #if gc failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect fixation baseline min max mean and stdev        \u000a            f_min,f_max,f_mean,f_stdev = eyelink.min_max(lpb_uadj)\u000a            \u000a            #if blink detected\u000a            ##check if any pupil size during gc window was less than 75% of baseline mean\u000a            blink_threshold = (.75*f_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a        \u000a        #Fixation Finished------------\u000a        #if first block\u000a        if blockNum == 1:\u000a            ps_min = f_min\u000a            ps_mean = f_mean\u000a            ps_max = f_max           \u000a        else:\u000a            ps_min = f_mean - (b_stdev *stdev_multi)\u000a            ps_mean = f_mean\u000a            ps_max = f_mean + (b_stdev *stdev_multi)\u000a            print('block: mean = %s, block min = %s, max = %s'%(b_mean, b_min, b_max))\u000a            print('fixation: mean = %s, min = %s, max = %s'%(f_mean, f_min, f_max))\u000a            print('threshold: mean = %s, min = %s, max = %s'%(ps_mean, ps_min, ps_max))\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            #stimulus and ITI duration\u000a            # if block 2-4\u000a            if blockNum == 1:\u000a                stim_offset = 5\u000a                iti_offset = 7\u000a            #else if block 1\u000a            else:\u000a                stim_offset = 10\u000a                iti_offset = 12\u000a            \u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('stimulus',stim_offset,iti_offset) #stim offset, blank offset\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min,\u005c\u000a            Cue, Event_draw = eyelink.prepare_bool(False)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lps_uadj, lps, lps_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()   \u000a     \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    win.flip()\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a\u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        #if Block 1\u000a                        if blockNum == 1:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):\u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)                    \u000a                            #if time = stimulus offset\u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                break\u000a                        #if Block 2-4                        \u000a                        else:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):                      \u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)\u000a                            #present Feedback\u000a                            if IAPSClock.getTime() >= 2:\u000a                                old_cue = eyelink.cue_check(lps,20,ps_min,ps_max)\u000a                            #End Stimulus presentation\u000a                            #if time = stimulus offset                   \u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                iaps_cue.setAutoDraw(False)\u000a                                break\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a                \u000a        if trialNum <5:\u000a            #concatinate lblock_ps with trial information\u000a            lblock_ps.extend(lps)\u000a            \u000a            #print results of block\u000a            if trialNum ==1:\u000a                trial_1 = len(lblock_ps)\u000a            if trialNum ==2:\u000a                trial_2 = len(lblock_ps) - trial_1\u000a            if trialNum ==3:\u000a                trial_3 = len(lblock_ps) - (trial_1+trial_2)\u000a            if trialNum ==4:\u000a                trial_4 = len(lblock_ps) - (trial_1+trial_2+trial_3)\u000a                \u000a            if trialNum ==4:\u000a                print('total_samples = %s' %(len(lblock_ps)))\u000a                print('trial_1 = %s,%s' %(trial_1,(len(lps))))\u000a                print('trial_2 = %s,%s' %(trial_2,(len(lps))))\u000a                print('trial_3 = %s,%s' %(trial_3,(len(lps))))\u000a                print('trial_4 = %s,%s' %(trial_4,(len(lps))))\u000a            \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p120
sg39
g1
(g40
g41
(dp121
S'valmean'
p122
g24
(g26
S'\x14\xaeG\xe1z\x14\x1f@'
tRp123
sS'outliers'
p124
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp125
sS'scenestim'
p126
S'2550.bmp'
p127
sS'arousal'
p128
S'High'
p129
sS'valence'
p130
S'Positive'
p131
sS'blocknum'
p132
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp133
sS'arousalmean'
p134
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x12@'
tRp135
stRp136
sg53
I401540368
sg10
S'Trial_Loop'
p137
sg6
g55
sg56
I0
sg18
I01
sg19
g20
sg57
g1
(g58
g41
(dp138
g60
g61
(g62
g63
g64
S'b'
tRp139
(I1
(I4
I1
tg66
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00'
S'\x00\x00\x00\x00'
Ntbsg75
g61
(g62
g63
g64
S'b'
tRp140
(I1
(I4
I1
tg66
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x01\x01\x00\x01'
NtbstRp141
(dp142
g80
(dp143
g60
I01
sg75
I01
ssg82
g118
sg83
(lp144
g60
ag75
asg85
(lp145
I4
aI1
asbsg87
S'random'
p146
sg89
g67
(g63
(I0
tS'b'
tRp147
(I1
(I4
I1
tg91
I01
S'\x02\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00'
tbsg92
I00
sg93
I1
sg94
I3
sg95
(lp148
g1
(g40
g41
(dp149
g122
g24
(g26
S'ffffff\x1d@'
tRp150
sg124
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp151
sg126
S'2208.bmp'
p152
sg128
g129
sg130
g131
sg132
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp153
sg134
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x16@'
tRp154
stRp155
ag1
(g40
g41
(dp156
g122
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x14@'
tRp157
sg124
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp158
sg126
S'2278.bmp'
p159
sg128
g129
sg130
S'Negative'
p160
sg132
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp161
sg134
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x13@'
tRp162
stRp163
ag136
ag1
(g40
g41
(dp164
g122
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\xfe?'
tRp165
sg124
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp166
sg126
S'3180.bmp'
p167
sg128
g129
sg130
g160
sg132
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp168
sg134
g24
(g26
S'\x14\xaeG\xe1z\x14\x17@'
tRp169
stRp170
asg111
Nsg112
g24
(g91
S'\x02\x00\x00\x00'
tRp171
sg114
I0
sg115
I0
sg116
I4
sg117
I01
sbasS'saveWideText'
p172
I01
sS'thisEntry'
p173
(dp174
g14
g74
sg15
F4.5166946693789214
ssS'version'
p175
S''
sS'_paramNamesSoFar'
p176
(lp177
g45
ag50
ag48
ag43
aS'valmean'
p178
aS'valence'
p179
aS'scenestim'
p180
aS'arousal'
p181
aS'outliers'
p182
aS'blocknum'
p183
aS'arousalmean'
p184
asS'entries'
p185
(lp186
(dp187
S'Trial_Loop.thisTrialN'
p188
I0
sg183
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp189
sg15
F0.45842142135370523
sS'block_loop.thisIndex'
p190
g24
(g91
S'\x00\x00\x00\x00'
tRp191
sg14
g71
sg43
g98
sg23
g27
sS'Trial_Loop.thisN'
p192
I0
sg21
g22
sS'Trial_Loop.thisIndex'
p193
g24
(g91
S'\x02\x00\x00\x00'
tRp194
sg181
S'Low'
p195
sg29
g30
sS'Trial_Loop.thisRepN'
p196
I0
sg50
g101
sg184
g24
(g26
S'\xaeG\xe1z\x14\xae\x0b@'
tRp197
sS'block_loop.thisRepN'
p198
I0
sg182
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp199
sg180
S'2214.bmp'
p200
sS'block_loop.thisN'
p201
I0
sg31
Vl
sg48
g100
sS'block_loop.thisTrialN'
p202
I0
sg178
g24
(g26
S'\n\xd7\xa3p=\n\x14@'
tRp203
sg28
g11
sg179
S'Neutral'
p204
sg45
g99
sa(dp205
S'Trial_Loop.thisTrialN'
p206
I1
sg50
g101
sg180
S'2215.bmp'
p207
sg43
g98
sg23
g27
sS'Trial_Loop.thisN'
p208
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p209
g24
(g91
S'\x03\x00\x00\x00'
tRp210
sg181
g195
sg29
g30
sS'Trial_Loop.thisRepN'
p211
I0
sg183
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp212
sg184
g24
(g26
S'\n\xd7\xa3p=\n\x0b@'
tRp213
sS'block_loop.thisRepN'
p214
I0
sg182
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp215
sS'block_loop.thisIndex'
p216
g191
sS'block_loop.thisN'
p217
I0
sg31
Vl
sg48
g100
sg45
g99
sg178
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x12@'
tRp218
sg28
g11
sg179
g204
sS'block_loop.thisTrialN'
p219
I0
sa(dp220
S'Trial_Loop.thisTrialN'
p221
I2
sg50
g101
sg180
S'2235.bmp'
p222
sg43
g98
sg23
g27
sS'Trial_Loop.thisN'
p223
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p224
g24
(g91
S'\x00\x00\x00\x00'
tRp225
sg181
g195
sg29
g30
sS'Trial_Loop.thisRepN'
p226
I0
sg183
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp227
sg184
g24
(g26
S'\xe1z\x14\xaeG\xe1\n@'
tRp228
sS'block_loop.thisRepN'
p229
I0
sg182
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp230
sS'block_loop.thisIndex'
p231
g191
sS'block_loop.thisN'
p232
I0
sg31
Vl
sg48
g100
sg45
g99
sg178
g24
(g26
S'\x8f\xc2\xf5(\\\x8f\x16@'
tRp233
sg28
g11
sg179
g204
sS'block_loop.thisTrialN'
p234
I0
sa(dp235
S'Trial_Loop.thisTrialN'
p236
I3
sg50
g101
sg180
S'2020.bmp'
p237
sg43
g98
sg23
g27
sS'Trial_Loop.thisN'
p238
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p239
g24
(g91
S'\x01\x00\x00\x00'
tRp240
sg181
g195
sg29
g30
sS'Trial_Loop.thisRepN'
p241
I0
sg183
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp242
sg184
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\n@'
tRp243
sS'block_loop.thisRepN'
p244
I0
sg182
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp245
sS'block_loop.thisIndex'
p246
g191
sS'block_loop.thisN'
p247
I0
sg31
Vl
sg48
g100
sg45
g99
sg178
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x16@'
tRp248
sg28
g11
sg179
g204
sS'block_loop.thisTrialN'
p249
I0
sa(dp250
S'block_loop.thisRepN'
p251
I0
sg29
g30
sS'Break_loop.thisTrialN'
p252
I0
sg50
g101
sS'block_loop.thisIndex'
p253
g191
sg16
S'return'
p254
sg23
g27
sS'block_loop.thisN'
p255
I0
sg31
Vl
sg48
g100
sg45
g99
sS'Break_loop.thisRepN'
p256
I0
sg28
g11
sg43
g98
sg21
g22
sS'Break_loop.thisIndex'
p257
g24
(g91
S'\x00\x00\x00\x00'
tRp258
sS'Break_loop.thisN'
p259
I0
sg17
F2.5334154918091372
sS'Break_loop.thisTrial'
p260
NsS'block_loop.thisTrialN'
p261
I0
sa(dp262
S'block_loop.thisRepN'
p263
I0
sg29
g30
sS'block_loop.thisIndex'
p264
g191
sg23
g27
sS'block_loop.thisN'
p265
I0
sg31
Vl
sg48
g100
sS'block_loop.thisTrialN'
p266
I0
sg28
g11
sg43
g98
sg21
g22
sg45
g99
sg50
g101
sa(dp267
S'Trial_Loop.thisTrialN'
p268
I0
sS'blocknum'
p269
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp270
sg15
F2.533440399565734
sS'block_loop.thisIndex'
p271
g24
(g91
S'\x01\x00\x00\x00'
tRp272
sg14
g72
sg43
g98
sg23
g27
sS'Trial_Loop.thisN'
p273
I0
sg21
g22
sS'Trial_Loop.thisIndex'
p274
g24
(g91
S'\x02\x00\x00\x00'
tRp275
sS'arousal'
p276
S'High'
p277
sg29
g30
sS'Trial_Loop.thisRepN'
p278
I0
sg50
g51
sS'arousalmean'
p279
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x12@'
tRp280
sS'block_loop.thisRepN'
p281
I0
sS'outliers'
p282
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp283
sS'scenestim'
p284
S'2550.bmp'
p285
sS'block_loop.thisN'
p286
I1
sg31
Vl
sg48
g105
sS'block_loop.thisTrialN'
p287
I1
sS'valmean'
p288
g24
(g26
S'\x14\xaeG\xe1z\x14\x1f@'
tRp289
sg28
g11
sS'valence'
p290
S'Positive'
p291
sg45
g104
sa(dp292
S'Trial_Loop.thisTrialN'
p293
I1
sg50
g51
sg284
S'2278.bmp'
p294
sg43
g98
sg23
g27
sS'Trial_Loop.thisN'
p295
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p296
g24
(g91
S'\x01\x00\x00\x00'
tRp297
sg276
g277
sg29
g30
sS'Trial_Loop.thisRepN'
p298
I0
sg269
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp299
sg279
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x13@'
tRp300
sS'block_loop.thisRepN'
p301
I0
sg282
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp302
sS'block_loop.thisIndex'
p303
g272
sS'block_loop.thisN'
p304
I1
sg31
Vl
sg48
g105
sg45
g104
sg288
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x14@'
tRp305
sg28
g11
sg290
S'Negative'
p306
sS'block_loop.thisTrialN'
p307
I1
sa(dp308
S'Trial_Loop.thisTrialN'
p309
I2
sg50
g51
sg284
S'3180.bmp'
p310
sg43
g98
sg23
g27
sS'Trial_Loop.thisN'
p311
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p312
g24
(g91
S'\x03\x00\x00\x00'
tRp313
sg276
g277
sg29
g30
sS'Trial_Loop.thisRepN'
p314
I0
sg269
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp315
sg279
g24
(g26
S'\x14\xaeG\xe1z\x14\x17@'
tRp316
sS'block_loop.thisRepN'
p317
I0
sg282
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp318
sS'block_loop.thisIndex'
p319
g272
sS'block_loop.thisN'
p320
I1
sg31
Vl
sg48
g105
sg45
g104
sg288
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\xfe?'
tRp321
sg28
g11
sg290
g306
sS'block_loop.thisTrialN'
p322
I1
sa(dp323
S'Trial_Loop.thisTrialN'
p324
I3
sg50
g51
sg284
S'2208.bmp'
p325
sg43
g98
sg23
g27
sS'Trial_Loop.thisN'
p326
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p327
g24
(g91
S'\x00\x00\x00\x00'
tRp328
sg276
g277
sg29
g30
sS'Trial_Loop.thisRepN'
p329
I0
sg269
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp330
sg279
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x16@'
tRp331
sS'block_loop.thisRepN'
p332
I0
sg282
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp333
sS'block_loop.thisIndex'
p334
g272
sS'block_loop.thisN'
p335
I1
sg31
Vl
sg48
g105
sg45
g104
sg288
g24
(g26
S'ffffff\x1d@'
tRp336
sg28
g11
sg290
g291
sS'block_loop.thisTrialN'
p337
I1
sa(dp338
S'block_loop.thisRepN'
p339
I0
sg29
g30
sS'Break_loop.thisTrialN'
p340
I0
sg50
g51
sS'block_loop.thisIndex'
p341
g272
sg16
S'return'
p342
sg23
g27
sS'block_loop.thisN'
p343
I1
sg31
Vl
sg48
g105
sg45
g104
sS'Break_loop.thisRepN'
p344
I0
sg28
g11
sg43
g98
sg21
g22
sS'Break_loop.thisIndex'
p345
g24
(g91
S'\x00\x00\x00\x00'
tRp346
sS'Break_loop.thisN'
p347
I0
sg17
F2.0584589489735663
sS'Break_loop.thisTrial'
p348
NsS'block_loop.thisTrialN'
p349
I1
sa(dp350
S'block_loop.thisRepN'
p351
I0
sg29
g30
sS'block_loop.thisIndex'
p352
g272
sg23
g27
sS'block_loop.thisN'
p353
I1
sg31
Vl
sg48
g105
sS'block_loop.thisTrialN'
p354
I1
sg28
g11
sg43
g98
sg21
g22
sg45
g104
sg50
g51
sa(dp355
S'Trial_Loop.thisTrialN'
p356
I0
sS'blocknum'
p357
g24
(g46
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp358
sg15
F0.62515695311594754
sS'block_loop.thisIndex'
p359
g24
(g91
S'\x02\x00\x00\x00'
tRp360
sg14
g73
sg43
g44
sg23
g27
sS'Trial_Loop.thisN'
p361
I0
sg21
g22
sS'Trial_Loop.thisIndex'
p362
g24
(g91
S'\x03\x00\x00\x00'
tRp363
sS'arousal'
p364
S'High'
p365
sg29
g30
sS'Trial_Loop.thisRepN'
p366
I0
sg50
g51
sS'arousalmean'
p367
g24
(g26
S'ffffff\x17@'
tRp368
sS'block_loop.thisRepN'
p369
I0
sS'outliers'
p370
g24
(g46
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp371
sS'scenestim'
p372
S'2691.bmp'
p373
sS'block_loop.thisN'
p374
I2
sg31
Vl
sg48
g109
sS'block_loop.thisTrialN'
p375
I2
sS'valmean'
p376
g24
(g26
S'R\xb8\x1e\x85\xebQ\x08@'
tRp377
sg28
g11
sS'valence'
p378
S'Negative'
p379
sg45
g108
sa(dp380
S'Trial_Loop.thisTrialN'
p381
I1
sg50
g51
sg372
S'2095.bmp'
p382
sg43
g44
sg23
g27
sS'Trial_Loop.thisN'
p383
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p384
g24
(g91
S'\x00\x00\x00\x00'
tRp385
sg364
g365
sg29
g30
sS'Trial_Loop.thisRepN'
p386
I0
sg357
g24
(g46
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp387
sg367
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x15@'
tRp388
sS'block_loop.thisRepN'
p389
I0
sg370
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp390
sS'block_loop.thisIndex'
p391
g360
sS'block_loop.thisN'
p392
I2
sg31
Vl
sg48
g109
sg45
g108
sg376
g24
(g26
S'\xa4p=\n\xd7\xa3\xfc?'
tRp393
sg28
g11
sg378
g379
sS'block_loop.thisTrialN'
p394
I2
sa(dp395
S'Trial_Loop.thisTrialN'
p396
I2
sg50
g51
sg372
S'2375.1.bmp'
p397
sg43
g44
sg23
g27
sS'Trial_Loop.thisN'
p398
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p399
g24
(g91
S'\x02\x00\x00\x00'
tRp400
sg364
g365
sg29
g30
sS'Trial_Loop.thisRepN'
p401
I0
sg357
g24
(g46
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp402
sg367
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x13@'
tRp403
sS'block_loop.thisRepN'
p404
I0
sg370
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp405
sS'block_loop.thisIndex'
p406
g360
sS'block_loop.thisN'
p407
I2
sg31
Vl
sg48
g109
sg45
g108
sg376
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\x01@'
tRp408
sg28
g11
sg378
g379
sS'block_loop.thisTrialN'
p409
I2
sa(dp410
S'Trial_Loop.thisTrialN'
p411
I3
sg50
g51
sg372
S'2278.bmp'
p412
sg43
g44
sg23
g27
sS'Trial_Loop.thisN'
p413
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p414
g24
(g91
S'\x01\x00\x00\x00'
tRp415
sg364
g365
sg29
g30
sS'Trial_Loop.thisRepN'
p416
I0
sg357
g24
(g46
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp417
sg367
g24
(g26
S'333333\x12@'
tRp418
sS'block_loop.thisRepN'
p419
I0
sg370
g24
(g46
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp420
sS'block_loop.thisIndex'
p421
g360
sS'block_loop.thisN'
p422
I2
sg31
Vl
sg48
g109
sg45
g108
sg376
g24
(g26
S'\xe1z\x14\xaeG\xe1\n@'
tRp423
sg28
g11
sg378
g379
sS'block_loop.thisTrialN'
p424
I2
sa(dp425
S'block_loop.thisRepN'
p426
I0
sg29
g30
sS'Break_loop.thisTrialN'
p427
I0
sg50
g51
sS'block_loop.thisIndex'
p428
g360
sg16
Nsg23
g27
sS'block_loop.thisN'
p429
I2
sg48
g109
sS'block_loop.thisTrialN'
p430
I2
sS'Break_loop.thisRepN'
p431
I0
sg28
g11
sg43
g44
sg21
g22
sS'Break_loop.thisIndex'
p432
g24
(g91
S'\x00\x00\x00\x00'
tRp433
sS'Break_loop.thisN'
p434
I0
sg31
Vl
sS'Break_loop.thisTrial'
p435
Nsg45
g108
sa(dp436
S'block_loop.thisRepN'
p437
I0
sg29
g30
sS'block_loop.thisIndex'
p438
g360
sg23
g27
sS'block_loop.thisN'
p439
I2
sg31
Vl
sg48
g109
sS'block_loop.thisTrialN'
p440
I2
sg28
g11
sg43
g44
sg21
g22
sg45
g108
sg50
g51
sasS'loops'
p441
(lp442
g1
(g34
g3
NtRp443
(dp444
g37
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.04 (6/28)\u000aFrom Chris\u000a- 4 blocks\u000a	- block 1: set up baseline\u000a		- view-only block: establish baseline and SD for images\u000a		- present neutral images\u000a	- block 2-4: use baseline and adapt (trial level)\u000a		- shift baseline location (mean) and size (SD) according to fixation and feedback updates\u000a        		- if trial has no changes in feedback, shift threshold size (SD) down\u000a                 - if trial has too many changes in feedback, shift threshold size up\u000a            have this version present a version with shifts and without \u000a\u000achanges: \u000aDONE added new block. 1) this block will have the same images as succeeding blocks, but not feedback presentation\u000a                      stimuli during this block will also be present for 5 seconds\u000a                      2) pupil means will be collected during this block and used as a baseline for future blocks\u000a\u000aDONE    new baseline. 1) use the parameters setup by the new baseline (SD, mean) as thresholds for blocks 2-4.\u000a                      shift thresholds using baseline mean from fixation\u000a                      have two versions of task (shift version, no-shift version) and compare\u000a    \u000aDONE         cleanup. 1) created functions for trial-level lists, booleans, and constants\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a#eyelink-standard deviation constant\u000astdev_multi = 1\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True, units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    #if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                    if ps <= (.94*lst[-1]) and ps <= (.94*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                    if (ps >= (.94*ps_n1)) and (maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *stdev_multi)\u000a        _min = _mean - (_stdev *stdev_multi)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def cue_check(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=win) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        cue_color = self.cue_display(less_,greater_,p_min,p_max)\u000a        return cue_color\u000a    \u000a    def cue_display(self,less_,greater_,p_min,p_max):\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a    \u000a    def prepare_append(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            #ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lf_min.append(blank_event)#neg stdev from baseline mean\u000a            lf_mean.append(blank_event)#baseline mean\u000a            lf_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a            lmood.append(blank_event) #stimulus valience\u000a            lstim.append(blank_event) #stimulus name\u000a        else:\u000a            #if Block 2-4\u000a            if blockNum != 1:\u000a                #timing\u000a                #tt = eyelink.t_tracker()#tracker time\u000a                pp_t = event.getTime()#psychopy time\u000a                \u000a                #creating variables for cross-validation\u000a                lblock.append(blockNum)#block\u000a                ltrial.append(trialNum)#trial\u000a                levent.append(event_type)#baseline or stimulus\u000a                lpp_t.append(pp_t)#psychopy time\u000a                cpu_pc.append(cpu_s)#cpu\u000a                ram_pc.append(ram_s)#ram\u000a                \u000a                #fixation baseline            \u000a                lf_min.append(f_min)#neg stdev from baseline mean\u000a                lf_mean.append(f_mean)#baseline mean\u000a                lf_max.append(f_max)#pos stdev from baseline mean\u000a                #adjusted baseline\u000a                lps_min.append(ps_min)#neg stdev from baseline mean\u000a                lps_mean.append(ps_mean)#baseline mean\u000a                lps_max.append(ps_max)#pos stdev from baseline mean\u000a                \u000a                lps_uadj.append(ps_o)#unadjusted pupil size\u000a                lps_d.append(maV)#pupil size velocity\u000a                lps.append(ps_n)#adjusted pupil size\u000a                lcue.append(old_cue) #cue color\u000a                lblink.append(blink_event) #debug\u000a                lmood.append(valence) #stimulus valience\u000a                lstim.append(scenestim) #stimulus name\u000a                \u000a    def prepare_constants(self, event, stim_offset, blank_offset):\u000a        blank_event='nan'#dummy value\u000a        blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a        event_type=event #stimulus event label\u000a        old_cue = 'nan' #dummy values for time before first cue presentation\u000a        p_ma = 'nan' #dummy value for moving average\u000a        ps_n1 = 0 #n-1 pupil size\u000a        st0=0 #time between samples (st1-st0)\u000a        ct0=0 #time between cues (ct1-ct0)\u000a        maV=0 #velocity\u000a        stimulus_offset = stim_offset #time (sec)\u000a        blank_offset = blank_offset #time (sec)\u000a        Total_Samples_old=0 #no. of samples\u000a        return blink_event, event_type, old_cue,\u005c\u000a        p_ma, ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a        blank_offset, Total_Samples_old,blank_event\u000a        \u000a    def prepare_bool(self,baseline_):\u000a        first_loop = True # is first pupil sample\u000a        Window = True #window to collect samples\u000a        baseline = baseline_ #end of baseline samples\u000a        blink = False #blink occuring\u000a        ma_min = False #less than 3 samples for moving average\u000a        Cue = True #present cue\u000a        Event_draw = False #marks the zero-time in a trial\u000a        return first_loop, Window, baseline, blink, ma_min,\u005c\u000a        Cue, Event_draw\u000a\u000a    def prepare_lists(self):\u000a        lblink=[] #list of blink events\u000a        levent=[] #list of event types (baseline,trial)\u000a        lf_max=[]#list of pupil baseline max\u000a        lf_min=[]#list of pupil baseline min\u000a        lf_mean=[]#list of pupil baseline mean\u000a        lps_max=[]#list of pupil baseline max\u000a        lps_min=[]#list of pupil baseline min\u000a        lps_mean=[]#list of pupil baseline mean\u000a        lps_uadj=[] #list of unadjusted pupil samples \u000a        lps=[]#list of adjusted pupil samples\u000a        lps_d=[] #change in ps\u000a        lcue=[] #list of cue colors\u000a        lpp_t=[]#time stamp of each cue onset (psychopy)\u000a        ltrial=[]#list of trials at each cue\u000a        lblock=[]#list of trials at each cue\u000a        cpu_pc=[]#list of cpu usage, by %\u000a        ram_pc=[]#list of ram usage, by %\u000a        lstim=[] #stimulus\u000a        lmood=[] #valience\u000a        return lblink, levent,\u005c\u000a        lf_max, lf_min, lf_mean,\u005c\u000a        lps_max, lps_min, lps_mean,\u005c\u000a        lps_uadj, lps, lps_d, lcue, lpp_t, ltrial, lblock,\u005c\u000a        cpu_pc, ram_pc, lstim, lmood\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event","valence","stimulus",\u000a                          "psychopy_timestamp","cpu","ram",\u000a                          "fixation_baseline_min","fixation_baseline_mean","fixation_baseline_max",\u000a                          "stimulus_baseline_min","stimulus_baseline_mean","stimulus_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","feedback","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,lmood,lstim,\u000a                                            time_,cpu_pc,ram_pc,\u000a                                            lf_min,lf_mean,lf_max,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Block %s Image %s'" %(trialNum,blockNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.005\u000a        return cu\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000alblock_ps = []\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating per block\u000a    blockNum = blockNum + 1 #block count\u000a    if blockNum == 2:\u000a        b_min,b_max,b_mean,b_stdev = eyelink.min_max(lblock_ps)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #constants\u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('baseline',None,None)\u000a            \u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min, Cue,\u005c\u000a            Event_draw = eyelink.prepare_bool(True)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lpb_uadj, lpb, lpb_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()           \u000a            \u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    #if at least 2msec between samples\u000a                    if eyelink.t_sample(st1,st0):\u000a                        #if gaze window not achived                        \u000a                        if inbox != True: \u000a                            # eyelink-gaze contingent function\u000a                            eyelink.gc_window()   \u000a                            #eyelink-pupil size\u000a                            ps_old = eyelink.pupil_sample()\u000a                        st0 = st1\u000a                        eyelink.prepare_append(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #if gc failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect fixation baseline min max mean and stdev        \u000a            f_min,f_max,f_mean,f_stdev = eyelink.min_max(lpb_uadj)\u000a            \u000a            #if blink detected\u000a            ##check if any pupil size during gc window was less than 75% of baseline mean\u000a            blink_threshold = (.75*f_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a        \u000a        #Fixation Finished------------\u000a        #if first block\u000a        if blockNum == 1:\u000a            ps_min = f_min\u000a            ps_mean = f_mean\u000a            ps_max = f_max           \u000a        else:\u000a            ps_min = f_mean - (b_stdev *stdev_multi)\u000a            ps_mean = f_mean\u000a            ps_max = f_mean + (b_stdev *stdev_multi)\u000a            print('block: mean = %s, block min = %s, max = %s'%(b_mean, b_min, b_max))\u000a            print('fixation: mean = %s, min = %s, max = %s'%(f_mean, f_min, f_max))\u000a            print('threshold: mean = %s, min = %s, max = %s'%(ps_mean, ps_min, ps_max))\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            #stimulus and ITI duration\u000a            # if block 2-4\u000a            if blockNum == 1:\u000a                stim_offset = 5\u000a                iti_offset = 7\u000a            #else if block 1\u000a            else:\u000a                stim_offset = 10\u000a                iti_offset = 12\u000a            \u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('stimulus',stim_offset,iti_offset) #stim offset, blank offset\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min,\u005c\u000a            Cue, Event_draw = eyelink.prepare_bool(False)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lps_uadj, lps, lps_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()   \u000a     \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    win.flip()\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a\u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        #if Block 1\u000a                        if blockNum == 1:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):\u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)                    \u000a                            #if time = stimulus offset\u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                break\u000a                        #if Block 2-4                        \u000a                        else:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):                      \u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)\u000a                            #present Feedback\u000a                            if IAPSClock.getTime() >= 2:\u000a                                old_cue = eyelink.cue_check(lps,20,ps_min,ps_max)\u000a                            #End Stimulus presentation\u000a                            #if time = stimulus offset                   \u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                iaps_cue.setAutoDraw(False)\u000a                                break\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a                \u000a        if trialNum <5:\u000a            #concatinate lblock_ps with trial information\u000a            lblock_ps.extend(lps)\u000a            \u000a            #print results of block\u000a            if trialNum ==1:\u000a                trial_1 = len(lblock_ps)\u000a            if trialNum ==2:\u000a                trial_2 = len(lblock_ps) - trial_1\u000a            if trialNum ==3:\u000a                trial_3 = len(lblock_ps) - (trial_1+trial_2)\u000a            if trialNum ==4:\u000a                trial_4 = len(lblock_ps) - (trial_1+trial_2+trial_3)\u000a                \u000a            if trialNum ==4:\u000a                print('total_samples = %s' %(len(lblock_ps)))\u000a                print('trial_1 = %s,%s' %(trial_1,(len(lps))))\u000a                print('trial_2 = %s,%s' %(trial_2,(len(lps))))\u000a                print('trial_3 = %s,%s' %(trial_3,(len(lps))))\u000a                print('trial_4 = %s,%s' %(trial_4,(len(lps))))\u000a            \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p445
sg39
(lp446
sg53
I401540368
sg10
S'Introduction_Loop'
p447
sg6
g55
sg56
I1
sg18
I01
sg19
g20
sg57
g1
(g58
g41
(dp448
g60
g61
(g62
g63
g64
S'b'
tRp449
(I1
(I1
I1
tg66
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg75
g61
(g62
g63
g64
S'b'
tRp450
(I1
(I1
I1
tg66
I00
S'\x00\x00\x00\x00'
S'\x00'
NtbstRp451
(dp452
g80
(dp453
g60
I01
sg75
I01
ssg82
g443
sg83
(lp454
g60
ag75
asg85
(lp455
I1
aI1
asbsg87
g88
sg89
g67
(g63
(I0
tS'b'
tRp456
(I1
(I1
I1
tg91
I00
S'\x00\x00\x00\x00'
tbsg92
I01
sg93
I1
sg94
I-1
sg95
(lp457
g1
(g40
g41
(dp458
S'Introduction_image'
p459
S'inst_1'
p460
stRp461
asg111
Nsg112
g24
(g91
S'\x00\x00\x00\x00'
tRp462
sg114
I1
sg115
I0
sg116
I1
sg117
I01
sbag35
ag1
(g34
g3
NtRp463
(dp464
g37
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.04 (6/28)\u000aFrom Chris\u000a- 4 blocks\u000a	- block 1: set up baseline\u000a		- view-only block: establish baseline and SD for images\u000a		- present neutral images\u000a	- block 2-4: use baseline and adapt (trial level)\u000a		- shift baseline location (mean) and size (SD) according to fixation and feedback updates\u000a        		- if trial has no changes in feedback, shift threshold size (SD) down\u000a                 - if trial has too many changes in feedback, shift threshold size up\u000a            have this version present a version with shifts and without \u000a\u000achanges: \u000aDONE added new block. 1) this block will have the same images as succeeding blocks, but not feedback presentation\u000a                      stimuli during this block will also be present for 5 seconds\u000a                      2) pupil means will be collected during this block and used as a baseline for future blocks\u000a\u000aDONE    new baseline. 1) use the parameters setup by the new baseline (SD, mean) as thresholds for blocks 2-4.\u000a                      shift thresholds using baseline mean from fixation\u000a                      have two versions of task (shift version, no-shift version) and compare\u000a    \u000aDONE         cleanup. 1) created functions for trial-level lists, booleans, and constants\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a#eyelink-standard deviation constant\u000astdev_multi = 1\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True, units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    #if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                    if ps <= (.94*lst[-1]) and ps <= (.94*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                    if (ps >= (.94*ps_n1)) and (maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *stdev_multi)\u000a        _min = _mean - (_stdev *stdev_multi)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def cue_check(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=win) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        cue_color = self.cue_display(less_,greater_,p_min,p_max)\u000a        return cue_color\u000a    \u000a    def cue_display(self,less_,greater_,p_min,p_max):\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a    \u000a    def prepare_append(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            #ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lf_min.append(blank_event)#neg stdev from baseline mean\u000a            lf_mean.append(blank_event)#baseline mean\u000a            lf_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a            lmood.append(blank_event) #stimulus valience\u000a            lstim.append(blank_event) #stimulus name\u000a        else:\u000a            #if Block 2-4\u000a            if blockNum != 1:\u000a                #timing\u000a                #tt = eyelink.t_tracker()#tracker time\u000a                pp_t = event.getTime()#psychopy time\u000a                \u000a                #creating variables for cross-validation\u000a                lblock.append(blockNum)#block\u000a                ltrial.append(trialNum)#trial\u000a                levent.append(event_type)#baseline or stimulus\u000a                lpp_t.append(pp_t)#psychopy time\u000a                cpu_pc.append(cpu_s)#cpu\u000a                ram_pc.append(ram_s)#ram\u000a                \u000a                #fixation baseline            \u000a                lf_min.append(f_min)#neg stdev from baseline mean\u000a                lf_mean.append(f_mean)#baseline mean\u000a                lf_max.append(f_max)#pos stdev from baseline mean\u000a                #adjusted baseline\u000a                lps_min.append(ps_min)#neg stdev from baseline mean\u000a                lps_mean.append(ps_mean)#baseline mean\u000a                lps_max.append(ps_max)#pos stdev from baseline mean\u000a                \u000a                lps_uadj.append(ps_o)#unadjusted pupil size\u000a                lps_d.append(maV)#pupil size velocity\u000a                lps.append(ps_n)#adjusted pupil size\u000a                lcue.append(old_cue) #cue color\u000a                lblink.append(blink_event) #debug\u000a                lmood.append(valence) #stimulus valience\u000a                lstim.append(scenestim) #stimulus name\u000a                \u000a    def prepare_constants(self, event, stim_offset, blank_offset):\u000a        blank_event='nan'#dummy value\u000a        blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a        event_type=event #stimulus event label\u000a        old_cue = 'nan' #dummy values for time before first cue presentation\u000a        p_ma = 'nan' #dummy value for moving average\u000a        ps_n1 = 0 #n-1 pupil size\u000a        st0=0 #time between samples (st1-st0)\u000a        ct0=0 #time between cues (ct1-ct0)\u000a        maV=0 #velocity\u000a        stimulus_offset = stim_offset #time (sec)\u000a        blank_offset = blank_offset #time (sec)\u000a        Total_Samples_old=0 #no. of samples\u000a        return blink_event, event_type, old_cue,\u005c\u000a        p_ma, ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a        blank_offset, Total_Samples_old,blank_event\u000a        \u000a    def prepare_bool(self,baseline_):\u000a        first_loop = True # is first pupil sample\u000a        Window = True #window to collect samples\u000a        baseline = baseline_ #end of baseline samples\u000a        blink = False #blink occuring\u000a        ma_min = False #less than 3 samples for moving average\u000a        Cue = True #present cue\u000a        Event_draw = False #marks the zero-time in a trial\u000a        return first_loop, Window, baseline, blink, ma_min,\u005c\u000a        Cue, Event_draw\u000a\u000a    def prepare_lists(self):\u000a        lblink=[] #list of blink events\u000a        levent=[] #list of event types (baseline,trial)\u000a        lf_max=[]#list of pupil baseline max\u000a        lf_min=[]#list of pupil baseline min\u000a        lf_mean=[]#list of pupil baseline mean\u000a        lps_max=[]#list of pupil baseline max\u000a        lps_min=[]#list of pupil baseline min\u000a        lps_mean=[]#list of pupil baseline mean\u000a        lps_uadj=[] #list of unadjusted pupil samples \u000a        lps=[]#list of adjusted pupil samples\u000a        lps_d=[] #change in ps\u000a        lcue=[] #list of cue colors\u000a        lpp_t=[]#time stamp of each cue onset (psychopy)\u000a        ltrial=[]#list of trials at each cue\u000a        lblock=[]#list of trials at each cue\u000a        cpu_pc=[]#list of cpu usage, by %\u000a        ram_pc=[]#list of ram usage, by %\u000a        lstim=[] #stimulus\u000a        lmood=[] #valience\u000a        return lblink, levent,\u005c\u000a        lf_max, lf_min, lf_mean,\u005c\u000a        lps_max, lps_min, lps_mean,\u005c\u000a        lps_uadj, lps, lps_d, lcue, lpp_t, ltrial, lblock,\u005c\u000a        cpu_pc, ram_pc, lstim, lmood\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event","valence","stimulus",\u000a                          "psychopy_timestamp","cpu","ram",\u000a                          "fixation_baseline_min","fixation_baseline_mean","fixation_baseline_max",\u000a                          "stimulus_baseline_min","stimulus_baseline_mean","stimulus_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","feedback","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,lmood,lstim,\u000a                                            time_,cpu_pc,ram_pc,\u000a                                            lf_min,lf_mean,lf_max,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Block %s Image %s'" %(trialNum,blockNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.005\u000a        return cu\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000alblock_ps = []\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating per block\u000a    blockNum = blockNum + 1 #block count\u000a    if blockNum == 2:\u000a        b_min,b_max,b_mean,b_stdev = eyelink.min_max(lblock_ps)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #constants\u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('baseline',None,None)\u000a            \u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min, Cue,\u005c\u000a            Event_draw = eyelink.prepare_bool(True)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lpb_uadj, lpb, lpb_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()           \u000a            \u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    #if at least 2msec between samples\u000a                    if eyelink.t_sample(st1,st0):\u000a                        #if gaze window not achived                        \u000a                        if inbox != True: \u000a                            # eyelink-gaze contingent function\u000a                            eyelink.gc_window()   \u000a                            #eyelink-pupil size\u000a                            ps_old = eyelink.pupil_sample()\u000a                        st0 = st1\u000a                        eyelink.prepare_append(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #if gc failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect fixation baseline min max mean and stdev        \u000a            f_min,f_max,f_mean,f_stdev = eyelink.min_max(lpb_uadj)\u000a            \u000a            #if blink detected\u000a            ##check if any pupil size during gc window was less than 75% of baseline mean\u000a            blink_threshold = (.75*f_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a        \u000a        #Fixation Finished------------\u000a        #if first block\u000a        if blockNum == 1:\u000a            ps_min = f_min\u000a            ps_mean = f_mean\u000a            ps_max = f_max           \u000a        else:\u000a            ps_min = f_mean - (b_stdev *stdev_multi)\u000a            ps_mean = f_mean\u000a            ps_max = f_mean + (b_stdev *stdev_multi)\u000a            print('block: mean = %s, block min = %s, max = %s'%(b_mean, b_min, b_max))\u000a            print('fixation: mean = %s, min = %s, max = %s'%(f_mean, f_min, f_max))\u000a            print('threshold: mean = %s, min = %s, max = %s'%(ps_mean, ps_min, ps_max))\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            #stimulus and ITI duration\u000a            # if block 2-4\u000a            if blockNum == 1:\u000a                stim_offset = 5\u000a                iti_offset = 7\u000a            #else if block 1\u000a            else:\u000a                stim_offset = 10\u000a                iti_offset = 12\u000a            \u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('stimulus',stim_offset,iti_offset) #stim offset, blank offset\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min,\u005c\u000a            Cue, Event_draw = eyelink.prepare_bool(False)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lps_uadj, lps, lps_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()   \u000a     \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    win.flip()\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a\u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        #if Block 1\u000a                        if blockNum == 1:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):\u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)                    \u000a                            #if time = stimulus offset\u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                break\u000a                        #if Block 2-4                        \u000a                        else:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):                      \u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)\u000a                            #present Feedback\u000a                            if IAPSClock.getTime() >= 2:\u000a                                old_cue = eyelink.cue_check(lps,20,ps_min,ps_max)\u000a                            #End Stimulus presentation\u000a                            #if time = stimulus offset                   \u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                iaps_cue.setAutoDraw(False)\u000a                                break\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a                \u000a        if trialNum <5:\u000a            #concatinate lblock_ps with trial information\u000a            lblock_ps.extend(lps)\u000a            \u000a            #print results of block\u000a            if trialNum ==1:\u000a                trial_1 = len(lblock_ps)\u000a            if trialNum ==2:\u000a                trial_2 = len(lblock_ps) - trial_1\u000a            if trialNum ==3:\u000a                trial_3 = len(lblock_ps) - (trial_1+trial_2)\u000a            if trialNum ==4:\u000a                trial_4 = len(lblock_ps) - (trial_1+trial_2+trial_3)\u000a                \u000a            if trialNum ==4:\u000a                print('total_samples = %s' %(len(lblock_ps)))\u000a                print('trial_1 = %s,%s' %(trial_1,(len(lps))))\u000a                print('trial_2 = %s,%s' %(trial_2,(len(lps))))\u000a                print('trial_3 = %s,%s' %(trial_3,(len(lps))))\u000a                print('trial_4 = %s,%s' %(trial_4,(len(lps))))\u000a            \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p465
sg39
(lp466
sg53
I401540368
sg10
g137
sg6
g55
sg56
I1
sg18
I01
sg19
g20
sg57
g1
(g58
g41
(dp467
g60
g61
(g62
g63
g64
S'b'
tRp468
(I1
(I4
I1
tg66
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg75
g61
(g62
g63
g64
S'b'
tRp469
(I1
(I4
I1
tg66
I00
S'\x00\x00\x00@\x00\x00@@\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00'
NtbstRp470
(dp471
g80
(dp472
g60
I01
sg75
I01
ssg82
g463
sg83
(lp473
g60
ag75
asg85
(lp474
I4
aI1
asbsg87
g146
sg89
g67
(g63
(I0
tS'b'
tRp475
(I1
(I4
I1
tg91
I01
S'\x02\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00'
tbsg92
I01
sg93
I1
sg94
I-1
sg95
(lp476
g1
(g40
g41
(dp477
g178
g233
sg182
g230
sg180
g222
sg181
g195
sg179
g204
sg183
g227
sg184
g228
stRp478
ag1
(g40
g41
(dp479
g178
g248
sg182
g245
sg180
g237
sg181
g195
sg179
g204
sg183
g242
sg184
g243
stRp480
ag1
(g40
g41
(dp481
g178
g203
sg182
g199
sg180
g200
sg181
g195
sg179
g204
sg183
g189
sg184
g197
stRp482
ag1
(g40
g41
(dp483
g178
g218
sg182
g215
sg180
g207
sg181
g195
sg179
g204
sg183
g212
sg184
g213
stRp484
asg111
Nsg112
g240
sg114
I4
sg115
I0
sg116
I4
sg117
I01
sbag1
(g34
g3
NtRp485
(dp486
g37
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.04 (6/28)\u000aFrom Chris\u000a- 4 blocks\u000a	- block 1: set up baseline\u000a		- view-only block: establish baseline and SD for images\u000a		- present neutral images\u000a	- block 2-4: use baseline and adapt (trial level)\u000a		- shift baseline location (mean) and size (SD) according to fixation and feedback updates\u000a        		- if trial has no changes in feedback, shift threshold size (SD) down\u000a                 - if trial has too many changes in feedback, shift threshold size up\u000a            have this version present a version with shifts and without \u000a\u000achanges: \u000aDONE added new block. 1) this block will have the same images as succeeding blocks, but not feedback presentation\u000a                      stimuli during this block will also be present for 5 seconds\u000a                      2) pupil means will be collected during this block and used as a baseline for future blocks\u000a\u000aDONE    new baseline. 1) use the parameters setup by the new baseline (SD, mean) as thresholds for blocks 2-4.\u000a                      shift thresholds using baseline mean from fixation\u000a                      have two versions of task (shift version, no-shift version) and compare\u000a    \u000aDONE         cleanup. 1) created functions for trial-level lists, booleans, and constants\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a#eyelink-standard deviation constant\u000astdev_multi = 1\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True, units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    #if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                    if ps <= (.94*lst[-1]) and ps <= (.94*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                    if (ps >= (.94*ps_n1)) and (maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *stdev_multi)\u000a        _min = _mean - (_stdev *stdev_multi)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def cue_check(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=win) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        cue_color = self.cue_display(less_,greater_,p_min,p_max)\u000a        return cue_color\u000a    \u000a    def cue_display(self,less_,greater_,p_min,p_max):\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a    \u000a    def prepare_append(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            #ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lf_min.append(blank_event)#neg stdev from baseline mean\u000a            lf_mean.append(blank_event)#baseline mean\u000a            lf_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a            lmood.append(blank_event) #stimulus valience\u000a            lstim.append(blank_event) #stimulus name\u000a        else:\u000a            #if Block 2-4\u000a            if blockNum != 1:\u000a                #timing\u000a                #tt = eyelink.t_tracker()#tracker time\u000a                pp_t = event.getTime()#psychopy time\u000a                \u000a                #creating variables for cross-validation\u000a                lblock.append(blockNum)#block\u000a                ltrial.append(trialNum)#trial\u000a                levent.append(event_type)#baseline or stimulus\u000a                lpp_t.append(pp_t)#psychopy time\u000a                cpu_pc.append(cpu_s)#cpu\u000a                ram_pc.append(ram_s)#ram\u000a                \u000a                #fixation baseline            \u000a                lf_min.append(f_min)#neg stdev from baseline mean\u000a                lf_mean.append(f_mean)#baseline mean\u000a                lf_max.append(f_max)#pos stdev from baseline mean\u000a                #adjusted baseline\u000a                lps_min.append(ps_min)#neg stdev from baseline mean\u000a                lps_mean.append(ps_mean)#baseline mean\u000a                lps_max.append(ps_max)#pos stdev from baseline mean\u000a                \u000a                lps_uadj.append(ps_o)#unadjusted pupil size\u000a                lps_d.append(maV)#pupil size velocity\u000a                lps.append(ps_n)#adjusted pupil size\u000a                lcue.append(old_cue) #cue color\u000a                lblink.append(blink_event) #debug\u000a                lmood.append(valence) #stimulus valience\u000a                lstim.append(scenestim) #stimulus name\u000a                \u000a    def prepare_constants(self, event, stim_offset, blank_offset):\u000a        blank_event='nan'#dummy value\u000a        blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a        event_type=event #stimulus event label\u000a        old_cue = 'nan' #dummy values for time before first cue presentation\u000a        p_ma = 'nan' #dummy value for moving average\u000a        ps_n1 = 0 #n-1 pupil size\u000a        st0=0 #time between samples (st1-st0)\u000a        ct0=0 #time between cues (ct1-ct0)\u000a        maV=0 #velocity\u000a        stimulus_offset = stim_offset #time (sec)\u000a        blank_offset = blank_offset #time (sec)\u000a        Total_Samples_old=0 #no. of samples\u000a        return blink_event, event_type, old_cue,\u005c\u000a        p_ma, ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a        blank_offset, Total_Samples_old,blank_event\u000a        \u000a    def prepare_bool(self,baseline_):\u000a        first_loop = True # is first pupil sample\u000a        Window = True #window to collect samples\u000a        baseline = baseline_ #end of baseline samples\u000a        blink = False #blink occuring\u000a        ma_min = False #less than 3 samples for moving average\u000a        Cue = True #present cue\u000a        Event_draw = False #marks the zero-time in a trial\u000a        return first_loop, Window, baseline, blink, ma_min,\u005c\u000a        Cue, Event_draw\u000a\u000a    def prepare_lists(self):\u000a        lblink=[] #list of blink events\u000a        levent=[] #list of event types (baseline,trial)\u000a        lf_max=[]#list of pupil baseline max\u000a        lf_min=[]#list of pupil baseline min\u000a        lf_mean=[]#list of pupil baseline mean\u000a        lps_max=[]#list of pupil baseline max\u000a        lps_min=[]#list of pupil baseline min\u000a        lps_mean=[]#list of pupil baseline mean\u000a        lps_uadj=[] #list of unadjusted pupil samples \u000a        lps=[]#list of adjusted pupil samples\u000a        lps_d=[] #change in ps\u000a        lcue=[] #list of cue colors\u000a        lpp_t=[]#time stamp of each cue onset (psychopy)\u000a        ltrial=[]#list of trials at each cue\u000a        lblock=[]#list of trials at each cue\u000a        cpu_pc=[]#list of cpu usage, by %\u000a        ram_pc=[]#list of ram usage, by %\u000a        lstim=[] #stimulus\u000a        lmood=[] #valience\u000a        return lblink, levent,\u005c\u000a        lf_max, lf_min, lf_mean,\u005c\u000a        lps_max, lps_min, lps_mean,\u005c\u000a        lps_uadj, lps, lps_d, lcue, lpp_t, ltrial, lblock,\u005c\u000a        cpu_pc, ram_pc, lstim, lmood\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event","valence","stimulus",\u000a                          "psychopy_timestamp","cpu","ram",\u000a                          "fixation_baseline_min","fixation_baseline_mean","fixation_baseline_max",\u000a                          "stimulus_baseline_min","stimulus_baseline_mean","stimulus_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","feedback","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,lmood,lstim,\u000a                                            time_,cpu_pc,ram_pc,\u000a                                            lf_min,lf_mean,lf_max,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Block %s Image %s'" %(trialNum,blockNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.005\u000a        return cu\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000alblock_ps = []\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating per block\u000a    blockNum = blockNum + 1 #block count\u000a    if blockNum == 2:\u000a        b_min,b_max,b_mean,b_stdev = eyelink.min_max(lblock_ps)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #constants\u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('baseline',None,None)\u000a            \u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min, Cue,\u005c\u000a            Event_draw = eyelink.prepare_bool(True)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lpb_uadj, lpb, lpb_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()           \u000a            \u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    #if at least 2msec between samples\u000a                    if eyelink.t_sample(st1,st0):\u000a                        #if gaze window not achived                        \u000a                        if inbox != True: \u000a                            # eyelink-gaze contingent function\u000a                            eyelink.gc_window()   \u000a                            #eyelink-pupil size\u000a                            ps_old = eyelink.pupil_sample()\u000a                        st0 = st1\u000a                        eyelink.prepare_append(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #if gc failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect fixation baseline min max mean and stdev        \u000a            f_min,f_max,f_mean,f_stdev = eyelink.min_max(lpb_uadj)\u000a            \u000a            #if blink detected\u000a            ##check if any pupil size during gc window was less than 75% of baseline mean\u000a            blink_threshold = (.75*f_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a        \u000a        #Fixation Finished------------\u000a        #if first block\u000a        if blockNum == 1:\u000a            ps_min = f_min\u000a            ps_mean = f_mean\u000a            ps_max = f_max           \u000a        else:\u000a            ps_min = f_mean - (b_stdev *stdev_multi)\u000a            ps_mean = f_mean\u000a            ps_max = f_mean + (b_stdev *stdev_multi)\u000a            print('block: mean = %s, block min = %s, max = %s'%(b_mean, b_min, b_max))\u000a            print('fixation: mean = %s, min = %s, max = %s'%(f_mean, f_min, f_max))\u000a            print('threshold: mean = %s, min = %s, max = %s'%(ps_mean, ps_min, ps_max))\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            #stimulus and ITI duration\u000a            # if block 2-4\u000a            if blockNum == 1:\u000a                stim_offset = 5\u000a                iti_offset = 7\u000a            #else if block 1\u000a            else:\u000a                stim_offset = 10\u000a                iti_offset = 12\u000a            \u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('stimulus',stim_offset,iti_offset) #stim offset, blank offset\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min,\u005c\u000a            Cue, Event_draw = eyelink.prepare_bool(False)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lps_uadj, lps, lps_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()   \u000a     \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    win.flip()\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a\u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        #if Block 1\u000a                        if blockNum == 1:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):\u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)                    \u000a                            #if time = stimulus offset\u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                break\u000a                        #if Block 2-4                        \u000a                        else:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):                      \u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)\u000a                            #present Feedback\u000a                            if IAPSClock.getTime() >= 2:\u000a                                old_cue = eyelink.cue_check(lps,20,ps_min,ps_max)\u000a                            #End Stimulus presentation\u000a                            #if time = stimulus offset                   \u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                iaps_cue.setAutoDraw(False)\u000a                                break\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a                \u000a        if trialNum <5:\u000a            #concatinate lblock_ps with trial information\u000a            lblock_ps.extend(lps)\u000a            \u000a            #print results of block\u000a            if trialNum ==1:\u000a                trial_1 = len(lblock_ps)\u000a            if trialNum ==2:\u000a                trial_2 = len(lblock_ps) - trial_1\u000a            if trialNum ==3:\u000a                trial_3 = len(lblock_ps) - (trial_1+trial_2)\u000a            if trialNum ==4:\u000a                trial_4 = len(lblock_ps) - (trial_1+trial_2+trial_3)\u000a                \u000a            if trialNum ==4:\u000a                print('total_samples = %s' %(len(lblock_ps)))\u000a                print('trial_1 = %s,%s' %(trial_1,(len(lps))))\u000a                print('trial_2 = %s,%s' %(trial_2,(len(lps))))\u000a                print('trial_3 = %s,%s' %(trial_3,(len(lps))))\u000a                print('trial_4 = %s,%s' %(trial_4,(len(lps))))\u000a            \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p487
sg39
(lp488
sg53
I401540368
sg10
S'Break_loop'
p489
sg6
g55
sg56
I1
sg18
I01
sg19
g20
sg57
g1
(g58
g41
(dp490
g60
g61
(g62
g63
g64
S'b'
tRp491
(I1
(I1
I1
tg66
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg17
g61
(g62
g63
g64
S'b'
tRp492
(I1
(I1
I1
tg66
I00
S'{#"@'
S'\x00'
Ntbsg75
g61
(g62
g63
g64
S'b'
tRp493
(I1
(I1
I1
tg66
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g67
(g63
(I0
tS'b'
tRp494
(I1
(I1
I1
tg69
I00
(lp495
g254
atbstRp496
(dp497
g80
(dp498
g60
I01
sg17
I01
sg75
I01
sg16
I00
ssg82
g485
sg83
(lp499
g60
ag75
ag16
ag17
asg85
(lp500
I1
aI1
asbsg87
g146
sg89
g67
(g63
(I0
tS'b'
tRp501
(I1
(I1
I1
tg91
I00
S'\x00\x00\x00\x00'
tbsg92
I01
sg93
I1
sg94
I-1
sg95
(lp502
Nasg111
Nsg112
g258
sg114
I1
sg115
I0
sg116
I1
sg117
I01
sbag1
(g34
g3
NtRp503
(dp504
g37
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.04 (6/28)\u000aFrom Chris\u000a- 4 blocks\u000a	- block 1: set up baseline\u000a		- view-only block: establish baseline and SD for images\u000a		- present neutral images\u000a	- block 2-4: use baseline and adapt (trial level)\u000a		- shift baseline location (mean) and size (SD) according to fixation and feedback updates\u000a        		- if trial has no changes in feedback, shift threshold size (SD) down\u000a                 - if trial has too many changes in feedback, shift threshold size up\u000a            have this version present a version with shifts and without \u000a\u000achanges: \u000aDONE added new block. 1) this block will have the same images as succeeding blocks, but not feedback presentation\u000a                      stimuli during this block will also be present for 5 seconds\u000a                      2) pupil means will be collected during this block and used as a baseline for future blocks\u000a\u000aDONE    new baseline. 1) use the parameters setup by the new baseline (SD, mean) as thresholds for blocks 2-4.\u000a                      shift thresholds using baseline mean from fixation\u000a                      have two versions of task (shift version, no-shift version) and compare\u000a    \u000aDONE         cleanup. 1) created functions for trial-level lists, booleans, and constants\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a#eyelink-standard deviation constant\u000astdev_multi = 1\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True, units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    #if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                    if ps <= (.94*lst[-1]) and ps <= (.94*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                    if (ps >= (.94*ps_n1)) and (maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *stdev_multi)\u000a        _min = _mean - (_stdev *stdev_multi)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def cue_check(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=win) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        cue_color = self.cue_display(less_,greater_,p_min,p_max)\u000a        return cue_color\u000a    \u000a    def cue_display(self,less_,greater_,p_min,p_max):\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a    \u000a    def prepare_append(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            #ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lf_min.append(blank_event)#neg stdev from baseline mean\u000a            lf_mean.append(blank_event)#baseline mean\u000a            lf_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a            lmood.append(blank_event) #stimulus valience\u000a            lstim.append(blank_event) #stimulus name\u000a        else:\u000a            #if Block 2-4\u000a            if blockNum != 1:\u000a                #timing\u000a                #tt = eyelink.t_tracker()#tracker time\u000a                pp_t = event.getTime()#psychopy time\u000a                \u000a                #creating variables for cross-validation\u000a                lblock.append(blockNum)#block\u000a                ltrial.append(trialNum)#trial\u000a                levent.append(event_type)#baseline or stimulus\u000a                lpp_t.append(pp_t)#psychopy time\u000a                cpu_pc.append(cpu_s)#cpu\u000a                ram_pc.append(ram_s)#ram\u000a                \u000a                #fixation baseline            \u000a                lf_min.append(f_min)#neg stdev from baseline mean\u000a                lf_mean.append(f_mean)#baseline mean\u000a                lf_max.append(f_max)#pos stdev from baseline mean\u000a                #adjusted baseline\u000a                lps_min.append(ps_min)#neg stdev from baseline mean\u000a                lps_mean.append(ps_mean)#baseline mean\u000a                lps_max.append(ps_max)#pos stdev from baseline mean\u000a                \u000a                lps_uadj.append(ps_o)#unadjusted pupil size\u000a                lps_d.append(maV)#pupil size velocity\u000a                lps.append(ps_n)#adjusted pupil size\u000a                lcue.append(old_cue) #cue color\u000a                lblink.append(blink_event) #debug\u000a                lmood.append(valence) #stimulus valience\u000a                lstim.append(scenestim) #stimulus name\u000a                \u000a    def prepare_constants(self, event, stim_offset, blank_offset):\u000a        blank_event='nan'#dummy value\u000a        blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a        event_type=event #stimulus event label\u000a        old_cue = 'nan' #dummy values for time before first cue presentation\u000a        p_ma = 'nan' #dummy value for moving average\u000a        ps_n1 = 0 #n-1 pupil size\u000a        st0=0 #time between samples (st1-st0)\u000a        ct0=0 #time between cues (ct1-ct0)\u000a        maV=0 #velocity\u000a        stimulus_offset = stim_offset #time (sec)\u000a        blank_offset = blank_offset #time (sec)\u000a        Total_Samples_old=0 #no. of samples\u000a        return blink_event, event_type, old_cue,\u005c\u000a        p_ma, ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a        blank_offset, Total_Samples_old,blank_event\u000a        \u000a    def prepare_bool(self,baseline_):\u000a        first_loop = True # is first pupil sample\u000a        Window = True #window to collect samples\u000a        baseline = baseline_ #end of baseline samples\u000a        blink = False #blink occuring\u000a        ma_min = False #less than 3 samples for moving average\u000a        Cue = True #present cue\u000a        Event_draw = False #marks the zero-time in a trial\u000a        return first_loop, Window, baseline, blink, ma_min,\u005c\u000a        Cue, Event_draw\u000a\u000a    def prepare_lists(self):\u000a        lblink=[] #list of blink events\u000a        levent=[] #list of event types (baseline,trial)\u000a        lf_max=[]#list of pupil baseline max\u000a        lf_min=[]#list of pupil baseline min\u000a        lf_mean=[]#list of pupil baseline mean\u000a        lps_max=[]#list of pupil baseline max\u000a        lps_min=[]#list of pupil baseline min\u000a        lps_mean=[]#list of pupil baseline mean\u000a        lps_uadj=[] #list of unadjusted pupil samples \u000a        lps=[]#list of adjusted pupil samples\u000a        lps_d=[] #change in ps\u000a        lcue=[] #list of cue colors\u000a        lpp_t=[]#time stamp of each cue onset (psychopy)\u000a        ltrial=[]#list of trials at each cue\u000a        lblock=[]#list of trials at each cue\u000a        cpu_pc=[]#list of cpu usage, by %\u000a        ram_pc=[]#list of ram usage, by %\u000a        lstim=[] #stimulus\u000a        lmood=[] #valience\u000a        return lblink, levent,\u005c\u000a        lf_max, lf_min, lf_mean,\u005c\u000a        lps_max, lps_min, lps_mean,\u005c\u000a        lps_uadj, lps, lps_d, lcue, lpp_t, ltrial, lblock,\u005c\u000a        cpu_pc, ram_pc, lstim, lmood\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event","valence","stimulus",\u000a                          "psychopy_timestamp","cpu","ram",\u000a                          "fixation_baseline_min","fixation_baseline_mean","fixation_baseline_max",\u000a                          "stimulus_baseline_min","stimulus_baseline_mean","stimulus_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","feedback","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,lmood,lstim,\u000a                                            time_,cpu_pc,ram_pc,\u000a                                            lf_min,lf_mean,lf_max,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Block %s Image %s'" %(trialNum,blockNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.005\u000a        return cu\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000alblock_ps = []\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating per block\u000a    blockNum = blockNum + 1 #block count\u000a    if blockNum == 2:\u000a        b_min,b_max,b_mean,b_stdev = eyelink.min_max(lblock_ps)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #constants\u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('baseline',None,None)\u000a            \u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min, Cue,\u005c\u000a            Event_draw = eyelink.prepare_bool(True)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lpb_uadj, lpb, lpb_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()           \u000a            \u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    #if at least 2msec between samples\u000a                    if eyelink.t_sample(st1,st0):\u000a                        #if gaze window not achived                        \u000a                        if inbox != True: \u000a                            # eyelink-gaze contingent function\u000a                            eyelink.gc_window()   \u000a                            #eyelink-pupil size\u000a                            ps_old = eyelink.pupil_sample()\u000a                        st0 = st1\u000a                        eyelink.prepare_append(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #if gc failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect fixation baseline min max mean and stdev        \u000a            f_min,f_max,f_mean,f_stdev = eyelink.min_max(lpb_uadj)\u000a            \u000a            #if blink detected\u000a            ##check if any pupil size during gc window was less than 75% of baseline mean\u000a            blink_threshold = (.75*f_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a        \u000a        #Fixation Finished------------\u000a        #if first block\u000a        if blockNum == 1:\u000a            ps_min = f_min\u000a            ps_mean = f_mean\u000a            ps_max = f_max           \u000a        else:\u000a            ps_min = f_mean - (b_stdev *stdev_multi)\u000a            ps_mean = f_mean\u000a            ps_max = f_mean + (b_stdev *stdev_multi)\u000a            print('block: mean = %s, block min = %s, max = %s'%(b_mean, b_min, b_max))\u000a            print('fixation: mean = %s, min = %s, max = %s'%(f_mean, f_min, f_max))\u000a            print('threshold: mean = %s, min = %s, max = %s'%(ps_mean, ps_min, ps_max))\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            #stimulus and ITI duration\u000a            # if block 2-4\u000a            if blockNum == 1:\u000a                stim_offset = 5\u000a                iti_offset = 7\u000a            #else if block 1\u000a            else:\u000a                stim_offset = 10\u000a                iti_offset = 12\u000a            \u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('stimulus',stim_offset,iti_offset) #stim offset, blank offset\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min,\u005c\u000a            Cue, Event_draw = eyelink.prepare_bool(False)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lps_uadj, lps, lps_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()   \u000a     \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    win.flip()\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a\u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        #if Block 1\u000a                        if blockNum == 1:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):\u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)                    \u000a                            #if time = stimulus offset\u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                break\u000a                        #if Block 2-4                        \u000a                        else:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):                      \u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)\u000a                            #present Feedback\u000a                            if IAPSClock.getTime() >= 2:\u000a                                old_cue = eyelink.cue_check(lps,20,ps_min,ps_max)\u000a                            #End Stimulus presentation\u000a                            #if time = stimulus offset                   \u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                iaps_cue.setAutoDraw(False)\u000a                                break\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a                \u000a        if trialNum <5:\u000a            #concatinate lblock_ps with trial information\u000a            lblock_ps.extend(lps)\u000a            \u000a            #print results of block\u000a            if trialNum ==1:\u000a                trial_1 = len(lblock_ps)\u000a            if trialNum ==2:\u000a                trial_2 = len(lblock_ps) - trial_1\u000a            if trialNum ==3:\u000a                trial_3 = len(lblock_ps) - (trial_1+trial_2)\u000a            if trialNum ==4:\u000a                trial_4 = len(lblock_ps) - (trial_1+trial_2+trial_3)\u000a                \u000a            if trialNum ==4:\u000a                print('total_samples = %s' %(len(lblock_ps)))\u000a                print('trial_1 = %s,%s' %(trial_1,(len(lps))))\u000a                print('trial_2 = %s,%s' %(trial_2,(len(lps))))\u000a                print('trial_3 = %s,%s' %(trial_3,(len(lps))))\u000a                print('trial_4 = %s,%s' %(trial_4,(len(lps))))\u000a            \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p505
sg39
(lp506
sg53
I401540368
sg10
g137
sg6
g55
sg56
I1
sg18
I01
sg19
g20
sg57
g1
(g58
g41
(dp507
g60
g61
(g62
g63
g64
S'b'
tRp508
(I1
(I4
I1
tg66
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg75
g61
(g62
g63
g64
S'b'
tRp509
(I1
(I4
I1
tg66
I00
S'\x00\x00@@\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00@'
S'\x00\x00\x00\x00'
NtbstRp510
(dp511
g80
(dp512
g60
I01
sg75
I01
ssg82
g503
sg83
(lp513
g60
ag75
asg85
(lp514
I4
aI1
asbsg87
g146
sg89
g67
(g63
(I0
tS'b'
tRp515
(I1
(I4
I1
tg91
I01
S'\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00'
tbsg92
I01
sg93
I1
sg94
I-1
sg95
(lp516
g1
(g40
g41
(dp517
g288
g336
sg282
g333
sg284
g325
sg276
g277
sg290
g291
sg269
g330
sg279
g331
stRp518
ag1
(g40
g41
(dp519
g288
g305
sg282
g302
sg284
g294
sg276
g277
sg290
g306
sg269
g299
sg279
g300
stRp520
ag1
(g40
g41
(dp521
g288
g289
sg282
g283
sg284
g285
sg276
g277
sg290
g291
sg269
g270
sg279
g280
stRp522
ag1
(g40
g41
(dp523
g288
g321
sg282
g318
sg284
g310
sg276
g277
sg290
g306
sg269
g315
sg279
g316
stRp524
asg111
Nsg112
g328
sg114
I4
sg115
I0
sg116
I4
sg117
I01
sbag1
(g34
g3
NtRp525
(dp526
g37
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.04 (6/28)\u000aFrom Chris\u000a- 4 blocks\u000a	- block 1: set up baseline\u000a		- view-only block: establish baseline and SD for images\u000a		- present neutral images\u000a	- block 2-4: use baseline and adapt (trial level)\u000a		- shift baseline location (mean) and size (SD) according to fixation and feedback updates\u000a        		- if trial has no changes in feedback, shift threshold size (SD) down\u000a                 - if trial has too many changes in feedback, shift threshold size up\u000a            have this version present a version with shifts and without \u000a\u000achanges: \u000aDONE added new block. 1) this block will have the same images as succeeding blocks, but not feedback presentation\u000a                      stimuli during this block will also be present for 5 seconds\u000a                      2) pupil means will be collected during this block and used as a baseline for future blocks\u000a\u000aDONE    new baseline. 1) use the parameters setup by the new baseline (SD, mean) as thresholds for blocks 2-4.\u000a                      shift thresholds using baseline mean from fixation\u000a                      have two versions of task (shift version, no-shift version) and compare\u000a    \u000aDONE         cleanup. 1) created functions for trial-level lists, booleans, and constants\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a#eyelink-standard deviation constant\u000astdev_multi = 1\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True, units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    #if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                    if ps <= (.94*lst[-1]) and ps <= (.94*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                    if (ps >= (.94*ps_n1)) and (maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *stdev_multi)\u000a        _min = _mean - (_stdev *stdev_multi)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def cue_check(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=win) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        cue_color = self.cue_display(less_,greater_,p_min,p_max)\u000a        return cue_color\u000a    \u000a    def cue_display(self,less_,greater_,p_min,p_max):\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a    \u000a    def prepare_append(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            #ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lf_min.append(blank_event)#neg stdev from baseline mean\u000a            lf_mean.append(blank_event)#baseline mean\u000a            lf_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a            lmood.append(blank_event) #stimulus valience\u000a            lstim.append(blank_event) #stimulus name\u000a        else:\u000a            #if Block 2-4\u000a            if blockNum != 1:\u000a                #timing\u000a                #tt = eyelink.t_tracker()#tracker time\u000a                pp_t = event.getTime()#psychopy time\u000a                \u000a                #creating variables for cross-validation\u000a                lblock.append(blockNum)#block\u000a                ltrial.append(trialNum)#trial\u000a                levent.append(event_type)#baseline or stimulus\u000a                lpp_t.append(pp_t)#psychopy time\u000a                cpu_pc.append(cpu_s)#cpu\u000a                ram_pc.append(ram_s)#ram\u000a                \u000a                #fixation baseline            \u000a                lf_min.append(f_min)#neg stdev from baseline mean\u000a                lf_mean.append(f_mean)#baseline mean\u000a                lf_max.append(f_max)#pos stdev from baseline mean\u000a                #adjusted baseline\u000a                lps_min.append(ps_min)#neg stdev from baseline mean\u000a                lps_mean.append(ps_mean)#baseline mean\u000a                lps_max.append(ps_max)#pos stdev from baseline mean\u000a                \u000a                lps_uadj.append(ps_o)#unadjusted pupil size\u000a                lps_d.append(maV)#pupil size velocity\u000a                lps.append(ps_n)#adjusted pupil size\u000a                lcue.append(old_cue) #cue color\u000a                lblink.append(blink_event) #debug\u000a                lmood.append(valence) #stimulus valience\u000a                lstim.append(scenestim) #stimulus name\u000a                \u000a    def prepare_constants(self, event, stim_offset, blank_offset):\u000a        blank_event='nan'#dummy value\u000a        blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a        event_type=event #stimulus event label\u000a        old_cue = 'nan' #dummy values for time before first cue presentation\u000a        p_ma = 'nan' #dummy value for moving average\u000a        ps_n1 = 0 #n-1 pupil size\u000a        st0=0 #time between samples (st1-st0)\u000a        ct0=0 #time between cues (ct1-ct0)\u000a        maV=0 #velocity\u000a        stimulus_offset = stim_offset #time (sec)\u000a        blank_offset = blank_offset #time (sec)\u000a        Total_Samples_old=0 #no. of samples\u000a        return blink_event, event_type, old_cue,\u005c\u000a        p_ma, ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a        blank_offset, Total_Samples_old,blank_event\u000a        \u000a    def prepare_bool(self,baseline_):\u000a        first_loop = True # is first pupil sample\u000a        Window = True #window to collect samples\u000a        baseline = baseline_ #end of baseline samples\u000a        blink = False #blink occuring\u000a        ma_min = False #less than 3 samples for moving average\u000a        Cue = True #present cue\u000a        Event_draw = False #marks the zero-time in a trial\u000a        return first_loop, Window, baseline, blink, ma_min,\u005c\u000a        Cue, Event_draw\u000a\u000a    def prepare_lists(self):\u000a        lblink=[] #list of blink events\u000a        levent=[] #list of event types (baseline,trial)\u000a        lf_max=[]#list of pupil baseline max\u000a        lf_min=[]#list of pupil baseline min\u000a        lf_mean=[]#list of pupil baseline mean\u000a        lps_max=[]#list of pupil baseline max\u000a        lps_min=[]#list of pupil baseline min\u000a        lps_mean=[]#list of pupil baseline mean\u000a        lps_uadj=[] #list of unadjusted pupil samples \u000a        lps=[]#list of adjusted pupil samples\u000a        lps_d=[] #change in ps\u000a        lcue=[] #list of cue colors\u000a        lpp_t=[]#time stamp of each cue onset (psychopy)\u000a        ltrial=[]#list of trials at each cue\u000a        lblock=[]#list of trials at each cue\u000a        cpu_pc=[]#list of cpu usage, by %\u000a        ram_pc=[]#list of ram usage, by %\u000a        lstim=[] #stimulus\u000a        lmood=[] #valience\u000a        return lblink, levent,\u005c\u000a        lf_max, lf_min, lf_mean,\u005c\u000a        lps_max, lps_min, lps_mean,\u005c\u000a        lps_uadj, lps, lps_d, lcue, lpp_t, ltrial, lblock,\u005c\u000a        cpu_pc, ram_pc, lstim, lmood\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event","valence","stimulus",\u000a                          "psychopy_timestamp","cpu","ram",\u000a                          "fixation_baseline_min","fixation_baseline_mean","fixation_baseline_max",\u000a                          "stimulus_baseline_min","stimulus_baseline_mean","stimulus_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","feedback","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,lmood,lstim,\u000a                                            time_,cpu_pc,ram_pc,\u000a                                            lf_min,lf_mean,lf_max,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Block %s Image %s'" %(trialNum,blockNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.005\u000a        return cu\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000alblock_ps = []\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating per block\u000a    blockNum = blockNum + 1 #block count\u000a    if blockNum == 2:\u000a        b_min,b_max,b_mean,b_stdev = eyelink.min_max(lblock_ps)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #constants\u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('baseline',None,None)\u000a            \u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min, Cue,\u005c\u000a            Event_draw = eyelink.prepare_bool(True)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lpb_uadj, lpb, lpb_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()           \u000a            \u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    #if at least 2msec between samples\u000a                    if eyelink.t_sample(st1,st0):\u000a                        #if gaze window not achived                        \u000a                        if inbox != True: \u000a                            # eyelink-gaze contingent function\u000a                            eyelink.gc_window()   \u000a                            #eyelink-pupil size\u000a                            ps_old = eyelink.pupil_sample()\u000a                        st0 = st1\u000a                        eyelink.prepare_append(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #if gc failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect fixation baseline min max mean and stdev        \u000a            f_min,f_max,f_mean,f_stdev = eyelink.min_max(lpb_uadj)\u000a            \u000a            #if blink detected\u000a            ##check if any pupil size during gc window was less than 75% of baseline mean\u000a            blink_threshold = (.75*f_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a        \u000a        #Fixation Finished------------\u000a        #if first block\u000a        if blockNum == 1:\u000a            ps_min = f_min\u000a            ps_mean = f_mean\u000a            ps_max = f_max           \u000a        else:\u000a            ps_min = f_mean - (b_stdev *stdev_multi)\u000a            ps_mean = f_mean\u000a            ps_max = f_mean + (b_stdev *stdev_multi)\u000a            print('block: mean = %s, block min = %s, max = %s'%(b_mean, b_min, b_max))\u000a            print('fixation: mean = %s, min = %s, max = %s'%(f_mean, f_min, f_max))\u000a            print('threshold: mean = %s, min = %s, max = %s'%(ps_mean, ps_min, ps_max))\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            #stimulus and ITI duration\u000a            # if block 2-4\u000a            if blockNum == 1:\u000a                stim_offset = 5\u000a                iti_offset = 7\u000a            #else if block 1\u000a            else:\u000a                stim_offset = 10\u000a                iti_offset = 12\u000a            \u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('stimulus',stim_offset,iti_offset) #stim offset, blank offset\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min,\u005c\u000a            Cue, Event_draw = eyelink.prepare_bool(False)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lps_uadj, lps, lps_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()   \u000a     \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    win.flip()\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a\u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        #if Block 1\u000a                        if blockNum == 1:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):\u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)                    \u000a                            #if time = stimulus offset\u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                break\u000a                        #if Block 2-4                        \u000a                        else:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):                      \u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)\u000a                            #present Feedback\u000a                            if IAPSClock.getTime() >= 2:\u000a                                old_cue = eyelink.cue_check(lps,20,ps_min,ps_max)\u000a                            #End Stimulus presentation\u000a                            #if time = stimulus offset                   \u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                iaps_cue.setAutoDraw(False)\u000a                                break\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a                \u000a        if trialNum <5:\u000a            #concatinate lblock_ps with trial information\u000a            lblock_ps.extend(lps)\u000a            \u000a            #print results of block\u000a            if trialNum ==1:\u000a                trial_1 = len(lblock_ps)\u000a            if trialNum ==2:\u000a                trial_2 = len(lblock_ps) - trial_1\u000a            if trialNum ==3:\u000a                trial_3 = len(lblock_ps) - (trial_1+trial_2)\u000a            if trialNum ==4:\u000a                trial_4 = len(lblock_ps) - (trial_1+trial_2+trial_3)\u000a                \u000a            if trialNum ==4:\u000a                print('total_samples = %s' %(len(lblock_ps)))\u000a                print('trial_1 = %s,%s' %(trial_1,(len(lps))))\u000a                print('trial_2 = %s,%s' %(trial_2,(len(lps))))\u000a                print('trial_3 = %s,%s' %(trial_3,(len(lps))))\u000a                print('trial_4 = %s,%s' %(trial_4,(len(lps))))\u000a            \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p527
sg39
(lp528
sg53
I401540368
sg10
g489
sg6
g55
sg56
I1
sg18
I01
sg19
g20
sg57
g1
(g58
g41
(dp529
g60
g61
(g62
g63
g64
S'b'
tRp530
(I1
(I1
I1
tg66
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg17
g61
(g62
g63
g64
S'b'
tRp531
(I1
(I1
I1
tg66
I00
S'\xcb\xbd\x03@'
S'\x00'
Ntbsg75
g61
(g62
g63
g64
S'b'
tRp532
(I1
(I1
I1
tg66
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g67
(g63
(I0
tS'b'
tRp533
(I1
(I1
I1
tg69
I00
(lp534
g342
atbstRp535
(dp536
g80
(dp537
g60
I01
sg17
I01
sg75
I01
sg16
I00
ssg82
g525
sg83
(lp538
g60
ag75
ag16
ag17
asg85
(lp539
I1
aI1
asbsg87
g146
sg89
g67
(g63
(I0
tS'b'
tRp540
(I1
(I1
I1
tg91
I00
S'\x00\x00\x00\x00'
tbsg92
I01
sg93
I1
sg94
I-1
sg95
(lp541
Nasg111
Nsg112
g346
sg114
I1
sg115
I0
sg116
I1
sg117
I01
sbag1
(g34
g3
NtRp542
(dp543
g37
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.04 (6/28)\u000aFrom Chris\u000a- 4 blocks\u000a	- block 1: set up baseline\u000a		- view-only block: establish baseline and SD for images\u000a		- present neutral images\u000a	- block 2-4: use baseline and adapt (trial level)\u000a		- shift baseline location (mean) and size (SD) according to fixation and feedback updates\u000a        		- if trial has no changes in feedback, shift threshold size (SD) down\u000a                 - if trial has too many changes in feedback, shift threshold size up\u000a            have this version present a version with shifts and without \u000a\u000achanges: \u000aDONE added new block. 1) this block will have the same images as succeeding blocks, but not feedback presentation\u000a                      stimuli during this block will also be present for 5 seconds\u000a                      2) pupil means will be collected during this block and used as a baseline for future blocks\u000a\u000aDONE    new baseline. 1) use the parameters setup by the new baseline (SD, mean) as thresholds for blocks 2-4.\u000a                      shift thresholds using baseline mean from fixation\u000a                      have two versions of task (shift version, no-shift version) and compare\u000a    \u000aDONE         cleanup. 1) created functions for trial-level lists, booleans, and constants\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a#eyelink-standard deviation constant\u000astdev_multi = 1\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True, units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    #if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                    if ps <= (.94*lst[-1]) and ps <= (.94*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                    if (ps >= (.94*ps_n1)) and (maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *stdev_multi)\u000a        _min = _mean - (_stdev *stdev_multi)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def cue_check(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=win) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        cue_color = self.cue_display(less_,greater_,p_min,p_max)\u000a        return cue_color\u000a    \u000a    def cue_display(self,less_,greater_,p_min,p_max):\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a    \u000a    def prepare_append(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            #ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lf_min.append(blank_event)#neg stdev from baseline mean\u000a            lf_mean.append(blank_event)#baseline mean\u000a            lf_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a            lmood.append(blank_event) #stimulus valience\u000a            lstim.append(blank_event) #stimulus name\u000a        else:\u000a            #if Block 2-4\u000a            if blockNum != 1:\u000a                #timing\u000a                #tt = eyelink.t_tracker()#tracker time\u000a                pp_t = event.getTime()#psychopy time\u000a                \u000a                #creating variables for cross-validation\u000a                lblock.append(blockNum)#block\u000a                ltrial.append(trialNum)#trial\u000a                levent.append(event_type)#baseline or stimulus\u000a                lpp_t.append(pp_t)#psychopy time\u000a                cpu_pc.append(cpu_s)#cpu\u000a                ram_pc.append(ram_s)#ram\u000a                \u000a                #fixation baseline            \u000a                lf_min.append(f_min)#neg stdev from baseline mean\u000a                lf_mean.append(f_mean)#baseline mean\u000a                lf_max.append(f_max)#pos stdev from baseline mean\u000a                #adjusted baseline\u000a                lps_min.append(ps_min)#neg stdev from baseline mean\u000a                lps_mean.append(ps_mean)#baseline mean\u000a                lps_max.append(ps_max)#pos stdev from baseline mean\u000a                \u000a                lps_uadj.append(ps_o)#unadjusted pupil size\u000a                lps_d.append(maV)#pupil size velocity\u000a                lps.append(ps_n)#adjusted pupil size\u000a                lcue.append(old_cue) #cue color\u000a                lblink.append(blink_event) #debug\u000a                lmood.append(valence) #stimulus valience\u000a                lstim.append(scenestim) #stimulus name\u000a                \u000a    def prepare_constants(self, event, stim_offset, blank_offset):\u000a        blank_event='nan'#dummy value\u000a        blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a        event_type=event #stimulus event label\u000a        old_cue = 'nan' #dummy values for time before first cue presentation\u000a        p_ma = 'nan' #dummy value for moving average\u000a        ps_n1 = 0 #n-1 pupil size\u000a        st0=0 #time between samples (st1-st0)\u000a        ct0=0 #time between cues (ct1-ct0)\u000a        maV=0 #velocity\u000a        stimulus_offset = stim_offset #time (sec)\u000a        blank_offset = blank_offset #time (sec)\u000a        Total_Samples_old=0 #no. of samples\u000a        return blink_event, event_type, old_cue,\u005c\u000a        p_ma, ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a        blank_offset, Total_Samples_old,blank_event\u000a        \u000a    def prepare_bool(self,baseline_):\u000a        first_loop = True # is first pupil sample\u000a        Window = True #window to collect samples\u000a        baseline = baseline_ #end of baseline samples\u000a        blink = False #blink occuring\u000a        ma_min = False #less than 3 samples for moving average\u000a        Cue = True #present cue\u000a        Event_draw = False #marks the zero-time in a trial\u000a        return first_loop, Window, baseline, blink, ma_min,\u005c\u000a        Cue, Event_draw\u000a\u000a    def prepare_lists(self):\u000a        lblink=[] #list of blink events\u000a        levent=[] #list of event types (baseline,trial)\u000a        lf_max=[]#list of pupil baseline max\u000a        lf_min=[]#list of pupil baseline min\u000a        lf_mean=[]#list of pupil baseline mean\u000a        lps_max=[]#list of pupil baseline max\u000a        lps_min=[]#list of pupil baseline min\u000a        lps_mean=[]#list of pupil baseline mean\u000a        lps_uadj=[] #list of unadjusted pupil samples \u000a        lps=[]#list of adjusted pupil samples\u000a        lps_d=[] #change in ps\u000a        lcue=[] #list of cue colors\u000a        lpp_t=[]#time stamp of each cue onset (psychopy)\u000a        ltrial=[]#list of trials at each cue\u000a        lblock=[]#list of trials at each cue\u000a        cpu_pc=[]#list of cpu usage, by %\u000a        ram_pc=[]#list of ram usage, by %\u000a        lstim=[] #stimulus\u000a        lmood=[] #valience\u000a        return lblink, levent,\u005c\u000a        lf_max, lf_min, lf_mean,\u005c\u000a        lps_max, lps_min, lps_mean,\u005c\u000a        lps_uadj, lps, lps_d, lcue, lpp_t, ltrial, lblock,\u005c\u000a        cpu_pc, ram_pc, lstim, lmood\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event","valence","stimulus",\u000a                          "psychopy_timestamp","cpu","ram",\u000a                          "fixation_baseline_min","fixation_baseline_mean","fixation_baseline_max",\u000a                          "stimulus_baseline_min","stimulus_baseline_mean","stimulus_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","feedback","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,lmood,lstim,\u000a                                            time_,cpu_pc,ram_pc,\u000a                                            lf_min,lf_mean,lf_max,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Block %s Image %s'" %(trialNum,blockNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.005\u000a        return cu\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000alblock_ps = []\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating per block\u000a    blockNum = blockNum + 1 #block count\u000a    if blockNum == 2:\u000a        b_min,b_max,b_mean,b_stdev = eyelink.min_max(lblock_ps)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #constants\u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('baseline',None,None)\u000a            \u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min, Cue,\u005c\u000a            Event_draw = eyelink.prepare_bool(True)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lpb_uadj, lpb, lpb_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()           \u000a            \u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    #if at least 2msec between samples\u000a                    if eyelink.t_sample(st1,st0):\u000a                        #if gaze window not achived                        \u000a                        if inbox != True: \u000a                            # eyelink-gaze contingent function\u000a                            eyelink.gc_window()   \u000a                            #eyelink-pupil size\u000a                            ps_old = eyelink.pupil_sample()\u000a                        st0 = st1\u000a                        eyelink.prepare_append(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #if gc failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect fixation baseline min max mean and stdev        \u000a            f_min,f_max,f_mean,f_stdev = eyelink.min_max(lpb_uadj)\u000a            \u000a            #if blink detected\u000a            ##check if any pupil size during gc window was less than 75% of baseline mean\u000a            blink_threshold = (.75*f_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a        \u000a        #Fixation Finished------------\u000a        #if first block\u000a        if blockNum == 1:\u000a            ps_min = f_min\u000a            ps_mean = f_mean\u000a            ps_max = f_max           \u000a        else:\u000a            ps_min = f_mean - (b_stdev *stdev_multi)\u000a            ps_mean = f_mean\u000a            ps_max = f_mean + (b_stdev *stdev_multi)\u000a            print('block: mean = %s, block min = %s, max = %s'%(b_mean, b_min, b_max))\u000a            print('fixation: mean = %s, min = %s, max = %s'%(f_mean, f_min, f_max))\u000a            print('threshold: mean = %s, min = %s, max = %s'%(ps_mean, ps_min, ps_max))\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            #stimulus and ITI duration\u000a            # if block 2-4\u000a            if blockNum == 1:\u000a                stim_offset = 5\u000a                iti_offset = 7\u000a            #else if block 1\u000a            else:\u000a                stim_offset = 10\u000a                iti_offset = 12\u000a            \u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('stimulus',stim_offset,iti_offset) #stim offset, blank offset\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min,\u005c\u000a            Cue, Event_draw = eyelink.prepare_bool(False)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lps_uadj, lps, lps_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()   \u000a     \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    win.flip()\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a\u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        #if Block 1\u000a                        if blockNum == 1:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):\u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)                    \u000a                            #if time = stimulus offset\u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                break\u000a                        #if Block 2-4                        \u000a                        else:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):                      \u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)\u000a                            #present Feedback\u000a                            if IAPSClock.getTime() >= 2:\u000a                                old_cue = eyelink.cue_check(lps,20,ps_min,ps_max)\u000a                            #End Stimulus presentation\u000a                            #if time = stimulus offset                   \u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                iaps_cue.setAutoDraw(False)\u000a                                break\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a                \u000a        if trialNum <5:\u000a            #concatinate lblock_ps with trial information\u000a            lblock_ps.extend(lps)\u000a            \u000a            #print results of block\u000a            if trialNum ==1:\u000a                trial_1 = len(lblock_ps)\u000a            if trialNum ==2:\u000a                trial_2 = len(lblock_ps) - trial_1\u000a            if trialNum ==3:\u000a                trial_3 = len(lblock_ps) - (trial_1+trial_2)\u000a            if trialNum ==4:\u000a                trial_4 = len(lblock_ps) - (trial_1+trial_2+trial_3)\u000a                \u000a            if trialNum ==4:\u000a                print('total_samples = %s' %(len(lblock_ps)))\u000a                print('trial_1 = %s,%s' %(trial_1,(len(lps))))\u000a                print('trial_2 = %s,%s' %(trial_2,(len(lps))))\u000a                print('trial_3 = %s,%s' %(trial_3,(len(lps))))\u000a                print('trial_4 = %s,%s' %(trial_4,(len(lps))))\u000a            \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p544
sg39
(lp545
sg53
I401540368
sg10
g137
sg6
g55
sg56
I1
sg18
I01
sg19
g20
sg57
g1
(g58
g41
(dp546
g60
g61
(g62
g63
g64
S'b'
tRp547
(I1
(I4
I1
tg66
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg75
g61
(g62
g63
g64
S'b'
tRp548
(I1
(I4
I1
tg66
I00
S'\x00\x00\x80?\x00\x00@@\x00\x00\x00@\x00\x00\x00\x00'
S'\x00\x00\x00\x00'
NtbstRp549
(dp550
g80
(dp551
g60
I01
sg75
I01
ssg82
g542
sg83
(lp552
g60
ag75
asg85
(lp553
I4
aI1
asbsg87
g146
sg89
g67
(g63
(I0
tS'b'
tRp554
(I1
(I4
I1
tg91
I01
S'\x03\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00'
tbsg92
I01
sg93
I1
sg94
I-1
sg95
(lp555
g1
(g40
g41
(dp556
g376
g393
sg370
g390
sg372
g382
sg364
g365
sg378
g379
sg357
g387
sg367
g388
stRp557
ag1
(g40
g41
(dp558
g376
g423
sg370
g420
sg372
g412
sg364
g365
sg378
g379
sg357
g417
sg367
g418
stRp559
ag1
(g40
g41
(dp560
g376
g408
sg370
g405
sg372
g397
sg364
g365
sg378
g379
sg357
g402
sg367
g403
stRp561
ag1
(g40
g41
(dp562
g376
g377
sg370
g371
sg372
g373
sg364
g365
sg378
g379
sg357
g358
sg367
g368
stRp563
asg111
Nsg112
g415
sg114
I4
sg115
I0
sg116
I4
sg117
I01
sbag1
(g34
g3
NtRp564
(dp565
g37
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.04 (6/28)\u000aFrom Chris\u000a- 4 blocks\u000a	- block 1: set up baseline\u000a		- view-only block: establish baseline and SD for images\u000a		- present neutral images\u000a	- block 2-4: use baseline and adapt (trial level)\u000a		- shift baseline location (mean) and size (SD) according to fixation and feedback updates\u000a        		- if trial has no changes in feedback, shift threshold size (SD) down\u000a                 - if trial has too many changes in feedback, shift threshold size up\u000a            have this version present a version with shifts and without \u000a\u000achanges: \u000aDONE added new block. 1) this block will have the same images as succeeding blocks, but not feedback presentation\u000a                      stimuli during this block will also be present for 5 seconds\u000a                      2) pupil means will be collected during this block and used as a baseline for future blocks\u000a\u000aDONE    new baseline. 1) use the parameters setup by the new baseline (SD, mean) as thresholds for blocks 2-4.\u000a                      shift thresholds using baseline mean from fixation\u000a                      have two versions of task (shift version, no-shift version) and compare\u000a    \u000aDONE         cleanup. 1) created functions for trial-level lists, booleans, and constants\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a#eyelink-standard deviation constant\u000astdev_multi = 1\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True, units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    #if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                    if ps <= (.94*lst[-1]) and ps <= (.94*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                    if (ps >= (.94*ps_n1)) and (maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *stdev_multi)\u000a        _min = _mean - (_stdev *stdev_multi)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def cue_check(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=win) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        cue_color = self.cue_display(less_,greater_,p_min,p_max)\u000a        return cue_color\u000a    \u000a    def cue_display(self,less_,greater_,p_min,p_max):\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                win.flip()\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a    \u000a    def prepare_append(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            #ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lf_min.append(blank_event)#neg stdev from baseline mean\u000a            lf_mean.append(blank_event)#baseline mean\u000a            lf_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a            lmood.append(blank_event) #stimulus valience\u000a            lstim.append(blank_event) #stimulus name\u000a        else:\u000a            #if Block 2-4\u000a            if blockNum != 1:\u000a                #timing\u000a                #tt = eyelink.t_tracker()#tracker time\u000a                pp_t = event.getTime()#psychopy time\u000a                \u000a                #creating variables for cross-validation\u000a                lblock.append(blockNum)#block\u000a                ltrial.append(trialNum)#trial\u000a                levent.append(event_type)#baseline or stimulus\u000a                lpp_t.append(pp_t)#psychopy time\u000a                cpu_pc.append(cpu_s)#cpu\u000a                ram_pc.append(ram_s)#ram\u000a                \u000a                #fixation baseline            \u000a                lf_min.append(f_min)#neg stdev from baseline mean\u000a                lf_mean.append(f_mean)#baseline mean\u000a                lf_max.append(f_max)#pos stdev from baseline mean\u000a                #adjusted baseline\u000a                lps_min.append(ps_min)#neg stdev from baseline mean\u000a                lps_mean.append(ps_mean)#baseline mean\u000a                lps_max.append(ps_max)#pos stdev from baseline mean\u000a                \u000a                lps_uadj.append(ps_o)#unadjusted pupil size\u000a                lps_d.append(maV)#pupil size velocity\u000a                lps.append(ps_n)#adjusted pupil size\u000a                lcue.append(old_cue) #cue color\u000a                lblink.append(blink_event) #debug\u000a                lmood.append(valence) #stimulus valience\u000a                lstim.append(scenestim) #stimulus name\u000a                \u000a    def prepare_constants(self, event, stim_offset, blank_offset):\u000a        blank_event='nan'#dummy value\u000a        blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a        event_type=event #stimulus event label\u000a        old_cue = 'nan' #dummy values for time before first cue presentation\u000a        p_ma = 'nan' #dummy value for moving average\u000a        ps_n1 = 0 #n-1 pupil size\u000a        st0=0 #time between samples (st1-st0)\u000a        ct0=0 #time between cues (ct1-ct0)\u000a        maV=0 #velocity\u000a        stimulus_offset = stim_offset #time (sec)\u000a        blank_offset = blank_offset #time (sec)\u000a        Total_Samples_old=0 #no. of samples\u000a        return blink_event, event_type, old_cue,\u005c\u000a        p_ma, ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a        blank_offset, Total_Samples_old,blank_event\u000a        \u000a    def prepare_bool(self,baseline_):\u000a        first_loop = True # is first pupil sample\u000a        Window = True #window to collect samples\u000a        baseline = baseline_ #end of baseline samples\u000a        blink = False #blink occuring\u000a        ma_min = False #less than 3 samples for moving average\u000a        Cue = True #present cue\u000a        Event_draw = False #marks the zero-time in a trial\u000a        return first_loop, Window, baseline, blink, ma_min,\u005c\u000a        Cue, Event_draw\u000a\u000a    def prepare_lists(self):\u000a        lblink=[] #list of blink events\u000a        levent=[] #list of event types (baseline,trial)\u000a        lf_max=[]#list of pupil baseline max\u000a        lf_min=[]#list of pupil baseline min\u000a        lf_mean=[]#list of pupil baseline mean\u000a        lps_max=[]#list of pupil baseline max\u000a        lps_min=[]#list of pupil baseline min\u000a        lps_mean=[]#list of pupil baseline mean\u000a        lps_uadj=[] #list of unadjusted pupil samples \u000a        lps=[]#list of adjusted pupil samples\u000a        lps_d=[] #change in ps\u000a        lcue=[] #list of cue colors\u000a        lpp_t=[]#time stamp of each cue onset (psychopy)\u000a        ltrial=[]#list of trials at each cue\u000a        lblock=[]#list of trials at each cue\u000a        cpu_pc=[]#list of cpu usage, by %\u000a        ram_pc=[]#list of ram usage, by %\u000a        lstim=[] #stimulus\u000a        lmood=[] #valience\u000a        return lblink, levent,\u005c\u000a        lf_max, lf_min, lf_mean,\u005c\u000a        lps_max, lps_min, lps_mean,\u005c\u000a        lps_uadj, lps, lps_d, lcue, lpp_t, ltrial, lblock,\u005c\u000a        cpu_pc, ram_pc, lstim, lmood\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event","valence","stimulus",\u000a                          "psychopy_timestamp","cpu","ram",\u000a                          "fixation_baseline_min","fixation_baseline_mean","fixation_baseline_max",\u000a                          "stimulus_baseline_min","stimulus_baseline_mean","stimulus_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","feedback","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,lmood,lstim,\u000a                                            time_,cpu_pc,ram_pc,\u000a                                            lf_min,lf_mean,lf_max,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Block %s Image %s'" %(trialNum,blockNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.005\u000a        return cu\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000alblock_ps = []\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating per block\u000a    blockNum = blockNum + 1 #block count\u000a    if blockNum == 2:\u000a        b_min,b_max,b_mean,b_stdev = eyelink.min_max(lblock_ps)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #constants\u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('baseline',None,None)\u000a            \u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min, Cue,\u005c\u000a            Event_draw = eyelink.prepare_bool(True)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lpb_uadj, lpb, lpb_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()           \u000a            \u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    #if at least 2msec between samples\u000a                    if eyelink.t_sample(st1,st0):\u000a                        #if gaze window not achived                        \u000a                        if inbox != True: \u000a                            # eyelink-gaze contingent function\u000a                            eyelink.gc_window()   \u000a                            #eyelink-pupil size\u000a                            ps_old = eyelink.pupil_sample()\u000a                        st0 = st1\u000a                        eyelink.prepare_append(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #if gc failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect fixation baseline min max mean and stdev        \u000a            f_min,f_max,f_mean,f_stdev = eyelink.min_max(lpb_uadj)\u000a            \u000a            #if blink detected\u000a            ##check if any pupil size during gc window was less than 75% of baseline mean\u000a            blink_threshold = (.75*f_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a        \u000a        #Fixation Finished------------\u000a        #if first block\u000a        if blockNum == 1:\u000a            ps_min = f_min\u000a            ps_mean = f_mean\u000a            ps_max = f_max           \u000a        else:\u000a            ps_min = f_mean - (b_stdev *stdev_multi)\u000a            ps_mean = f_mean\u000a            ps_max = f_mean + (b_stdev *stdev_multi)\u000a            print('block: mean = %s, block min = %s, max = %s'%(b_mean, b_min, b_max))\u000a            print('fixation: mean = %s, min = %s, max = %s'%(f_mean, f_min, f_max))\u000a            print('threshold: mean = %s, min = %s, max = %s'%(ps_mean, ps_min, ps_max))\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            #stimulus and ITI duration\u000a            # if block 2-4\u000a            if blockNum == 1:\u000a                stim_offset = 5\u000a                iti_offset = 7\u000a            #else if block 1\u000a            else:\u000a                stim_offset = 10\u000a                iti_offset = 12\u000a            \u000a            blink_event, event_type, old_cue, p_ma,\u005c\u000a            ps_n1, st0, ct0, maV, stimulus_offset,\u005c\u000a            blank_offset, Total_Samples_old,\u005c\u000a            blank_event = eyelink.prepare_constants('stimulus',stim_offset,iti_offset) #stim offset, blank offset\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop, Window, baseline, blink, ma_min,\u005c\u000a            Cue, Event_draw = eyelink.prepare_bool(False)\u000a            \u000a            #lists\u000a            lblink, levent,\u005c\u000a            lf_max, lf_min, lf_mean,\u005c\u000a            lps_max, lps_min, lps_mean,\u005c\u000a            lps_uadj, lps, lps_d, lcue, lpp_t, ltrial,\u005c\u000a            lblock, cpu_pc, ram_pc, lstim, lmood = eyelink.prepare_lists()   \u000a     \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    win.flip()\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a\u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        #if Block 1\u000a                        if blockNum == 1:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):\u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)                    \u000a                            #if time = stimulus offset\u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                break\u000a                        #if Block 2-4                        \u000a                        else:\u000a                            #if ps_1 time - ps_n1 time > 2 msec\u000a                            if eyelink.t_sample(st1,st0):                      \u000a                                ps_new = eyelink.blink_correction(lps_uadj)\u000a                                st0 = st1\u000a                                eyelink.prepare_append(IAPSClock,ps_old,ps_new)\u000a                            #present Feedback\u000a                            if IAPSClock.getTime() >= 2:\u000a                                old_cue = eyelink.cue_check(lps,20,ps_min,ps_max)\u000a                            #End Stimulus presentation\u000a                            #if time = stimulus offset                   \u000a                            if IAPSClock.getTime() >= stimulus_offset:\u000a                                iaps_display.setAutoDraw(False)\u000a                                iaps_cue.setAutoDraw(False)\u000a                                break\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a                \u000a        if trialNum <5:\u000a            #concatinate lblock_ps with trial information\u000a            lblock_ps.extend(lps)\u000a            \u000a            #print results of block\u000a            if trialNum ==1:\u000a                trial_1 = len(lblock_ps)\u000a            if trialNum ==2:\u000a                trial_2 = len(lblock_ps) - trial_1\u000a            if trialNum ==3:\u000a                trial_3 = len(lblock_ps) - (trial_1+trial_2)\u000a            if trialNum ==4:\u000a                trial_4 = len(lblock_ps) - (trial_1+trial_2+trial_3)\u000a                \u000a            if trialNum ==4:\u000a                print('total_samples = %s' %(len(lblock_ps)))\u000a                print('trial_1 = %s,%s' %(trial_1,(len(lps))))\u000a                print('trial_2 = %s,%s' %(trial_2,(len(lps))))\u000a                print('trial_3 = %s,%s' %(trial_3,(len(lps))))\u000a                print('trial_4 = %s,%s' %(trial_4,(len(lps))))\u000a            \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p566
sg39
(lp567
sg53
I401540368
sg10
g489
sg6
g55
sg56
I1
sg18
I01
sg19
g20
sg57
g1
(g58
g41
(dp568
g60
g61
(g62
g63
g64
S'b'
tRp569
(I1
(I1
I1
tg66
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg75
g61
(g62
g63
g64
S'b'
tRp570
(I1
(I1
I1
tg66
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g67
(g63
(I0
tS'b'
tRp571
(I1
(I1
I1
tg69
I00
(lp572
NatbstRp573
(dp574
g80
(dp575
g60
I01
sg75
I01
sg16
I00
ssg82
g564
sg83
(lp576
g60
ag75
ag16
asg85
(lp577
I1
aI1
asbsg87
g146
sg89
g67
(g63
(I0
tS'b'
tRp578
(I1
(I1
I1
tg91
I00
S'\x00\x00\x00\x00'
tbsg92
I01
sg93
I1
sg94
I-1
sg95
(lp579
Nasg111
Nsg112
g433
sg114
I1
sg115
I0
sg116
I1
sg117
I01
sbag118
asS'savePickle'
p580
I00
sb.