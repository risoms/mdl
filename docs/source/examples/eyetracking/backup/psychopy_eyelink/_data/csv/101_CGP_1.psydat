ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005csr38553\u005cDesktop\u005cnew task\u005ctask\u005cdata/csv/101_CGP
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'CGP'
p11
sS'dataNames'
p12
(lp13
S'block_key.keys'
p14
aS'block_key.rt'
p15
aS'Break_key.keys'
p16
aS'Break_key.rt'
p17
asS'autoLog'
p18
I01
sS'extraInfo'
p19
(dp20
S'date'
p21
V2016_May_18_1427
p22
sS'frameRate'
p23
cnumpy.core.multiarray
scalar
p24
(cnumpy
dtype
p25
(S'f8'
I0
I1
tRp26
(I3
S'<'
NNNI-1
I-1
I0
tbS'W\x07\x9ce\x88\xfc]@'
tRp27
sS'expName'
p28
g11
sVParticipant
p29
V101
p30
ssS'loopsUnfinished'
p31
(lp32
sS'saveWideText'
p33
I01
sS'thisEntry'
p34
(dp35
sS'version'
p36
S''
sS'_paramNamesSoFar'
p37
(lp38
S'order'
p39
aS'block_display'
p40
aS'block_file'
p41
aS'break_display'
p42
aS'valmean'
p43
aS'valence'
p44
aS'scenestim'
p45
aS'arousal'
p46
aS'outliers'
p47
aS'blocknum'
p48
aS'arousalmean'
p49
asS'entries'
p50
(lp51
(dp52
S'Trial_Loop.thisTrialN'
p53
I0
sg48
g24
(g25
(S'i8'
I0
I1
tRp54
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp55
sg15
F2.0417436042199597
sS'block_loop.thisIndex'
p56
g24
(g25
(S'i4'
I0
I1
tRp57
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00'
tRp58
sg14
S'space'
p59
sg42
S'break'
p60
sg23
g27
sS'Trial_Loop.thisN'
p61
I0
sg21
g22
sS'Trial_Loop.thisIndex'
p62
g24
(g57
S'\x00\x00\x00\x00'
tRp63
sg46
S'High'
p64
sg29
g30
sS'Trial_Loop.thisRepN'
p65
I0
sg40
S'inst_2'
p66
sg49
g24
(g26
S')\\\x8f\xc2\xf5(\x12@'
tRp67
sS'block_loop.thisRepN'
p68
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp69
sg45
S'2030.bmp'
p70
sS'block_loop.thisN'
p71
I0
sg41
S'procedure\\0.csv'
p72
sS'block_loop.thisTrialN'
p73
I0
sg43
g24
(g26
S'\xd7\xa3p=\n\xd7\x1a@'
tRp74
sg28
g11
sg44
S'Positive'
p75
sg39
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp76
sa(dp77
S'Trial_Loop.thisTrialN'
p78
I1
sg40
g66
sg45
S'2655.bmp'
p79
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p80
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p81
g24
(g57
S'\x03\x00\x00\x00'
tRp82
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p83
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp84
sg49
g24
(g26
S'H\xe1z\x14\xaeG\x12@'
tRp85
sS'block_loop.thisRepN'
p86
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp87
sS'block_loop.thisIndex'
p88
g58
sS'block_loop.thisN'
p89
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x1b@'
tRp90
sg28
g11
sg44
g75
sS'block_loop.thisTrialN'
p91
I0
sa(dp92
S'Trial_Loop.thisTrialN'
p93
I2
sg40
g66
sg45
S'2205.bmp'
p94
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p95
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p96
g24
(g57
S'\x02\x00\x00\x00'
tRp97
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p98
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp99
sg49
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x12@'
tRp100
sS'block_loop.thisRepN'
p101
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp102
sS'block_loop.thisIndex'
p103
g58
sS'block_loop.thisN'
p104
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'333333\xff?'
tRp105
sg28
g11
sg44
S'Negative'
p106
sS'block_loop.thisTrialN'
p107
I0
sa(dp108
S'Trial_Loop.thisTrialN'
p109
I3
sg40
g66
sg45
S'2120.bmp'
p110
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p111
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p112
g24
(g57
S'\x01\x00\x00\x00'
tRp113
sg46
g64
sg29
g30
sS'Trial_Loop.thisRepN'
p114
I0
sg48
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp115
sg49
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x14@'
tRp116
sS'block_loop.thisRepN'
p117
I0
sg47
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp118
sS'block_loop.thisIndex'
p119
g58
sS'block_loop.thisN'
p120
I0
sg41
g72
sg39
g76
sg43
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\n@'
tRp121
sg28
g11
sg44
g106
sS'block_loop.thisTrialN'
p122
I0
sa(dp123
S'block_loop.thisRepN'
p124
I0
sg29
g30
sS'Break_loop.thisTrialN'
p125
I0
sg40
g66
sS'block_loop.thisIndex'
p126
g58
sg16
S'space'
p127
sg23
g27
sS'block_loop.thisN'
p128
I0
sg41
g72
sg39
g76
sS'Break_loop.thisRepN'
p129
I0
sg28
g11
sg42
g60
sg21
g22
sS'Break_loop.thisIndex'
p130
g24
(g57
S'\x00\x00\x00\x00'
tRp131
sS'Break_loop.thisN'
p132
I0
sg17
F5.8499261067383941
sS'Break_loop.thisTrial'
p133
NsS'block_loop.thisTrialN'
p134
I0
sa(dp135
S'block_loop.thisRepN'
p136
I0
sg29
g30
sS'block_loop.thisIndex'
p137
g58
sg23
g27
sS'block_loop.thisN'
p138
I0
sg41
g72
sS'block_loop.thisTrialN'
p139
I0
sg28
g11
sg42
g60
sg21
g22
sg39
g76
sg40
g66
sa(dp140
S'Trial_Loop.thisTrialN'
p141
I0
sS'blocknum'
p142
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp143
sg15
F5.5166555965150792
sS'block_loop.thisIndex'
p144
g24
(g57
S'\x01\x00\x00\x00'
tRp145
sg14
S'space'
p146
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p147
I0
sg21
g22
sS'Trial_Loop.thisIndex'
p148
g24
(g57
S'\x01\x00\x00\x00'
tRp149
sS'arousal'
p150
S'High'
p151
sg29
g30
sS'Trial_Loop.thisRepN'
p152
I0
sg40
S'cont_inst'
p153
sS'arousalmean'
p154
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x13@'
tRp155
sS'block_loop.thisRepN'
p156
I0
sS'outliers'
p157
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp158
sS'scenestim'
p159
S'2200.bmp'
p160
sS'block_loop.thisN'
p161
I1
sg41
S'procedure\\1.csv'
p162
sS'block_loop.thisTrialN'
p163
I1
sS'valmean'
p164
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x14@'
tRp165
sg28
g11
sS'valence'
p166
S'Neutral'
p167
sg39
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp168
sa(dp169
S'Trial_Loop.thisTrialN'
p170
I1
sg40
g153
sg159
S'2208.bmp'
p171
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p172
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p173
g24
(g57
S'\x00\x00\x00\x00'
tRp174
sg150
g151
sg29
g30
sS'Trial_Loop.thisRepN'
p175
I0
sg142
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp176
sg154
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x16@'
tRp177
sS'block_loop.thisRepN'
p178
I0
sg157
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp179
sS'block_loop.thisIndex'
p180
g145
sS'block_loop.thisN'
p181
I1
sg41
g162
sg39
g168
sg164
g24
(g26
S'ffffff\x1d@'
tRp182
sg28
g11
sg166
S'Positive'
p183
sS'block_loop.thisTrialN'
p184
I1
sa(dp185
S'Trial_Loop.thisTrialN'
p186
I2
sg40
g153
sg159
S'2550.bmp'
p187
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p188
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p189
g24
(g57
S'\x02\x00\x00\x00'
tRp190
sg150
g151
sg29
g30
sS'Trial_Loop.thisRepN'
p191
I0
sg142
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp192
sg154
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x12@'
tRp193
sS'block_loop.thisRepN'
p194
I0
sg157
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp195
sS'block_loop.thisIndex'
p196
g145
sS'block_loop.thisN'
p197
I1
sg41
g162
sg39
g168
sg164
g24
(g26
S'\x14\xaeG\xe1z\x14\x1f@'
tRp198
sg28
g11
sg166
g183
sS'block_loop.thisTrialN'
p199
I1
sa(dp200
S'Trial_Loop.thisTrialN'
p201
I3
sg40
g153
sg159
S'3180.bmp'
p202
sg42
g60
sg23
g27
sS'Trial_Loop.thisN'
p203
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p204
g24
(g57
S'\x03\x00\x00\x00'
tRp205
sg150
g151
sg29
g30
sS'Trial_Loop.thisRepN'
p206
I0
sg142
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp207
sg154
g24
(g26
S'\x14\xaeG\xe1z\x14\x17@'
tRp208
sS'block_loop.thisRepN'
p209
I0
sg157
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp210
sS'block_loop.thisIndex'
p211
g145
sS'block_loop.thisN'
p212
I1
sg41
g162
sg39
g168
sg164
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\xfe?'
tRp213
sg28
g11
sg166
S'Negative'
p214
sS'block_loop.thisTrialN'
p215
I1
sa(dp216
S'block_loop.thisRepN'
p217
I0
sg29
g30
sS'Break_loop.thisTrialN'
p218
I0
sg40
g153
sS'block_loop.thisIndex'
p219
g145
sg16
S'space'
p220
sg23
g27
sS'block_loop.thisN'
p221
I1
sg41
g162
sg39
g168
sS'Break_loop.thisRepN'
p222
I0
sg28
g11
sg42
g60
sg21
g22
sS'Break_loop.thisIndex'
p223
g24
(g57
S'\x00\x00\x00\x00'
tRp224
sS'Break_loop.thisN'
p225
I0
sg17
F3.7750830261367128
sS'Break_loop.thisTrial'
p226
NsS'block_loop.thisTrialN'
p227
I1
sa(dp228
S'block_loop.thisRepN'
p229
I0
sg29
g30
sS'block_loop.thisIndex'
p230
g145
sg23
g27
sS'block_loop.thisN'
p231
I1
sg41
g162
sS'block_loop.thisTrialN'
p232
I1
sg28
g11
sg42
g60
sg21
g22
sg39
g168
sg40
g153
sa(dp233
S'Trial_Loop.thisTrialN'
p234
I0
sS'blocknum'
p235
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp236
sg15
F1.4167870545647929
sS'block_loop.thisIndex'
p237
g24
(g57
S'\x02\x00\x00\x00'
tRp238
sg14
S'space'
p239
sg42
S'blank'
p240
sg23
g27
sS'Trial_Loop.thisN'
p241
I0
sg21
g22
sS'Trial_Loop.thisIndex'
p242
g24
(g57
S'\x02\x00\x00\x00'
tRp243
sS'arousal'
p244
S'High'
p245
sg29
g30
sS'Trial_Loop.thisRepN'
p246
I0
sg40
g153
sS'arousalmean'
p247
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x13@'
tRp248
sS'block_loop.thisRepN'
p249
I0
sS'outliers'
p250
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp251
sS'scenestim'
p252
S'2375.1.bmp'
p253
sS'block_loop.thisN'
p254
I2
sg41
S'procedure\\2.csv'
p255
sS'block_loop.thisTrialN'
p256
I2
sS'valmean'
p257
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\x01@'
tRp258
sg28
g11
sS'valence'
p259
S'Negative'
p260
sg39
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp261
sa(dp262
S'Trial_Loop.thisTrialN'
p263
I1
sg40
g153
sg252
S'2691.bmp'
p264
sg42
g240
sg23
g27
sS'Trial_Loop.thisN'
p265
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p266
g24
(g57
S'\x03\x00\x00\x00'
tRp267
sg244
g245
sg29
g30
sS'Trial_Loop.thisRepN'
p268
I0
sg235
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp269
sg247
g24
(g26
S'ffffff\x17@'
tRp270
sS'block_loop.thisRepN'
p271
I0
sg250
g24
(g54
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp272
sS'block_loop.thisIndex'
p273
g238
sS'block_loop.thisN'
p274
I2
sg41
g255
sg39
g261
sg257
g24
(g26
S'R\xb8\x1e\x85\xebQ\x08@'
tRp275
sg28
g11
sg259
g260
sS'block_loop.thisTrialN'
p276
I2
sa(dp277
S'Trial_Loop.thisTrialN'
p278
I2
sg40
g153
sg252
S'2278.bmp'
p279
sg42
g240
sg23
g27
sS'Trial_Loop.thisN'
p280
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p281
g24
(g57
S'\x01\x00\x00\x00'
tRp282
sg244
g245
sg29
g30
sS'Trial_Loop.thisRepN'
p283
I0
sg235
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp284
sg247
g24
(g26
S'333333\x12@'
tRp285
sS'block_loop.thisRepN'
p286
I0
sg250
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp287
sS'block_loop.thisIndex'
p288
g238
sS'block_loop.thisN'
p289
I2
sg41
g255
sg39
g261
sg257
g24
(g26
S'\xe1z\x14\xaeG\xe1\n@'
tRp290
sg28
g11
sg259
g260
sS'block_loop.thisTrialN'
p291
I2
sa(dp292
S'Trial_Loop.thisTrialN'
p293
I3
sg40
g153
sg252
S'2095.bmp'
p294
sg42
g240
sg23
g27
sS'Trial_Loop.thisN'
p295
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p296
g24
(g57
S'\x00\x00\x00\x00'
tRp297
sg244
g245
sg29
g30
sS'Trial_Loop.thisRepN'
p298
I0
sg235
g24
(g54
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp299
sg247
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x15@'
tRp300
sS'block_loop.thisRepN'
p301
I0
sg250
g24
(g54
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp302
sS'block_loop.thisIndex'
p303
g238
sS'block_loop.thisN'
p304
I2
sg41
g255
sg39
g261
sg257
g24
(g26
S'\xa4p=\n\xd7\xa3\xfc?'
tRp305
sg28
g11
sg259
g260
sS'block_loop.thisTrialN'
p306
I2
sa(dp307
S'block_loop.thisRepN'
p308
I0
sg29
g30
sS'Break_loop.thisTrialN'
p309
I0
sg40
g153
sS'block_loop.thisIndex'
p310
g238
sg16
Nsg23
g27
sS'block_loop.thisN'
p311
I2
sg41
g255
sS'block_loop.thisTrialN'
p312
I2
sS'Break_loop.thisRepN'
p313
I0
sg28
g11
sg42
g240
sg21
g22
sS'Break_loop.thisIndex'
p314
g24
(g57
S'\x00\x00\x00\x00'
tRp315
sS'Break_loop.thisN'
p316
I0
sS'Break_loop.thisTrial'
p317
Nsg39
g261
sa(dp318
S'block_loop.thisRepN'
p319
I0
sg29
g30
sS'block_loop.thisIndex'
p320
g238
sg23
g27
sS'block_loop.thisN'
p321
I2
sg41
g255
sS'block_loop.thisTrialN'
p322
I2
sg28
g11
sg42
g240
sg21
g22
sg39
g261
sg40
g153
sasS'loops'
p323
(lp324
g1
(cpsychopy.data
TrialHandler
p325
g3
NtRp326
(dp327
S'origin'
p328
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p329
sS'thisTrial'
p330
(lp331
sS'_exp'
p332
I392286416
sg10
S'Introduction_Loop'
p333
sg6
S'C:/Users/sr38553/Desktop/new task/task/new_task.py'
p334
sS'thisRepN'
p335
I1
sg18
I01
sg19
g20
sS'data'
p336
g1
(cpsychopy.data
DataHandler
p337
c__builtin__
dict
p338
(dp339
S'ran'
p340
cnumpy.ma.core
_mareconstruct
p341
(cnumpy.ma.core
MaskedArray
p342
cnumpy
ndarray
p343
(I0
tp344
S'b'
tRp345
(I1
(I1
I1
tg25
(S'f4'
I0
I1
tRp346
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?'
S'\x00'
NtbsS'order'
p347
g341
(g342
g343
g344
S'b'
tRp348
(I1
(I1
I1
tg346
I00
S'\x00\x00\x00\x00'
S'\x00'
NtbstRp349
(dp350
S'isNumeric'
p351
(dp352
g340
I01
sg347
I01
ssS'trials'
p353
g326
sS'dataTypes'
p354
(lp355
g340
ag347
asS'dataShape'
p356
(lp357
I1
aI1
asbsS'method'
p358
S'sequential'
p359
sS'sequenceIndices'
p360
cnumpy.core.multiarray
_reconstruct
p361
(g343
(I0
tS'b'
tRp362
(I1
(I1
I1
tg57
I00
S'\x00\x00\x00\x00'
tbsS'finished'
p363
I01
sS'nReps'
p364
I1
sS'nRemaining'
p365
I-1
sS'trialList'
p366
(lp367
g1
(cpsychopy.data
TrialType
p368
g338
(dp369
S'Introduction_image'
p370
S'inst_1'
p371
stRp372
asS'seed'
p373
NsS'thisIndex'
p374
g24
(g57
S'\x00\x00\x00\x00'
tRp375
sS'thisN'
p376
I1
sS'thisTrialN'
p377
I0
sS'nTotal'
p378
I1
sS'_warnUseOfNext'
p379
I01
sbag1
(g325
g3
NtRp380
(dp381
g328
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p382
sg330
(lp383
sg332
I392286416
sg10
S'block_loop'
p384
sg6
g334
sg335
I1
sg18
I01
sg19
g20
sg336
g1
(g337
g338
(dp385
g340
g341
(g342
g343
g344
S'b'
tRp386
(I1
(I3
I1
tg346
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00'
Ntbsg14
g361
(g343
(I0
tS'b'
tRp387
(I1
(I3
I1
tg25
(S'O4'
I0
I1
tRp388
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp389
g59
ag146
ag239
atbsg347
g341
(g342
g343
g344
S'b'
tRp390
(I1
(I3
I1
tg346
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@'
S'\x00\x00\x00'
Ntbsg15
g341
(g342
g343
g344
S'b'
tRp391
(I1
(I3
I1
tg346
I00
S'\xed\xab\x02@q\x88\xb0@GY\xb5?'
S'\x00\x00\x00'
NtbstRp392
(dp393
g351
(dp394
g340
I01
sg14
I00
sg347
I01
sg15
I01
ssg353
g380
sg354
(lp395
g340
ag347
ag14
ag15
asg356
(lp396
I3
aI1
asbsg358
g359
sg360
g361
(g343
(I0
tS'b'
tRp397
(I1
(I3
I1
tg57
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00'
tbsg363
I01
sg364
I1
sg365
I-1
sg366
(lp398
g1
(g368
g338
(dp399
g42
g60
sg39
g76
sg41
g72
sg40
g66
stRp400
ag1
(g368
g338
(dp401
g42
g60
sg39
g168
sg41
g162
sg40
g153
stRp402
ag1
(g368
g338
(dp403
g42
g240
sg39
g261
sg41
g255
sg40
g153
stRp404
asg373
Nsg374
g238
sg376
I3
sg377
I0
sg378
I3
sg379
I01
sbag1
(g325
g3
NtRp405
(dp406
g328
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p407
sg330
(lp408
sg332
I392286416
sg10
S'Trial_Loop'
p409
sg6
g334
sg335
I1
sg18
I01
sg19
g20
sg336
g1
(g337
g338
(dp410
g340
g341
(g342
g343
g344
S'b'
tRp411
(I1
(I4
I1
tg346
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg347
g341
(g342
g343
g344
S'b'
tRp412
(I1
(I4
I1
tg346
I00
S'\x00\x00\x00\x00\x00\x00@@\x00\x00\x00@\x00\x00\x80?'
S'\x00\x00\x00\x00'
NtbstRp413
(dp414
g351
(dp415
g340
I01
sg347
I01
ssg353
g405
sg354
(lp416
g340
ag347
asg356
(lp417
I4
aI1
asbsg358
S'random'
p418
sg360
g361
(g343
(I0
tS'b'
tRp419
(I1
(I4
I1
tg57
I01
S'\x00\x00\x00\x00\x03\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00'
tbsg363
I01
sg364
I1
sg365
I-1
sg366
(lp420
g1
(g368
g338
(dp421
g43
g74
sg47
g69
sg45
g70
sg46
g64
sg44
g75
sg48
g55
sg49
g67
stRp422
ag1
(g368
g338
(dp423
g43
g121
sg47
g118
sg45
g110
sg46
g64
sg44
g106
sg48
g115
sg49
g116
stRp424
ag1
(g368
g338
(dp425
g43
g105
sg47
g102
sg45
g94
sg46
g64
sg44
g106
sg48
g99
sg49
g100
stRp426
ag1
(g368
g338
(dp427
g43
g90
sg47
g87
sg45
g79
sg46
g64
sg44
g75
sg48
g84
sg49
g85
stRp428
asg373
Nsg374
g113
sg376
I4
sg377
I0
sg378
I4
sg379
I01
sbag1
(g325
g3
NtRp429
(dp430
g328
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p431
sg330
(lp432
sg332
I392286416
sg10
S'Break_loop'
p433
sg6
g334
sg335
I1
sg18
I01
sg19
g20
sg336
g1
(g337
g338
(dp434
g340
g341
(g342
g343
g344
S'b'
tRp435
(I1
(I1
I1
tg346
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg17
g341
(g342
g343
g344
S'b'
tRp436
(I1
(I1
I1
tg346
I00
S'\x982\xbb@'
S'\x00'
Ntbsg347
g341
(g342
g343
g344
S'b'
tRp437
(I1
(I1
I1
tg346
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g361
(g343
(I0
tS'b'
tRp438
(I1
(I1
I1
tg388
I00
(lp439
g127
atbstRp440
(dp441
g351
(dp442
g340
I01
sg17
I01
sg347
I01
sg16
I00
ssg353
g429
sg354
(lp443
g340
ag347
ag16
ag17
asg356
(lp444
I1
aI1
asbsg358
g418
sg360
g361
(g343
(I0
tS'b'
tRp445
(I1
(I1
I1
tg57
I00
S'\x00\x00\x00\x00'
tbsg363
I01
sg364
I1
sg365
I-1
sg366
(lp446
Nasg373
Nsg374
g131
sg376
I1
sg377
I0
sg378
I1
sg379
I01
sbag1
(g325
g3
NtRp447
(dp448
g328
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p449
sg330
(lp450
sg332
I392286416
sg10
g409
sg6
g334
sg335
I1
sg18
I01
sg19
g20
sg336
g1
(g337
g338
(dp451
g340
g341
(g342
g343
g344
S'b'
tRp452
(I1
(I4
I1
tg346
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg347
g341
(g342
g343
g344
S'b'
tRp453
(I1
(I4
I1
tg346
I00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00@\x00\x00@@'
S'\x00\x00\x00\x00'
NtbstRp454
(dp455
g351
(dp456
g340
I01
sg347
I01
ssg353
g447
sg354
(lp457
g340
ag347
asg356
(lp458
I4
aI1
asbsg358
g418
sg360
g361
(g343
(I0
tS'b'
tRp459
(I1
(I4
I1
tg57
I01
S'\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'
tbsg363
I01
sg364
I1
sg365
I-1
sg366
(lp460
g1
(g368
g338
(dp461
g164
g182
sg157
g179
sg159
g171
sg150
g151
sg166
g183
sg142
g176
sg154
g177
stRp462
ag1
(g368
g338
(dp463
g164
g165
sg157
g158
sg159
g160
sg150
g151
sg166
g167
sg142
g143
sg154
g155
stRp464
ag1
(g368
g338
(dp465
g164
g198
sg157
g195
sg159
g187
sg150
g151
sg166
g183
sg142
g192
sg154
g193
stRp466
ag1
(g368
g338
(dp467
g164
g213
sg157
g210
sg159
g202
sg150
g151
sg166
g214
sg142
g207
sg154
g208
stRp468
asg373
Nsg374
g205
sg376
I4
sg377
I0
sg378
I4
sg379
I01
sbag1
(g325
g3
NtRp469
(dp470
g328
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p471
sg330
(lp472
sg332
I392286416
sg10
g433
sg6
g334
sg335
I1
sg18
I01
sg19
g20
sg336
g1
(g337
g338
(dp473
g340
g341
(g342
g343
g344
S'b'
tRp474
(I1
(I1
I1
tg346
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg17
g341
(g342
g343
g344
S'b'
tRp475
(I1
(I1
I1
tg346
I00
S'\xf6\x9aq@'
S'\x00'
Ntbsg347
g341
(g342
g343
g344
S'b'
tRp476
(I1
(I1
I1
tg346
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g361
(g343
(I0
tS'b'
tRp477
(I1
(I1
I1
tg388
I00
(lp478
g220
atbstRp479
(dp480
g351
(dp481
g340
I01
sg17
I01
sg347
I01
sg16
I00
ssg353
g469
sg354
(lp482
g340
ag347
ag16
ag17
asg356
(lp483
I1
aI1
asbsg358
g418
sg360
g361
(g343
(I0
tS'b'
tRp484
(I1
(I1
I1
tg57
I00
S'\x00\x00\x00\x00'
tbsg363
I01
sg364
I1
sg365
I-1
sg366
(lp485
Nasg373
Nsg374
g224
sg376
I1
sg377
I0
sg378
I1
sg379
I01
sbag1
(g325
g3
NtRp486
(dp487
g328
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p488
sg330
(lp489
sg332
I392286416
sg10
g409
sg6
g334
sg335
I1
sg18
I01
sg19
g20
sg336
g1
(g337
g338
(dp490
g340
g341
(g342
g343
g344
S'b'
tRp491
(I1
(I4
I1
tg346
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg347
g341
(g342
g343
g344
S'b'
tRp492
(I1
(I4
I1
tg346
I00
S'\x00\x00@@\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00'
NtbstRp493
(dp494
g351
(dp495
g340
I01
sg347
I01
ssg353
g486
sg354
(lp496
g340
ag347
asg356
(lp497
I4
aI1
asbsg358
g418
sg360
g361
(g343
(I0
tS'b'
tRp498
(I1
(I4
I1
tg57
I01
S'\x02\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00'
tbsg363
I01
sg364
I1
sg365
I-1
sg366
(lp499
g1
(g368
g338
(dp500
g257
g305
sg250
g302
sg252
g294
sg244
g245
sg259
g260
sg235
g299
sg247
g300
stRp501
ag1
(g368
g338
(dp502
g257
g290
sg250
g287
sg252
g279
sg244
g245
sg259
g260
sg235
g284
sg247
g285
stRp503
ag1
(g368
g338
(dp504
g257
g258
sg250
g251
sg252
g253
sg244
g245
sg259
g260
sg235
g236
sg247
g248
stRp505
ag1
(g368
g338
(dp506
g257
g275
sg250
g272
sg252
g264
sg244
g245
sg259
g260
sg235
g269
sg247
g270
stRp507
asg373
Nsg374
g297
sg376
I4
sg377
I0
sg378
I4
sg379
I01
sbag1
(g325
g3
NtRp508
(dp509
g328
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a\u000a6.6.2 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.1 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a#imports for testing\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000aeye_used = None\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]        \u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a        pylink.getEYELINK().setOfflineMode()\u000a        \u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')\u000a        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')\u000a    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a    \u000a        # Set display coords for dataviewer\u000a        pylink.getEYELINK().sendMessage("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("DC_failed") #send failure message\u000a            pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a            pylink.getEYELINK().stopRecording()\u000a    \u000a        # Generate custom calibration stimuli\u000a        self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a    \u000a        if self.realconnect:        \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global Finished\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            elif eye_used == self.left_eye:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a            else:\u000a                gx,gy = (-1,-1)\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                Finished = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("GC_failed") #send failure message\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data \u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            elif eye_used == self.left_eye:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            # invalid\u000a            else:\u000a                ps = -1\u000a        return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        global trialNum\u000a        global scenestim\u000a        self.recording = False\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("record_status_message 'trial %s image %s'" %(trialNum,scenestim))\u000a        pylink.getEYELINK().sendCommand("set_idle_mode")\u000a        core.wait(.05) #delay so tracker is ready (using psychopy)\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        \u000a        # Begin recording\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)\u000a        pylink.pumpDelay(100)#100 milliseconds of data to accumulate before the trial display starts    \u000a        self.inbox = False #reset gaze congingent fixation\u000a        self.Finished = False #if gaze congingent fixation failed\u000a    \u000a    def stop_recording(self):\u000a        self.recording = False\u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        while pylink.getEYELINK().getkey():\u000a            pass  \u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.getEYELINK().closeDataFile()\u000a        time.sleep(1)\u000a        assert os.path.isdir(spath), 'EDF destination directory does not exist.'\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath)\u000a        pylink.getEYELINK().close()    \u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        lst = [x for x in lst if x != -1 and x != 0]\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean,_stdev\u000a\u000a    def pupil_cue(self,count,lst,p_min,p_max):\u000a        global p_ma\u000a        p_ma = self.moving_avg(count,lst)\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 1SD from baseline\u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "red")\u000a                im.save("red.png")\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('redimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        elif greater_:#pupil size greater than 1SD from baseline    \u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "green")\u000a                im.save("green.png")\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('greenimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a        else: #pupil size within 1SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                im = Image.new("RGB", (stim_size), "blue")\u000a                im.save("blue.png")\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                pylink.getEYELINK().sendMessage('blueimage')\u000a                pylink.getEYELINK().sendMessage('mean %s min %s max %s'%(p_ma,p_min,p_max))\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a\u000a    def moving_avg(self,count,lst):\u000a        df = pandas.DataFrame(data=lst, columns=['samples']) #convert to dataframe\u000a        rm = pandas.rolling_median(df,count)[count-1:] #moving average\u000a        ma = rm['samples'][rm.index[-1]] #gets last pupil sample\u000a        return ma\u000a        \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.2500\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.5,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# Set eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        #pupil\u000a        baseline=True\u000a        st0=0 #time between samples (st1-st0)\u000a        lpb=[] #baseline samples\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            Finished = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                #eyelink-pupil dilation baseline\u000a                if FixationClock.getTime() >= 1.75: #baseline duration 250ms, before Fixation offset\u000a                    st1 = FixationClock.getTime()\u000a                    if eyelink.sample_time(st1,st0):\u000a                        ps = eyelink.pupil_sample()\u000a                        lpb.append(ps)\u000a                    st0 = st1\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a\u000a            \u000a            #if Fixation failed              \u000a            if Finished != True:\u000a                #if DC >=2:#if drift correct failed twice run calibration\u000a                #    eyelink.calibrate()\u000a                #    DC = 0 #reset counter\u000a                #else: # drift correct\u000a                #    eyelink.gc_drift_correct()\u000a                #    DC = DC + 1 #add counter\u000a                eyelink.gc_drift_correct()\u000a                DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a            #pupil\u000a            rw=20 #running average window (appox 20 samples/200 msec)\u000a            lps0=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            lps=[] #pupil sample list\u000a            lts=[] #pupil sample time collected\u000a            old_cue = None\u000a            Window = True #window to collect samples\u000a            Cue = True\u000a    \u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            collect_ma=True\u000a            pb_min,pb_max,pb_mean,pb_stdev = eyelink.min_max(lpb) #collect baseline min max mean and stdev (debug)\u000a    \u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            stim_size = iaps_display.size[0],iaps_display.size[1]\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline = %s'%(pb_mean))\u000a            pylink.getEYELINK().sendMessage('-2SD = %s'%(pb_min))\u000a            pylink.getEYELINK().sendMessage('+2SD = %s'%(pb_max))\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage(' IAPS Onset new')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 1.800 msec                      \u000a                            ps = eyelink.pupil_sample()\u000a                            lps.append(ps)\u000a                            st0 = st1\u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            raw_lps = len(lps) - lps0 #sample size before artifact clearing for current cue\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.005 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    lps = [x for x in lps if x != -1 and x != 0] #removing missing samples (0 and -1) before moving average\u000a                    lps1 = len(lps) #sample size after artifact clearing\u000a                    COUNT = lps1-lps0\u000a                    if ((raw_lps - COUNT)/COUNT) > .5: #artifact clearing - if more than 50% difference, recollect samples\u000a                        pylink.getEYELINK().sendMessage('too few samples')\u000a                        pass\u000a                    else:\u000a                        old_cue = eyelink.pupil_cue(COUNT,lps,pb_min,pb_max)\u000a                        pylink.getEYELINK().sendMessage('color = %s'%(old_cue))\u000a                        pylink.getEYELINK().sendMessage('moving average = %s'%(p_ma))\u000a                        print('total samples = %s'%(lps1))#debug\u000a                        print('samples preceeding cue = %s'%(COUNT))#debug\u000a                        print('color = %s'%(old_cue))#debug\u000a                        print('moving average = %s'%(p_ma))#debug\u000a                        print('min = %s max = %s'%(pb_min,pb_max))#debug\u000a                        print('time = %s'%(t))#debug\u000a                        lps0 = lps1 #debug sample list\u000a                            \u000a                    \u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        #EyeLink-4 End Trial\u000a        #creating csv file for gaze info\u000a        #gaze_csv = _thisDir + os.sep + 'data/gaze/' + edfsubject + '.csv'\u000a        #with open(gaze_csv, "w") as output:\u000a        #    writer = csv.writer(output, lineterminator='\u005cn')\u000a        #    for val in gaze:\u000a        #        writer.writerow([val])  \u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #IAPS\u000a        # Send onset time\u000a        offset = int((t-iaps_display.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Onset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #IAPS\u000a        # Send offset time\u000a        offset = int((t-blank.tStart) * 1000)\u000a        msg = str(offset) + " IAPS_Offset"\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        pylink.pumpDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blocknum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + 'data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p510
sg330
(lp511
sg332
I392286416
sg10
g433
sg6
g334
sg335
I1
sg18
I01
sg19
g20
sg336
g1
(g337
g338
(dp512
g340
g341
(g342
g343
g344
S'b'
tRp513
(I1
(I1
I1
tg346
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg347
g341
(g342
g343
g344
S'b'
tRp514
(I1
(I1
I1
tg346
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g361
(g343
(I0
tS'b'
tRp515
(I1
(I1
I1
tg388
I00
(lp516
NatbstRp517
(dp518
g351
(dp519
g340
I01
sg347
I01
sg16
I00
ssg353
g508
sg354
(lp520
g340
ag347
ag16
asg356
(lp521
I1
aI1
asbsg358
g418
sg360
g361
(g343
(I0
tS'b'
tRp522
(I1
(I1
I1
tg57
I00
S'\x00\x00\x00\x00'
tbsg363
I01
sg364
I1
sg365
I-1
sg366
(lp523
Nasg373
Nsg374
g315
sg376
I1
sg377
I0
sg378
I1
sg379
I01
sbasS'savePickle'
p524
I00
sb.