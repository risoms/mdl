ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005csr38553\u005cDesktop\u005cnew task\u005ctask\u005c_data/csv/001_CGP
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'CGP'
p11
sS'dataNames'
p12
(lp13
S'block_key.keys'
p14
aS'block_key.rt'
p15
aS'Break_key.keys'
p16
aS'Break_key.rt'
p17
asS'autoLog'
p18
I01
sS'extraInfo'
p19
(dp20
S'date'
p21
V2016_Jun_10_0931
p22
sS'frameRate'
p23
cnumpy.core.multiarray
scalar
p24
(cnumpy
dtype
p25
(S'f8'
I0
I1
tRp26
(I3
S'<'
NNNI-1
I-1
I0
tbS'Jc\xfb\xf6\xd0\x00^@'
tRp27
sS'expName'
p28
g11
sVParticipant
p29
V001
p30
ssS'loopsUnfinished'
p31
(lp32
sS'saveWideText'
p33
I01
sS'thisEntry'
p34
(dp35
sS'version'
p36
S''
sS'_paramNamesSoFar'
p37
(lp38
S'block_event'
p39
aS'order'
p40
aS'block_display'
p41
aS'block_file'
p42
aS'break_display'
p43
aS'valmean'
p44
aS'valence'
p45
aS'scenestim'
p46
aS'arousal'
p47
aS'outliers'
p48
aS'blocknum'
p49
aS'arousalmean'
p50
asS'entries'
p51
(lp52
(dp53
S'Trial_Loop.thisTrialN'
p54
I0
sg29
g30
sg46
S'2205.bmp'
p55
sg39
S'comp_1'
p56
sS'Trial_Loop.thisIndex'
p57
g24
(g25
(S'i4'
I0
I1
tRp58
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x02\x00\x00\x00'
tRp59
sg23
g27
sg47
S'High'
p60
sS'Trial_Loop.thisRepN'
p61
I0
sg41
S'inst_2'
p62
sg49
g24
(g25
(S'i8'
I0
I1
tRp63
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp64
sg44
g24
(g26
S'333333\xff?'
tRp65
sg48
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp66
sg15
F0.95847779882024042
sS'block_loop.thisIndex'
p67
g24
(g58
S'\x00\x00\x00\x00'
tRp68
sg14
S'space'
p69
sS'Trial_Loop.thisN'
p70
I0
sg43
S'break'
p71
sg21
g22
sg50
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x12@'
tRp72
sS'block_loop.thisRepN'
p73
I0
sS'block_loop.thisN'
p74
I0
sg42
S'procedure\\0.csv'
p75
sS'block_loop.thisTrialN'
p76
I0
sg28
g11
sg45
S'Negative'
p77
sg40
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp78
sa(dp79
S'Trial_Loop.thisTrialN'
p80
I1
sg49
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp81
sg46
S'2655.bmp'
p82
sg39
g56
sg43
g71
sg23
g27
sS'Trial_Loop.thisN'
p83
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p84
g24
(g58
S'\x03\x00\x00\x00'
tRp85
sg47
g60
sg29
g30
sS'Trial_Loop.thisRepN'
p86
I0
sg41
g62
sg50
g24
(g26
S'H\xe1z\x14\xaeG\x12@'
tRp87
sS'block_loop.thisRepN'
p88
I0
sg48
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp89
sS'block_loop.thisIndex'
p90
g68
sS'block_loop.thisN'
p91
I0
sg42
g75
sS'block_loop.thisTrialN'
p92
I0
sg44
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x1b@'
tRp93
sg28
g11
sg45
S'Positive'
p94
sg40
g78
sa(dp95
S'Trial_Loop.thisTrialN'
p96
I2
sg49
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp97
sg46
S'2120.bmp'
p98
sg39
g56
sg43
g71
sg23
g27
sS'Trial_Loop.thisN'
p99
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p100
g24
(g58
S'\x01\x00\x00\x00'
tRp101
sg47
g60
sg29
g30
sS'Trial_Loop.thisRepN'
p102
I0
sg41
g62
sg50
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x14@'
tRp103
sS'block_loop.thisRepN'
p104
I0
sg48
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp105
sS'block_loop.thisIndex'
p106
g68
sS'block_loop.thisN'
p107
I0
sg42
g75
sS'block_loop.thisTrialN'
p108
I0
sg44
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\n@'
tRp109
sg28
g11
sg45
g77
sg40
g78
sa(dp110
S'Trial_Loop.thisTrialN'
p111
I3
sg49
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp112
sg46
S'2030.bmp'
p113
sg39
g56
sg43
g71
sg23
g27
sS'Trial_Loop.thisN'
p114
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p115
g24
(g58
S'\x00\x00\x00\x00'
tRp116
sg47
g60
sg29
g30
sS'Trial_Loop.thisRepN'
p117
I0
sg41
g62
sg50
g24
(g26
S')\\\x8f\xc2\xf5(\x12@'
tRp118
sS'block_loop.thisRepN'
p119
I0
sg48
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp120
sS'block_loop.thisIndex'
p121
g68
sS'block_loop.thisN'
p122
I0
sg42
g75
sS'block_loop.thisTrialN'
p123
I0
sg44
g24
(g26
S'\xd7\xa3p=\n\xd7\x1a@'
tRp124
sg28
g11
sg45
g94
sg40
g78
sa(dp125
S'block_loop.thisRepN'
p126
I0
sg28
g11
sS'Break_loop.thisTrialN'
p127
I0
sg41
g62
sS'block_loop.thisIndex'
p128
g68
sg16
S'space'
p129
sg39
g56
sg29
g30
sS'block_loop.thisN'
p130
I0
sg42
g75
sg40
g78
sS'Break_loop.thisRepN'
p131
I0
sg23
g27
sg43
g71
sg21
g22
sS'Break_loop.thisIndex'
p132
g24
(g58
S'\x00\x00\x00\x00'
tRp133
sS'Break_loop.thisN'
p134
I0
sg17
F1.5167123310384341
sS'Break_loop.thisTrial'
p135
NsS'block_loop.thisTrialN'
p136
I0
sa(dp137
S'block_loop.thisRepN'
p138
I0
sg23
g27
sg41
g62
sS'block_loop.thisIndex'
p139
g68
sg39
g56
sS'block_loop.thisN'
p140
I0
sg42
g75
sg40
g78
sg28
g11
sg43
g71
sg21
g22
sg29
g30
sS'block_loop.thisTrialN'
p141
I0
sa(dp142
S'Trial_Loop.thisTrialN'
p143
I0
sg29
g30
sS'scenestim'
p144
S'2278.bmp'
p145
sg39
S'comp_2'
p146
sS'Trial_Loop.thisIndex'
p147
g24
(g58
S'\x01\x00\x00\x00'
tRp148
sg23
g27
sS'arousal'
p149
S'High'
p150
sS'Trial_Loop.thisRepN'
p151
I0
sg41
S'cont_inst'
p152
sS'blocknum'
p153
g24
(g63
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp154
sS'valmean'
p155
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x14@'
tRp156
sS'outliers'
p157
g24
(g63
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp158
sg15
F0.41681860448443331
sS'block_loop.thisIndex'
p159
g24
(g58
S'\x01\x00\x00\x00'
tRp160
sg14
S'space'
p161
sS'Trial_Loop.thisN'
p162
I0
sg43
g71
sg21
g22
sS'arousalmean'
p163
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x13@'
tRp164
sS'block_loop.thisRepN'
p165
I0
sS'block_loop.thisN'
p166
I1
sg42
S'procedure\\1.csv'
p167
sS'block_loop.thisTrialN'
p168
I1
sg28
g11
sS'valence'
p169
S'Negative'
p170
sg40
g24
(g63
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp171
sa(dp172
S'Trial_Loop.thisTrialN'
p173
I1
sg153
g24
(g63
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp174
sg144
S'3180.bmp'
p175
sg39
g146
sg43
g71
sg23
g27
sS'Trial_Loop.thisN'
p176
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p177
g24
(g58
S'\x03\x00\x00\x00'
tRp178
sg149
g150
sg29
g30
sS'Trial_Loop.thisRepN'
p179
I0
sg41
g152
sg163
g24
(g26
S'\x14\xaeG\xe1z\x14\x17@'
tRp180
sS'block_loop.thisRepN'
p181
I0
sg157
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp182
sS'block_loop.thisIndex'
p183
g160
sS'block_loop.thisN'
p184
I1
sg42
g167
sS'block_loop.thisTrialN'
p185
I1
sg155
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\xfe?'
tRp186
sg28
g11
sg169
g170
sg40
g171
sa(dp187
S'Trial_Loop.thisTrialN'
p188
I2
sg153
g24
(g63
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp189
sg144
S'2550.bmp'
p190
sg39
g146
sg43
g71
sg23
g27
sS'Trial_Loop.thisN'
p191
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p192
g24
(g58
S'\x02\x00\x00\x00'
tRp193
sg149
g150
sg29
g30
sS'Trial_Loop.thisRepN'
p194
I0
sg41
g152
sg163
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x12@'
tRp195
sS'block_loop.thisRepN'
p196
I0
sg157
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp197
sS'block_loop.thisIndex'
p198
g160
sS'block_loop.thisN'
p199
I1
sg42
g167
sS'block_loop.thisTrialN'
p200
I1
sg155
g24
(g26
S'\x14\xaeG\xe1z\x14\x1f@'
tRp201
sg28
g11
sg169
S'Positive'
p202
sg40
g171
sa(dp203
S'Trial_Loop.thisTrialN'
p204
I3
sg153
g24
(g63
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp205
sg144
S'2208.bmp'
p206
sg39
g146
sg43
g71
sg23
g27
sS'Trial_Loop.thisN'
p207
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p208
g24
(g58
S'\x00\x00\x00\x00'
tRp209
sg149
g150
sg29
g30
sS'Trial_Loop.thisRepN'
p210
I0
sg41
g152
sg163
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x16@'
tRp211
sS'block_loop.thisRepN'
p212
I0
sg157
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp213
sS'block_loop.thisIndex'
p214
g160
sS'block_loop.thisN'
p215
I1
sg42
g167
sS'block_loop.thisTrialN'
p216
I1
sg155
g24
(g26
S'ffffff\x1d@'
tRp217
sg28
g11
sg169
g202
sg40
g171
sa(dp218
S'block_loop.thisRepN'
p219
I0
sg28
g11
sS'Break_loop.thisTrialN'
p220
I0
sg41
g152
sS'block_loop.thisIndex'
p221
g160
sg16
S'space'
p222
sg39
g146
sg29
g30
sS'block_loop.thisN'
p223
I1
sg42
g167
sg40
g171
sS'Break_loop.thisRepN'
p224
I0
sg23
g27
sg43
g71
sg21
g22
sS'Break_loop.thisIndex'
p225
g24
(g58
S'\x00\x00\x00\x00'
tRp226
sS'Break_loop.thisN'
p227
I0
sg17
F36.640724320022855
sS'Break_loop.thisTrial'
p228
NsS'block_loop.thisTrialN'
p229
I1
sa(dp230
S'block_loop.thisRepN'
p231
I0
sg23
g27
sg41
g152
sS'block_loop.thisIndex'
p232
g160
sg39
g146
sS'block_loop.thisN'
p233
I1
sg42
g167
sg40
g171
sg28
g11
sg43
g71
sg21
g22
sg29
g30
sS'block_loop.thisTrialN'
p234
I1
sa(dp235
S'Trial_Loop.thisTrialN'
p236
I0
sg29
g30
sS'scenestim'
p237
S'2095.bmp'
p238
sg39
S'comp_3'
p239
sS'Trial_Loop.thisIndex'
p240
g24
(g58
S'\x00\x00\x00\x00'
tRp241
sg23
g27
sS'arousal'
p242
S'High'
p243
sS'Trial_Loop.thisRepN'
p244
I0
sg41
g152
sS'blocknum'
p245
g24
(g63
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp246
sS'valmean'
p247
g24
(g26
S'\xa4p=\n\xd7\xa3\xfc?'
tRp248
sS'outliers'
p249
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp250
sg15
F1.3251333953230642
sS'block_loop.thisIndex'
p251
g24
(g58
S'\x02\x00\x00\x00'
tRp252
sg14
S'space'
p253
sS'Trial_Loop.thisN'
p254
I0
sg43
S'blank'
p255
sg21
g22
sS'arousalmean'
p256
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x15@'
tRp257
sS'block_loop.thisRepN'
p258
I0
sS'block_loop.thisN'
p259
I2
sg42
S'procedure\\2.csv'
p260
sS'block_loop.thisTrialN'
p261
I2
sg28
g11
sS'valence'
p262
S'Negative'
p263
sg40
g24
(g63
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp264
sa(dp265
S'Trial_Loop.thisTrialN'
p266
I1
sg245
g24
(g63
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp267
sg237
S'2691.bmp'
p268
sg39
g239
sg43
g255
sg23
g27
sS'Trial_Loop.thisN'
p269
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p270
g24
(g58
S'\x03\x00\x00\x00'
tRp271
sg242
g243
sg29
g30
sS'Trial_Loop.thisRepN'
p272
I0
sg41
g152
sg256
g24
(g26
S'ffffff\x17@'
tRp273
sS'block_loop.thisRepN'
p274
I0
sg249
g24
(g63
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp275
sS'block_loop.thisIndex'
p276
g252
sS'block_loop.thisN'
p277
I2
sg42
g260
sS'block_loop.thisTrialN'
p278
I2
sg247
g24
(g26
S'R\xb8\x1e\x85\xebQ\x08@'
tRp279
sg28
g11
sg262
g263
sg40
g264
sa(dp280
S'Trial_Loop.thisTrialN'
p281
I2
sg245
g24
(g63
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp282
sg237
S'2375.1.bmp'
p283
sg39
g239
sg43
g255
sg23
g27
sS'Trial_Loop.thisN'
p284
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p285
g24
(g58
S'\x02\x00\x00\x00'
tRp286
sg242
g243
sg29
g30
sS'Trial_Loop.thisRepN'
p287
I0
sg41
g152
sg256
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x13@'
tRp288
sS'block_loop.thisRepN'
p289
I0
sg249
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp290
sS'block_loop.thisIndex'
p291
g252
sS'block_loop.thisN'
p292
I2
sg42
g260
sS'block_loop.thisTrialN'
p293
I2
sg247
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\x01@'
tRp294
sg28
g11
sg262
g263
sg40
g264
sa(dp295
S'Trial_Loop.thisTrialN'
p296
I3
sg245
g24
(g63
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp297
sg237
S'2278.bmp'
p298
sg39
g239
sg43
g255
sg23
g27
sS'Trial_Loop.thisN'
p299
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p300
g24
(g58
S'\x01\x00\x00\x00'
tRp301
sg242
g243
sg29
g30
sS'Trial_Loop.thisRepN'
p302
I0
sg41
g152
sg256
g24
(g26
S'333333\x12@'
tRp303
sS'block_loop.thisRepN'
p304
I0
sg249
g24
(g63
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp305
sS'block_loop.thisIndex'
p306
g252
sS'block_loop.thisN'
p307
I2
sg42
g260
sS'block_loop.thisTrialN'
p308
I2
sg247
g24
(g26
S'\xe1z\x14\xaeG\xe1\n@'
tRp309
sg28
g11
sg262
g263
sg40
g264
sa(dp310
S'block_loop.thisRepN'
p311
I0
sg28
g11
sS'Break_loop.thisTrialN'
p312
I0
sg41
g152
sS'block_loop.thisIndex'
p313
g252
sg16
Nsg39
g239
sg29
g30
sS'block_loop.thisN'
p314
I2
sg42
g260
sg40
g264
sS'Break_loop.thisRepN'
p315
I0
sg23
g27
sg43
g255
sg21
g22
sS'Break_loop.thisIndex'
p316
g24
(g58
S'\x00\x00\x00\x00'
tRp317
sS'Break_loop.thisN'
p318
I0
sS'Break_loop.thisTrial'
p319
NsS'block_loop.thisTrialN'
p320
I2
sa(dp321
S'block_loop.thisRepN'
p322
I0
sg23
g27
sg41
g152
sS'block_loop.thisIndex'
p323
g252
sg39
g239
sS'block_loop.thisN'
p324
I2
sg42
g260
sg40
g264
sg28
g11
sg43
g255
sg21
g22
sg29
g30
sS'block_loop.thisTrialN'
p325
I2
sasS'loops'
p326
(lp327
g1
(cpsychopy.data
TrialHandler
p328
g3
NtRp329
(dp330
S'origin'
p331
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a\u000achanged\u000a- clean up of obsolete variables\u000a\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#imports for cross-validation\u000aimport csv\u000aimport itertools\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aeye_used = None\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def pupil_sample_new(self):\u000a        global first_loop\u000a        global ps_n2 #n-2 pupil sample\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_d #derivative of pupil area\u000a        global ps_old #ps without changes \u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a                ps_old = ps\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a                ps_old = ps            \u000a\u000a            #if not first sample\u000a            if first_loop != True:\u000a                #calculating derivative of pupil area \u000a                ps_d = (ps - ps_n2)/(2*500)\u000a                self.moving_avg(lps)#moving average\u000a                if ps_d < -0.01 * ma or ps_d > 0.01 * ma or ps == 0:\u000a                    ps = ps_n1\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a                else:\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a            else: #collect first sample \u000a                first_loop = False\u000a                ps_n2 = ps_n1\u000a                ps_n1 = ps \u000a                return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        if baseline:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Block A%s Image %s.png'" %(blockNum,block_event)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID A%s'%(blockNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 512, self.h/2 - 384, self.w/2 + 512, self.h/2 + 384,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1) #Begin recording - (0,0,1,0): sends samples through link   \u000a        else:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a    \u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean\u000a\u000a    def pupil_cue(self,p_ma,p_min,p_max):\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 2SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than 2SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        else: #pupil size within 2SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def moving_avg(self,lst):\u000a        global ma\u000a        rm = pandas.DataFrame(lst, columns=['samples']).rolling(3,center=False).mean() #moving average\u000a        ma = rm['samples'][rm.index[-1]] #last pupil sample\u000a        return ma\u000a   \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Block_event"\u000aBlock_eventClock = core.Clock()\u000acomposite_display = visual.ImageStim(win=win, name='composite_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Block_event"-------\u000a    t = 0\u000a    Block_eventClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(5.000000)\u000a    # update component parameters for each repeat\u000a    blockNum = blockNum + 1 #trial count\u000a\u000a    #pupil\u000a    lps=[] #adjusted samples\u000a    ps_n1 = 0 #n-1 pupil sample\u000a    ps_n2 = 0 #n-2 pupil sample\u000a    st0=0 #time between samples (st1-st0)\u000a    Window = True #window to collect samples\u000a    first_loop = True\u000a    baseline = True #preparing start recording\u000a    \u000a    #eyelink\u000a    eye_used = eyelink.set_eye_used() #Set eye used\u000a    eyelink.start_recording() #start recording\u000a    \u000a    composite_display.setImage("instructions/"+block_event+".png")\u000a    image_size = composite_display.size[0],composite_display.size[1]\u000a    \u000a    #-------Start Routine "Block_event"-------       \u000a    #Block_event updates\u000a    composite_display.setAutoDraw(True)\u000a    win.flip()\u000a    \u000a    # update/draw components on each frame\u000a    #eyelink-pupil dilation baseline\u000a    while Window:\u000a        st1 = Block_eventClock.getTime()\u000a        if Block_eventClock.getTime() >= 0:\u000a            if Block_eventClock.getTime() >= 5:\u000a                composite_display.setAutoDraw(False)\u000a                break\u000a            else:\u000a                if eyelink.sample_time(st1,st0):\u000a                    ps_baseline = eyelink.pupil_sample_new()\u000a                    lps.append(ps_baseline)#adjusted pupil size\u000a                    st0 = st1      \u000a    \u000a    #-------Ending Routine "Block_event"-------\u000a    #eyelink-stop baseline recording  \u000a    eyelink.stop_recording()\u000a    composite_display.setAutoDraw(False)    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        Event_draw = False #marks the zero-time in a trial\u000a        baseline = False #preparing start recording\u000a        \u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a            \u000a            #if Fixation failed              \u000a            #if GAZE != True:\u000a            #    if DC >=2:#if drift correct failed twice run calibration\u000a            #        eyelink.calibrate()\u000a            #        DC = 0 #reset counter\u000a            #    else: # drift correct\u000a            #        eyelink.gc_drift_correct()\u000a            #        DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #debug for cross-validation\u000a            #loops\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            \u000a            #baseline pupil size\u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lps) #collect baseline min max mean and stdev (debug)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a\u000a            #trial pupil size            \u000a            Cue = True\u000a            old_cue = None\u000a            lps_old=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples \u000a            lps_d=[] #change in ps\u000a            ps_d = "nan" #providing dummy value for derivative\u000a            p_ma = "nan" #providing dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            ps_n2 = 0 #n-2 pupil size\u000a            \u000a            #computer performance\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a            \u000a            #time info\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.pupil_sample_new()\u000a                            st0 = st1\u000a                            \u000a                            #start debug #sample level\u000a                            #timing\u000a                            tt = eyelink.tracker_time()#tracker time\u000a                            pp_t = IAPSClock.getTime()#psychopy time\u000a                            \u000a                            #creating variables for cross-validation\u000a                            lblock.append(blockNum)#block\u000a                            ltrial.append(trialNum)#trial\u000a                            ltt.append(tt)#tracker time\u000a                            lpp_t.append(pp_t) #psychopy time\u000a                            cpu_pc.append(cpu_s)#cpu\u000a                            ram_pc.append(ram_s)#ram\u000a                            lps_min.append(ps_min)#neg stdev from baseline mean\u000a                            lps_mean.append(ps_mean)#baseline mean\u000a                            lps_max.append(ps_max)#pos stdev from baseline mean\u000a                            lps_old.append(ps_old)#unadjusted pupil size\u000a                            lps_d.append(ps_d)#pupil size velocity\u000a                            lps.append(ps_new)#adjusted pupil size\u000a                            #end debug\u000a                            \u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.250 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(ma,ps_min,ps_max)\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a\u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a\u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file for following:\u000a        #timestamp #pupil size #pupil running average #trial\u000a        #outputting set_list procedure\u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,\u000a                                            ltt,lpp_t,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            lps_old,lps_d,lps))\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p332
sS'thisTrial'
p333
(lp334
sS'_exp'
p335
I392424912
sg10
S'Introduction_Loop'
p336
sg6
S'C:/Users/sr38553/Desktop/new task/task/6.7.02.py'
p337
sS'thisRepN'
p338
I1
sg18
I01
sg19
g20
sS'data'
p339
g1
(cpsychopy.data
DataHandler
p340
c__builtin__
dict
p341
(dp342
S'ran'
p343
cnumpy.ma.core
_mareconstruct
p344
(cnumpy.ma.core
MaskedArray
p345
cnumpy
ndarray
p346
(I0
tp347
S'b'
tRp348
(I1
(I1
I1
tg25
(S'f4'
I0
I1
tRp349
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?'
S'\x00'
NtbsS'order'
p350
g344
(g345
g346
g347
S'b'
tRp351
(I1
(I1
I1
tg349
I00
S'\x00\x00\x00\x00'
S'\x00'
NtbstRp352
(dp353
S'isNumeric'
p354
(dp355
g343
I01
sg350
I01
ssS'trials'
p356
g329
sS'dataTypes'
p357
(lp358
g343
ag350
asS'dataShape'
p359
(lp360
I1
aI1
asbsS'method'
p361
S'sequential'
p362
sS'sequenceIndices'
p363
cnumpy.core.multiarray
_reconstruct
p364
(g346
(I0
tS'b'
tRp365
(I1
(I1
I1
tg58
I00
S'\x00\x00\x00\x00'
tbsS'finished'
p366
I01
sS'nReps'
p367
I1
sS'nRemaining'
p368
I-1
sS'trialList'
p369
(lp370
g1
(cpsychopy.data
TrialType
p371
g341
(dp372
S'Introduction_image'
p373
S'inst_1'
p374
stRp375
asS'seed'
p376
NsS'thisIndex'
p377
g24
(g58
S'\x00\x00\x00\x00'
tRp378
sS'thisN'
p379
I1
sS'thisTrialN'
p380
I0
sS'nTotal'
p381
I1
sS'_warnUseOfNext'
p382
I01
sbag1
(g328
g3
NtRp383
(dp384
g331
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a\u000achanged\u000a- clean up of obsolete variables\u000a\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#imports for cross-validation\u000aimport csv\u000aimport itertools\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aeye_used = None\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def pupil_sample_new(self):\u000a        global first_loop\u000a        global ps_n2 #n-2 pupil sample\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_d #derivative of pupil area\u000a        global ps_old #ps without changes \u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a                ps_old = ps\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a                ps_old = ps            \u000a\u000a            #if not first sample\u000a            if first_loop != True:\u000a                #calculating derivative of pupil area \u000a                ps_d = (ps - ps_n2)/(2*500)\u000a                self.moving_avg(lps)#moving average\u000a                if ps_d < -0.01 * ma or ps_d > 0.01 * ma or ps == 0:\u000a                    ps = ps_n1\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a                else:\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a            else: #collect first sample \u000a                first_loop = False\u000a                ps_n2 = ps_n1\u000a                ps_n1 = ps \u000a                return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        if baseline:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Block A%s Image %s.png'" %(blockNum,block_event)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID A%s'%(blockNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 512, self.h/2 - 384, self.w/2 + 512, self.h/2 + 384,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1) #Begin recording - (0,0,1,0): sends samples through link   \u000a        else:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a    \u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean\u000a\u000a    def pupil_cue(self,p_ma,p_min,p_max):\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 2SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than 2SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        else: #pupil size within 2SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def moving_avg(self,lst):\u000a        global ma\u000a        rm = pandas.DataFrame(lst, columns=['samples']).rolling(3,center=False).mean() #moving average\u000a        ma = rm['samples'][rm.index[-1]] #last pupil sample\u000a        return ma\u000a   \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Block_event"\u000aBlock_eventClock = core.Clock()\u000acomposite_display = visual.ImageStim(win=win, name='composite_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Block_event"-------\u000a    t = 0\u000a    Block_eventClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(5.000000)\u000a    # update component parameters for each repeat\u000a    blockNum = blockNum + 1 #trial count\u000a\u000a    #pupil\u000a    lps=[] #adjusted samples\u000a    ps_n1 = 0 #n-1 pupil sample\u000a    ps_n2 = 0 #n-2 pupil sample\u000a    st0=0 #time between samples (st1-st0)\u000a    Window = True #window to collect samples\u000a    first_loop = True\u000a    baseline = True #preparing start recording\u000a    \u000a    #eyelink\u000a    eye_used = eyelink.set_eye_used() #Set eye used\u000a    eyelink.start_recording() #start recording\u000a    \u000a    composite_display.setImage("instructions/"+block_event+".png")\u000a    image_size = composite_display.size[0],composite_display.size[1]\u000a    \u000a    #-------Start Routine "Block_event"-------       \u000a    #Block_event updates\u000a    composite_display.setAutoDraw(True)\u000a    win.flip()\u000a    \u000a    # update/draw components on each frame\u000a    #eyelink-pupil dilation baseline\u000a    while Window:\u000a        st1 = Block_eventClock.getTime()\u000a        if Block_eventClock.getTime() >= 0:\u000a            if Block_eventClock.getTime() >= 5:\u000a                composite_display.setAutoDraw(False)\u000a                break\u000a            else:\u000a                if eyelink.sample_time(st1,st0):\u000a                    ps_baseline = eyelink.pupil_sample_new()\u000a                    lps.append(ps_baseline)#adjusted pupil size\u000a                    st0 = st1      \u000a    \u000a    #-------Ending Routine "Block_event"-------\u000a    #eyelink-stop baseline recording  \u000a    eyelink.stop_recording()\u000a    composite_display.setAutoDraw(False)    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        Event_draw = False #marks the zero-time in a trial\u000a        baseline = False #preparing start recording\u000a        \u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a            \u000a            #if Fixation failed              \u000a            #if GAZE != True:\u000a            #    if DC >=2:#if drift correct failed twice run calibration\u000a            #        eyelink.calibrate()\u000a            #        DC = 0 #reset counter\u000a            #    else: # drift correct\u000a            #        eyelink.gc_drift_correct()\u000a            #        DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #debug for cross-validation\u000a            #loops\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            \u000a            #baseline pupil size\u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lps) #collect baseline min max mean and stdev (debug)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a\u000a            #trial pupil size            \u000a            Cue = True\u000a            old_cue = None\u000a            lps_old=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples \u000a            lps_d=[] #change in ps\u000a            ps_d = "nan" #providing dummy value for derivative\u000a            p_ma = "nan" #providing dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            ps_n2 = 0 #n-2 pupil size\u000a            \u000a            #computer performance\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a            \u000a            #time info\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.pupil_sample_new()\u000a                            st0 = st1\u000a                            \u000a                            #start debug #sample level\u000a                            #timing\u000a                            tt = eyelink.tracker_time()#tracker time\u000a                            pp_t = IAPSClock.getTime()#psychopy time\u000a                            \u000a                            #creating variables for cross-validation\u000a                            lblock.append(blockNum)#block\u000a                            ltrial.append(trialNum)#trial\u000a                            ltt.append(tt)#tracker time\u000a                            lpp_t.append(pp_t) #psychopy time\u000a                            cpu_pc.append(cpu_s)#cpu\u000a                            ram_pc.append(ram_s)#ram\u000a                            lps_min.append(ps_min)#neg stdev from baseline mean\u000a                            lps_mean.append(ps_mean)#baseline mean\u000a                            lps_max.append(ps_max)#pos stdev from baseline mean\u000a                            lps_old.append(ps_old)#unadjusted pupil size\u000a                            lps_d.append(ps_d)#pupil size velocity\u000a                            lps.append(ps_new)#adjusted pupil size\u000a                            #end debug\u000a                            \u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.250 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(ma,ps_min,ps_max)\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a\u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a\u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file for following:\u000a        #timestamp #pupil size #pupil running average #trial\u000a        #outputting set_list procedure\u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,\u000a                                            ltt,lpp_t,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            lps_old,lps_d,lps))\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p385
sg333
(lp386
sg335
I392424912
sg10
S'block_loop'
p387
sg6
g337
sg338
I1
sg18
I01
sg19
g20
sg339
g1
(g340
g341
(dp388
g343
g344
(g345
g346
g347
S'b'
tRp389
(I1
(I3
I1
tg349
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00'
Ntbsg14
g364
(g346
(I0
tS'b'
tRp390
(I1
(I3
I1
tg25
(S'O4'
I0
I1
tRp391
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp392
g69
ag161
ag253
atbsg350
g344
(g345
g346
g347
S'b'
tRp393
(I1
(I3
I1
tg349
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@'
S'\x00\x00\x00'
Ntbsg15
g344
(g345
g346
g347
S'b'
tRp394
(I1
(I3
I1
tg349
I00
S'\xcd^u?@i\xd5>\xf9\x9d\xa9?'
S'\x00\x00\x00'
NtbstRp395
(dp396
g354
(dp397
g343
I01
sg14
I00
sg350
I01
sg15
I01
ssg356
g383
sg357
(lp398
g343
ag350
ag14
ag15
asg359
(lp399
I3
aI1
asbsg361
g362
sg363
g364
(g346
(I0
tS'b'
tRp400
(I1
(I3
I1
tg58
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00'
tbsg366
I01
sg367
I1
sg368
I-1
sg369
(lp401
g1
(g371
g341
(dp402
g39
g56
sg43
g71
sg40
g78
sg42
g75
sg41
g62
stRp403
ag1
(g371
g341
(dp404
g39
g146
sg43
g71
sg40
g171
sg42
g167
sg41
g152
stRp405
ag1
(g371
g341
(dp406
g39
g239
sg43
g255
sg40
g264
sg42
g260
sg41
g152
stRp407
asg376
Nsg377
g252
sg379
I3
sg380
I0
sg381
I3
sg382
I01
sbag1
(g328
g3
NtRp408
(dp409
g331
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a\u000achanged\u000a- clean up of obsolete variables\u000a\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#imports for cross-validation\u000aimport csv\u000aimport itertools\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aeye_used = None\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def pupil_sample_new(self):\u000a        global first_loop\u000a        global ps_n2 #n-2 pupil sample\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_d #derivative of pupil area\u000a        global ps_old #ps without changes \u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a                ps_old = ps\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a                ps_old = ps            \u000a\u000a            #if not first sample\u000a            if first_loop != True:\u000a                #calculating derivative of pupil area \u000a                ps_d = (ps - ps_n2)/(2*500)\u000a                self.moving_avg(lps)#moving average\u000a                if ps_d < -0.01 * ma or ps_d > 0.01 * ma or ps == 0:\u000a                    ps = ps_n1\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a                else:\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a            else: #collect first sample \u000a                first_loop = False\u000a                ps_n2 = ps_n1\u000a                ps_n1 = ps \u000a                return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        if baseline:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Block A%s Image %s.png'" %(blockNum,block_event)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID A%s'%(blockNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 512, self.h/2 - 384, self.w/2 + 512, self.h/2 + 384,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1) #Begin recording - (0,0,1,0): sends samples through link   \u000a        else:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a    \u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean\u000a\u000a    def pupil_cue(self,p_ma,p_min,p_max):\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 2SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than 2SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        else: #pupil size within 2SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def moving_avg(self,lst):\u000a        global ma\u000a        rm = pandas.DataFrame(lst, columns=['samples']).rolling(3,center=False).mean() #moving average\u000a        ma = rm['samples'][rm.index[-1]] #last pupil sample\u000a        return ma\u000a   \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Block_event"\u000aBlock_eventClock = core.Clock()\u000acomposite_display = visual.ImageStim(win=win, name='composite_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Block_event"-------\u000a    t = 0\u000a    Block_eventClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(5.000000)\u000a    # update component parameters for each repeat\u000a    blockNum = blockNum + 1 #trial count\u000a\u000a    #pupil\u000a    lps=[] #adjusted samples\u000a    ps_n1 = 0 #n-1 pupil sample\u000a    ps_n2 = 0 #n-2 pupil sample\u000a    st0=0 #time between samples (st1-st0)\u000a    Window = True #window to collect samples\u000a    first_loop = True\u000a    baseline = True #preparing start recording\u000a    \u000a    #eyelink\u000a    eye_used = eyelink.set_eye_used() #Set eye used\u000a    eyelink.start_recording() #start recording\u000a    \u000a    composite_display.setImage("instructions/"+block_event+".png")\u000a    image_size = composite_display.size[0],composite_display.size[1]\u000a    \u000a    #-------Start Routine "Block_event"-------       \u000a    #Block_event updates\u000a    composite_display.setAutoDraw(True)\u000a    win.flip()\u000a    \u000a    # update/draw components on each frame\u000a    #eyelink-pupil dilation baseline\u000a    while Window:\u000a        st1 = Block_eventClock.getTime()\u000a        if Block_eventClock.getTime() >= 0:\u000a            if Block_eventClock.getTime() >= 5:\u000a                composite_display.setAutoDraw(False)\u000a                break\u000a            else:\u000a                if eyelink.sample_time(st1,st0):\u000a                    ps_baseline = eyelink.pupil_sample_new()\u000a                    lps.append(ps_baseline)#adjusted pupil size\u000a                    st0 = st1      \u000a    \u000a    #-------Ending Routine "Block_event"-------\u000a    #eyelink-stop baseline recording  \u000a    eyelink.stop_recording()\u000a    composite_display.setAutoDraw(False)    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        Event_draw = False #marks the zero-time in a trial\u000a        baseline = False #preparing start recording\u000a        \u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a            \u000a            #if Fixation failed              \u000a            #if GAZE != True:\u000a            #    if DC >=2:#if drift correct failed twice run calibration\u000a            #        eyelink.calibrate()\u000a            #        DC = 0 #reset counter\u000a            #    else: # drift correct\u000a            #        eyelink.gc_drift_correct()\u000a            #        DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #debug for cross-validation\u000a            #loops\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            \u000a            #baseline pupil size\u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lps) #collect baseline min max mean and stdev (debug)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a\u000a            #trial pupil size            \u000a            Cue = True\u000a            old_cue = None\u000a            lps_old=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples \u000a            lps_d=[] #change in ps\u000a            ps_d = "nan" #providing dummy value for derivative\u000a            p_ma = "nan" #providing dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            ps_n2 = 0 #n-2 pupil size\u000a            \u000a            #computer performance\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a            \u000a            #time info\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.pupil_sample_new()\u000a                            st0 = st1\u000a                            \u000a                            #start debug #sample level\u000a                            #timing\u000a                            tt = eyelink.tracker_time()#tracker time\u000a                            pp_t = IAPSClock.getTime()#psychopy time\u000a                            \u000a                            #creating variables for cross-validation\u000a                            lblock.append(blockNum)#block\u000a                            ltrial.append(trialNum)#trial\u000a                            ltt.append(tt)#tracker time\u000a                            lpp_t.append(pp_t) #psychopy time\u000a                            cpu_pc.append(cpu_s)#cpu\u000a                            ram_pc.append(ram_s)#ram\u000a                            lps_min.append(ps_min)#neg stdev from baseline mean\u000a                            lps_mean.append(ps_mean)#baseline mean\u000a                            lps_max.append(ps_max)#pos stdev from baseline mean\u000a                            lps_old.append(ps_old)#unadjusted pupil size\u000a                            lps_d.append(ps_d)#pupil size velocity\u000a                            lps.append(ps_new)#adjusted pupil size\u000a                            #end debug\u000a                            \u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.250 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(ma,ps_min,ps_max)\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a\u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a\u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file for following:\u000a        #timestamp #pupil size #pupil running average #trial\u000a        #outputting set_list procedure\u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,\u000a                                            ltt,lpp_t,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            lps_old,lps_d,lps))\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p410
sg333
(lp411
sg335
I392424912
sg10
S'Trial_Loop'
p412
sg6
g337
sg338
I1
sg18
I01
sg19
g20
sg339
g1
(g340
g341
(dp413
g343
g344
(g345
g346
g347
S'b'
tRp414
(I1
(I4
I1
tg349
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg350
g344
(g345
g346
g347
S'b'
tRp415
(I1
(I4
I1
tg349
I00
S'\x00\x00@@\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00'
NtbstRp416
(dp417
g354
(dp418
g343
I01
sg350
I01
ssg356
g408
sg357
(lp419
g343
ag350
asg359
(lp420
I4
aI1
asbsg361
S'random'
p421
sg363
g364
(g346
(I0
tS'b'
tRp422
(I1
(I4
I1
tg58
I01
S'\x02\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00'
tbsg366
I01
sg367
I1
sg368
I-1
sg369
(lp423
g1
(g371
g341
(dp424
g44
g124
sg48
g120
sg46
g113
sg47
g60
sg45
g94
sg49
g112
sg50
g118
stRp425
ag1
(g371
g341
(dp426
g44
g109
sg48
g105
sg46
g98
sg47
g60
sg45
g77
sg49
g97
sg50
g103
stRp427
ag1
(g371
g341
(dp428
g44
g65
sg48
g66
sg46
g55
sg47
g60
sg45
g77
sg49
g64
sg50
g72
stRp429
ag1
(g371
g341
(dp430
g44
g93
sg48
g89
sg46
g82
sg47
g60
sg45
g94
sg49
g81
sg50
g87
stRp431
asg376
Nsg377
g116
sg379
I4
sg380
I0
sg381
I4
sg382
I01
sbag1
(g328
g3
NtRp432
(dp433
g331
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a\u000achanged\u000a- clean up of obsolete variables\u000a\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#imports for cross-validation\u000aimport csv\u000aimport itertools\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aeye_used = None\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def pupil_sample_new(self):\u000a        global first_loop\u000a        global ps_n2 #n-2 pupil sample\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_d #derivative of pupil area\u000a        global ps_old #ps without changes \u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a                ps_old = ps\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a                ps_old = ps            \u000a\u000a            #if not first sample\u000a            if first_loop != True:\u000a                #calculating derivative of pupil area \u000a                ps_d = (ps - ps_n2)/(2*500)\u000a                self.moving_avg(lps)#moving average\u000a                if ps_d < -0.01 * ma or ps_d > 0.01 * ma or ps == 0:\u000a                    ps = ps_n1\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a                else:\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a            else: #collect first sample \u000a                first_loop = False\u000a                ps_n2 = ps_n1\u000a                ps_n1 = ps \u000a                return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        if baseline:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Block A%s Image %s.png'" %(blockNum,block_event)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID A%s'%(blockNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 512, self.h/2 - 384, self.w/2 + 512, self.h/2 + 384,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1) #Begin recording - (0,0,1,0): sends samples through link   \u000a        else:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a    \u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean\u000a\u000a    def pupil_cue(self,p_ma,p_min,p_max):\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 2SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than 2SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        else: #pupil size within 2SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def moving_avg(self,lst):\u000a        global ma\u000a        rm = pandas.DataFrame(lst, columns=['samples']).rolling(3,center=False).mean() #moving average\u000a        ma = rm['samples'][rm.index[-1]] #last pupil sample\u000a        return ma\u000a   \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Block_event"\u000aBlock_eventClock = core.Clock()\u000acomposite_display = visual.ImageStim(win=win, name='composite_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Block_event"-------\u000a    t = 0\u000a    Block_eventClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(5.000000)\u000a    # update component parameters for each repeat\u000a    blockNum = blockNum + 1 #trial count\u000a\u000a    #pupil\u000a    lps=[] #adjusted samples\u000a    ps_n1 = 0 #n-1 pupil sample\u000a    ps_n2 = 0 #n-2 pupil sample\u000a    st0=0 #time between samples (st1-st0)\u000a    Window = True #window to collect samples\u000a    first_loop = True\u000a    baseline = True #preparing start recording\u000a    \u000a    #eyelink\u000a    eye_used = eyelink.set_eye_used() #Set eye used\u000a    eyelink.start_recording() #start recording\u000a    \u000a    composite_display.setImage("instructions/"+block_event+".png")\u000a    image_size = composite_display.size[0],composite_display.size[1]\u000a    \u000a    #-------Start Routine "Block_event"-------       \u000a    #Block_event updates\u000a    composite_display.setAutoDraw(True)\u000a    win.flip()\u000a    \u000a    # update/draw components on each frame\u000a    #eyelink-pupil dilation baseline\u000a    while Window:\u000a        st1 = Block_eventClock.getTime()\u000a        if Block_eventClock.getTime() >= 0:\u000a            if Block_eventClock.getTime() >= 5:\u000a                composite_display.setAutoDraw(False)\u000a                break\u000a            else:\u000a                if eyelink.sample_time(st1,st0):\u000a                    ps_baseline = eyelink.pupil_sample_new()\u000a                    lps.append(ps_baseline)#adjusted pupil size\u000a                    st0 = st1      \u000a    \u000a    #-------Ending Routine "Block_event"-------\u000a    #eyelink-stop baseline recording  \u000a    eyelink.stop_recording()\u000a    composite_display.setAutoDraw(False)    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        Event_draw = False #marks the zero-time in a trial\u000a        baseline = False #preparing start recording\u000a        \u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a            \u000a            #if Fixation failed              \u000a            #if GAZE != True:\u000a            #    if DC >=2:#if drift correct failed twice run calibration\u000a            #        eyelink.calibrate()\u000a            #        DC = 0 #reset counter\u000a            #    else: # drift correct\u000a            #        eyelink.gc_drift_correct()\u000a            #        DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #debug for cross-validation\u000a            #loops\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            \u000a            #baseline pupil size\u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lps) #collect baseline min max mean and stdev (debug)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a\u000a            #trial pupil size            \u000a            Cue = True\u000a            old_cue = None\u000a            lps_old=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples \u000a            lps_d=[] #change in ps\u000a            ps_d = "nan" #providing dummy value for derivative\u000a            p_ma = "nan" #providing dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            ps_n2 = 0 #n-2 pupil size\u000a            \u000a            #computer performance\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a            \u000a            #time info\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.pupil_sample_new()\u000a                            st0 = st1\u000a                            \u000a                            #start debug #sample level\u000a                            #timing\u000a                            tt = eyelink.tracker_time()#tracker time\u000a                            pp_t = IAPSClock.getTime()#psychopy time\u000a                            \u000a                            #creating variables for cross-validation\u000a                            lblock.append(blockNum)#block\u000a                            ltrial.append(trialNum)#trial\u000a                            ltt.append(tt)#tracker time\u000a                            lpp_t.append(pp_t) #psychopy time\u000a                            cpu_pc.append(cpu_s)#cpu\u000a                            ram_pc.append(ram_s)#ram\u000a                            lps_min.append(ps_min)#neg stdev from baseline mean\u000a                            lps_mean.append(ps_mean)#baseline mean\u000a                            lps_max.append(ps_max)#pos stdev from baseline mean\u000a                            lps_old.append(ps_old)#unadjusted pupil size\u000a                            lps_d.append(ps_d)#pupil size velocity\u000a                            lps.append(ps_new)#adjusted pupil size\u000a                            #end debug\u000a                            \u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.250 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(ma,ps_min,ps_max)\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a\u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a\u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file for following:\u000a        #timestamp #pupil size #pupil running average #trial\u000a        #outputting set_list procedure\u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,\u000a                                            ltt,lpp_t,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            lps_old,lps_d,lps))\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p434
sg333
(lp435
sg335
I392424912
sg10
S'Break_loop'
p436
sg6
g337
sg338
I1
sg18
I01
sg19
g20
sg339
g1
(g340
g341
(dp437
g343
g344
(g345
g346
g347
S'b'
tRp438
(I1
(I1
I1
tg349
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg17
g344
(g345
g346
g347
S'b'
tRp439
(I1
(I1
I1
tg349
I00
S'\xa1#\xc2?'
S'\x00'
Ntbsg350
g344
(g345
g346
g347
S'b'
tRp440
(I1
(I1
I1
tg349
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g364
(g346
(I0
tS'b'
tRp441
(I1
(I1
I1
tg391
I00
(lp442
g129
atbstRp443
(dp444
g354
(dp445
g343
I01
sg17
I01
sg350
I01
sg16
I00
ssg356
g432
sg357
(lp446
g343
ag350
ag16
ag17
asg359
(lp447
I1
aI1
asbsg361
g421
sg363
g364
(g346
(I0
tS'b'
tRp448
(I1
(I1
I1
tg58
I00
S'\x00\x00\x00\x00'
tbsg366
I01
sg367
I1
sg368
I-1
sg369
(lp449
Nasg376
Nsg377
g133
sg379
I1
sg380
I0
sg381
I1
sg382
I01
sbag1
(g328
g3
NtRp450
(dp451
g331
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a\u000achanged\u000a- clean up of obsolete variables\u000a\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#imports for cross-validation\u000aimport csv\u000aimport itertools\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aeye_used = None\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def pupil_sample_new(self):\u000a        global first_loop\u000a        global ps_n2 #n-2 pupil sample\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_d #derivative of pupil area\u000a        global ps_old #ps without changes \u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a                ps_old = ps\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a                ps_old = ps            \u000a\u000a            #if not first sample\u000a            if first_loop != True:\u000a                #calculating derivative of pupil area \u000a                ps_d = (ps - ps_n2)/(2*500)\u000a                self.moving_avg(lps)#moving average\u000a                if ps_d < -0.01 * ma or ps_d > 0.01 * ma or ps == 0:\u000a                    ps = ps_n1\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a                else:\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a            else: #collect first sample \u000a                first_loop = False\u000a                ps_n2 = ps_n1\u000a                ps_n1 = ps \u000a                return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        if baseline:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Block A%s Image %s.png'" %(blockNum,block_event)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID A%s'%(blockNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 512, self.h/2 - 384, self.w/2 + 512, self.h/2 + 384,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1) #Begin recording - (0,0,1,0): sends samples through link   \u000a        else:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a    \u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean\u000a\u000a    def pupil_cue(self,p_ma,p_min,p_max):\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 2SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than 2SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        else: #pupil size within 2SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def moving_avg(self,lst):\u000a        global ma\u000a        rm = pandas.DataFrame(lst, columns=['samples']).rolling(3,center=False).mean() #moving average\u000a        ma = rm['samples'][rm.index[-1]] #last pupil sample\u000a        return ma\u000a   \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Block_event"\u000aBlock_eventClock = core.Clock()\u000acomposite_display = visual.ImageStim(win=win, name='composite_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Block_event"-------\u000a    t = 0\u000a    Block_eventClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(5.000000)\u000a    # update component parameters for each repeat\u000a    blockNum = blockNum + 1 #trial count\u000a\u000a    #pupil\u000a    lps=[] #adjusted samples\u000a    ps_n1 = 0 #n-1 pupil sample\u000a    ps_n2 = 0 #n-2 pupil sample\u000a    st0=0 #time between samples (st1-st0)\u000a    Window = True #window to collect samples\u000a    first_loop = True\u000a    baseline = True #preparing start recording\u000a    \u000a    #eyelink\u000a    eye_used = eyelink.set_eye_used() #Set eye used\u000a    eyelink.start_recording() #start recording\u000a    \u000a    composite_display.setImage("instructions/"+block_event+".png")\u000a    image_size = composite_display.size[0],composite_display.size[1]\u000a    \u000a    #-------Start Routine "Block_event"-------       \u000a    #Block_event updates\u000a    composite_display.setAutoDraw(True)\u000a    win.flip()\u000a    \u000a    # update/draw components on each frame\u000a    #eyelink-pupil dilation baseline\u000a    while Window:\u000a        st1 = Block_eventClock.getTime()\u000a        if Block_eventClock.getTime() >= 0:\u000a            if Block_eventClock.getTime() >= 5:\u000a                composite_display.setAutoDraw(False)\u000a                break\u000a            else:\u000a                if eyelink.sample_time(st1,st0):\u000a                    ps_baseline = eyelink.pupil_sample_new()\u000a                    lps.append(ps_baseline)#adjusted pupil size\u000a                    st0 = st1      \u000a    \u000a    #-------Ending Routine "Block_event"-------\u000a    #eyelink-stop baseline recording  \u000a    eyelink.stop_recording()\u000a    composite_display.setAutoDraw(False)    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        Event_draw = False #marks the zero-time in a trial\u000a        baseline = False #preparing start recording\u000a        \u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a            \u000a            #if Fixation failed              \u000a            #if GAZE != True:\u000a            #    if DC >=2:#if drift correct failed twice run calibration\u000a            #        eyelink.calibrate()\u000a            #        DC = 0 #reset counter\u000a            #    else: # drift correct\u000a            #        eyelink.gc_drift_correct()\u000a            #        DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #debug for cross-validation\u000a            #loops\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            \u000a            #baseline pupil size\u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lps) #collect baseline min max mean and stdev (debug)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a\u000a            #trial pupil size            \u000a            Cue = True\u000a            old_cue = None\u000a            lps_old=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples \u000a            lps_d=[] #change in ps\u000a            ps_d = "nan" #providing dummy value for derivative\u000a            p_ma = "nan" #providing dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            ps_n2 = 0 #n-2 pupil size\u000a            \u000a            #computer performance\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a            \u000a            #time info\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.pupil_sample_new()\u000a                            st0 = st1\u000a                            \u000a                            #start debug #sample level\u000a                            #timing\u000a                            tt = eyelink.tracker_time()#tracker time\u000a                            pp_t = IAPSClock.getTime()#psychopy time\u000a                            \u000a                            #creating variables for cross-validation\u000a                            lblock.append(blockNum)#block\u000a                            ltrial.append(trialNum)#trial\u000a                            ltt.append(tt)#tracker time\u000a                            lpp_t.append(pp_t) #psychopy time\u000a                            cpu_pc.append(cpu_s)#cpu\u000a                            ram_pc.append(ram_s)#ram\u000a                            lps_min.append(ps_min)#neg stdev from baseline mean\u000a                            lps_mean.append(ps_mean)#baseline mean\u000a                            lps_max.append(ps_max)#pos stdev from baseline mean\u000a                            lps_old.append(ps_old)#unadjusted pupil size\u000a                            lps_d.append(ps_d)#pupil size velocity\u000a                            lps.append(ps_new)#adjusted pupil size\u000a                            #end debug\u000a                            \u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.250 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(ma,ps_min,ps_max)\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a\u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a\u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file for following:\u000a        #timestamp #pupil size #pupil running average #trial\u000a        #outputting set_list procedure\u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,\u000a                                            ltt,lpp_t,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            lps_old,lps_d,lps))\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p452
sg333
(lp453
sg335
I392424912
sg10
g412
sg6
g337
sg338
I1
sg18
I01
sg19
g20
sg339
g1
(g340
g341
(dp454
g343
g344
(g345
g346
g347
S'b'
tRp455
(I1
(I4
I1
tg349
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg350
g344
(g345
g346
g347
S'b'
tRp456
(I1
(I4
I1
tg349
I00
S'\x00\x00@@\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x80?'
S'\x00\x00\x00\x00'
NtbstRp457
(dp458
g354
(dp459
g343
I01
sg350
I01
ssg356
g450
sg357
(lp460
g343
ag350
asg359
(lp461
I4
aI1
asbsg361
g421
sg363
g364
(g346
(I0
tS'b'
tRp462
(I1
(I4
I1
tg58
I01
S'\x01\x00\x00\x00\x03\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00'
tbsg366
I01
sg367
I1
sg368
I-1
sg369
(lp463
g1
(g371
g341
(dp464
g155
g217
sg157
g213
sg144
g206
sg149
g150
sg169
g202
sg153
g205
sg163
g211
stRp465
ag1
(g371
g341
(dp466
g155
g156
sg157
g158
sg144
g145
sg149
g150
sg169
g170
sg153
g154
sg163
g164
stRp467
ag1
(g371
g341
(dp468
g155
g201
sg157
g197
sg144
g190
sg149
g150
sg169
g202
sg153
g189
sg163
g195
stRp469
ag1
(g371
g341
(dp470
g155
g186
sg157
g182
sg144
g175
sg149
g150
sg169
g170
sg153
g174
sg163
g180
stRp471
asg376
Nsg377
g209
sg379
I4
sg380
I0
sg381
I4
sg382
I01
sbag1
(g328
g3
NtRp472
(dp473
g331
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a\u000achanged\u000a- clean up of obsolete variables\u000a\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#imports for cross-validation\u000aimport csv\u000aimport itertools\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aeye_used = None\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def pupil_sample_new(self):\u000a        global first_loop\u000a        global ps_n2 #n-2 pupil sample\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_d #derivative of pupil area\u000a        global ps_old #ps without changes \u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a                ps_old = ps\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a                ps_old = ps            \u000a\u000a            #if not first sample\u000a            if first_loop != True:\u000a                #calculating derivative of pupil area \u000a                ps_d = (ps - ps_n2)/(2*500)\u000a                self.moving_avg(lps)#moving average\u000a                if ps_d < -0.01 * ma or ps_d > 0.01 * ma or ps == 0:\u000a                    ps = ps_n1\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a                else:\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a            else: #collect first sample \u000a                first_loop = False\u000a                ps_n2 = ps_n1\u000a                ps_n1 = ps \u000a                return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        if baseline:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Block A%s Image %s.png'" %(blockNum,block_event)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID A%s'%(blockNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 512, self.h/2 - 384, self.w/2 + 512, self.h/2 + 384,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1) #Begin recording - (0,0,1,0): sends samples through link   \u000a        else:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a    \u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean\u000a\u000a    def pupil_cue(self,p_ma,p_min,p_max):\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 2SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than 2SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        else: #pupil size within 2SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def moving_avg(self,lst):\u000a        global ma\u000a        rm = pandas.DataFrame(lst, columns=['samples']).rolling(3,center=False).mean() #moving average\u000a        ma = rm['samples'][rm.index[-1]] #last pupil sample\u000a        return ma\u000a   \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Block_event"\u000aBlock_eventClock = core.Clock()\u000acomposite_display = visual.ImageStim(win=win, name='composite_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Block_event"-------\u000a    t = 0\u000a    Block_eventClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(5.000000)\u000a    # update component parameters for each repeat\u000a    blockNum = blockNum + 1 #trial count\u000a\u000a    #pupil\u000a    lps=[] #adjusted samples\u000a    ps_n1 = 0 #n-1 pupil sample\u000a    ps_n2 = 0 #n-2 pupil sample\u000a    st0=0 #time between samples (st1-st0)\u000a    Window = True #window to collect samples\u000a    first_loop = True\u000a    baseline = True #preparing start recording\u000a    \u000a    #eyelink\u000a    eye_used = eyelink.set_eye_used() #Set eye used\u000a    eyelink.start_recording() #start recording\u000a    \u000a    composite_display.setImage("instructions/"+block_event+".png")\u000a    image_size = composite_display.size[0],composite_display.size[1]\u000a    \u000a    #-------Start Routine "Block_event"-------       \u000a    #Block_event updates\u000a    composite_display.setAutoDraw(True)\u000a    win.flip()\u000a    \u000a    # update/draw components on each frame\u000a    #eyelink-pupil dilation baseline\u000a    while Window:\u000a        st1 = Block_eventClock.getTime()\u000a        if Block_eventClock.getTime() >= 0:\u000a            if Block_eventClock.getTime() >= 5:\u000a                composite_display.setAutoDraw(False)\u000a                break\u000a            else:\u000a                if eyelink.sample_time(st1,st0):\u000a                    ps_baseline = eyelink.pupil_sample_new()\u000a                    lps.append(ps_baseline)#adjusted pupil size\u000a                    st0 = st1      \u000a    \u000a    #-------Ending Routine "Block_event"-------\u000a    #eyelink-stop baseline recording  \u000a    eyelink.stop_recording()\u000a    composite_display.setAutoDraw(False)    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        Event_draw = False #marks the zero-time in a trial\u000a        baseline = False #preparing start recording\u000a        \u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a            \u000a            #if Fixation failed              \u000a            #if GAZE != True:\u000a            #    if DC >=2:#if drift correct failed twice run calibration\u000a            #        eyelink.calibrate()\u000a            #        DC = 0 #reset counter\u000a            #    else: # drift correct\u000a            #        eyelink.gc_drift_correct()\u000a            #        DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #debug for cross-validation\u000a            #loops\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            \u000a            #baseline pupil size\u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lps) #collect baseline min max mean and stdev (debug)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a\u000a            #trial pupil size            \u000a            Cue = True\u000a            old_cue = None\u000a            lps_old=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples \u000a            lps_d=[] #change in ps\u000a            ps_d = "nan" #providing dummy value for derivative\u000a            p_ma = "nan" #providing dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            ps_n2 = 0 #n-2 pupil size\u000a            \u000a            #computer performance\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a            \u000a            #time info\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.pupil_sample_new()\u000a                            st0 = st1\u000a                            \u000a                            #start debug #sample level\u000a                            #timing\u000a                            tt = eyelink.tracker_time()#tracker time\u000a                            pp_t = IAPSClock.getTime()#psychopy time\u000a                            \u000a                            #creating variables for cross-validation\u000a                            lblock.append(blockNum)#block\u000a                            ltrial.append(trialNum)#trial\u000a                            ltt.append(tt)#tracker time\u000a                            lpp_t.append(pp_t) #psychopy time\u000a                            cpu_pc.append(cpu_s)#cpu\u000a                            ram_pc.append(ram_s)#ram\u000a                            lps_min.append(ps_min)#neg stdev from baseline mean\u000a                            lps_mean.append(ps_mean)#baseline mean\u000a                            lps_max.append(ps_max)#pos stdev from baseline mean\u000a                            lps_old.append(ps_old)#unadjusted pupil size\u000a                            lps_d.append(ps_d)#pupil size velocity\u000a                            lps.append(ps_new)#adjusted pupil size\u000a                            #end debug\u000a                            \u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.250 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(ma,ps_min,ps_max)\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a\u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a\u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file for following:\u000a        #timestamp #pupil size #pupil running average #trial\u000a        #outputting set_list procedure\u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,\u000a                                            ltt,lpp_t,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            lps_old,lps_d,lps))\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p474
sg333
(lp475
sg335
I392424912
sg10
g436
sg6
g337
sg338
I1
sg18
I01
sg19
g20
sg339
g1
(g340
g341
(dp476
g343
g344
(g345
g346
g347
S'b'
tRp477
(I1
(I1
I1
tg349
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg17
g344
(g345
g346
g347
S'b'
tRp478
(I1
(I1
I1
tg349
I00
S'\x1a\x90\x12B'
S'\x00'
Ntbsg350
g344
(g345
g346
g347
S'b'
tRp479
(I1
(I1
I1
tg349
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g364
(g346
(I0
tS'b'
tRp480
(I1
(I1
I1
tg391
I00
(lp481
g222
atbstRp482
(dp483
g354
(dp484
g343
I01
sg17
I01
sg350
I01
sg16
I00
ssg356
g472
sg357
(lp485
g343
ag350
ag16
ag17
asg359
(lp486
I1
aI1
asbsg361
g421
sg363
g364
(g346
(I0
tS'b'
tRp487
(I1
(I1
I1
tg58
I00
S'\x00\x00\x00\x00'
tbsg366
I01
sg367
I1
sg368
I-1
sg369
(lp488
Nasg376
Nsg377
g226
sg379
I1
sg380
I0
sg381
I1
sg382
I01
sbag1
(g328
g3
NtRp489
(dp490
g331
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a\u000achanged\u000a- clean up of obsolete variables\u000a\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#imports for cross-validation\u000aimport csv\u000aimport itertools\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aeye_used = None\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def pupil_sample_new(self):\u000a        global first_loop\u000a        global ps_n2 #n-2 pupil sample\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_d #derivative of pupil area\u000a        global ps_old #ps without changes \u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a                ps_old = ps\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a                ps_old = ps            \u000a\u000a            #if not first sample\u000a            if first_loop != True:\u000a                #calculating derivative of pupil area \u000a                ps_d = (ps - ps_n2)/(2*500)\u000a                self.moving_avg(lps)#moving average\u000a                if ps_d < -0.01 * ma or ps_d > 0.01 * ma or ps == 0:\u000a                    ps = ps_n1\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a                else:\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a            else: #collect first sample \u000a                first_loop = False\u000a                ps_n2 = ps_n1\u000a                ps_n1 = ps \u000a                return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        if baseline:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Block A%s Image %s.png'" %(blockNum,block_event)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID A%s'%(blockNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 512, self.h/2 - 384, self.w/2 + 512, self.h/2 + 384,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1) #Begin recording - (0,0,1,0): sends samples through link   \u000a        else:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a    \u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean\u000a\u000a    def pupil_cue(self,p_ma,p_min,p_max):\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 2SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than 2SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        else: #pupil size within 2SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def moving_avg(self,lst):\u000a        global ma\u000a        rm = pandas.DataFrame(lst, columns=['samples']).rolling(3,center=False).mean() #moving average\u000a        ma = rm['samples'][rm.index[-1]] #last pupil sample\u000a        return ma\u000a   \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Block_event"\u000aBlock_eventClock = core.Clock()\u000acomposite_display = visual.ImageStim(win=win, name='composite_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Block_event"-------\u000a    t = 0\u000a    Block_eventClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(5.000000)\u000a    # update component parameters for each repeat\u000a    blockNum = blockNum + 1 #trial count\u000a\u000a    #pupil\u000a    lps=[] #adjusted samples\u000a    ps_n1 = 0 #n-1 pupil sample\u000a    ps_n2 = 0 #n-2 pupil sample\u000a    st0=0 #time between samples (st1-st0)\u000a    Window = True #window to collect samples\u000a    first_loop = True\u000a    baseline = True #preparing start recording\u000a    \u000a    #eyelink\u000a    eye_used = eyelink.set_eye_used() #Set eye used\u000a    eyelink.start_recording() #start recording\u000a    \u000a    composite_display.setImage("instructions/"+block_event+".png")\u000a    image_size = composite_display.size[0],composite_display.size[1]\u000a    \u000a    #-------Start Routine "Block_event"-------       \u000a    #Block_event updates\u000a    composite_display.setAutoDraw(True)\u000a    win.flip()\u000a    \u000a    # update/draw components on each frame\u000a    #eyelink-pupil dilation baseline\u000a    while Window:\u000a        st1 = Block_eventClock.getTime()\u000a        if Block_eventClock.getTime() >= 0:\u000a            if Block_eventClock.getTime() >= 5:\u000a                composite_display.setAutoDraw(False)\u000a                break\u000a            else:\u000a                if eyelink.sample_time(st1,st0):\u000a                    ps_baseline = eyelink.pupil_sample_new()\u000a                    lps.append(ps_baseline)#adjusted pupil size\u000a                    st0 = st1      \u000a    \u000a    #-------Ending Routine "Block_event"-------\u000a    #eyelink-stop baseline recording  \u000a    eyelink.stop_recording()\u000a    composite_display.setAutoDraw(False)    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        Event_draw = False #marks the zero-time in a trial\u000a        baseline = False #preparing start recording\u000a        \u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a            \u000a            #if Fixation failed              \u000a            #if GAZE != True:\u000a            #    if DC >=2:#if drift correct failed twice run calibration\u000a            #        eyelink.calibrate()\u000a            #        DC = 0 #reset counter\u000a            #    else: # drift correct\u000a            #        eyelink.gc_drift_correct()\u000a            #        DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #debug for cross-validation\u000a            #loops\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            \u000a            #baseline pupil size\u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lps) #collect baseline min max mean and stdev (debug)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a\u000a            #trial pupil size            \u000a            Cue = True\u000a            old_cue = None\u000a            lps_old=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples \u000a            lps_d=[] #change in ps\u000a            ps_d = "nan" #providing dummy value for derivative\u000a            p_ma = "nan" #providing dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            ps_n2 = 0 #n-2 pupil size\u000a            \u000a            #computer performance\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a            \u000a            #time info\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.pupil_sample_new()\u000a                            st0 = st1\u000a                            \u000a                            #start debug #sample level\u000a                            #timing\u000a                            tt = eyelink.tracker_time()#tracker time\u000a                            pp_t = IAPSClock.getTime()#psychopy time\u000a                            \u000a                            #creating variables for cross-validation\u000a                            lblock.append(blockNum)#block\u000a                            ltrial.append(trialNum)#trial\u000a                            ltt.append(tt)#tracker time\u000a                            lpp_t.append(pp_t) #psychopy time\u000a                            cpu_pc.append(cpu_s)#cpu\u000a                            ram_pc.append(ram_s)#ram\u000a                            lps_min.append(ps_min)#neg stdev from baseline mean\u000a                            lps_mean.append(ps_mean)#baseline mean\u000a                            lps_max.append(ps_max)#pos stdev from baseline mean\u000a                            lps_old.append(ps_old)#unadjusted pupil size\u000a                            lps_d.append(ps_d)#pupil size velocity\u000a                            lps.append(ps_new)#adjusted pupil size\u000a                            #end debug\u000a                            \u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.250 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(ma,ps_min,ps_max)\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a\u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a\u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file for following:\u000a        #timestamp #pupil size #pupil running average #trial\u000a        #outputting set_list procedure\u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,\u000a                                            ltt,lpp_t,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            lps_old,lps_d,lps))\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p491
sg333
(lp492
sg335
I392424912
sg10
g412
sg6
g337
sg338
I1
sg18
I01
sg19
g20
sg339
g1
(g340
g341
(dp493
g343
g344
(g345
g346
g347
S'b'
tRp494
(I1
(I4
I1
tg349
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg350
g344
(g345
g346
g347
S'b'
tRp495
(I1
(I4
I1
tg349
I00
S'\x00\x00\x00\x00\x00\x00@@\x00\x00\x00@\x00\x00\x80?'
S'\x00\x00\x00\x00'
NtbstRp496
(dp497
g354
(dp498
g343
I01
sg350
I01
ssg356
g489
sg357
(lp499
g343
ag350
asg359
(lp500
I4
aI1
asbsg361
g421
sg363
g364
(g346
(I0
tS'b'
tRp501
(I1
(I4
I1
tg58
I01
S'\x00\x00\x00\x00\x03\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00'
tbsg366
I01
sg367
I1
sg368
I-1
sg369
(lp502
g1
(g371
g341
(dp503
g247
g248
sg249
g250
sg237
g238
sg242
g243
sg262
g263
sg245
g246
sg256
g257
stRp504
ag1
(g371
g341
(dp505
g247
g309
sg249
g305
sg237
g298
sg242
g243
sg262
g263
sg245
g297
sg256
g303
stRp506
ag1
(g371
g341
(dp507
g247
g294
sg249
g290
sg237
g283
sg242
g243
sg262
g263
sg245
g282
sg256
g288
stRp508
ag1
(g371
g341
(dp509
g247
g279
sg249
g275
sg237
g268
sg242
g243
sg262
g263
sg245
g267
sg256
g273
stRp510
asg376
Nsg377
g301
sg379
I4
sg380
I0
sg381
I4
sg382
I01
sbag1
(g328
g3
NtRp511
(dp512
g331
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a\u000achanged\u000a- clean up of obsolete variables\u000a\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000aimport pylink\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000afrom _script import eyelink_display\u000afrom statistics import stdev\u000afrom PIL import Image\u000aimport pandas\u000afrom psychopy.hardware import joystick\u000a\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#imports for cross-validation\u000aimport csv\u000aimport itertools\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aeye_used = None\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1\u000a        self.binocular = 2        \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False\u000a        self.Fixation = True        \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a    \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        dt = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def pupil_sample(self):\u000a        """\u000a        desc:\u000a            Returns the newest pupil size sample.\u000a        returns:dt.getRightEye()\u000a            desc: Returns pupil size for the eye that is currently\u000a                being tracked\u000a    		type:	[int, float]\u000a        """\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the pupil size of the latest sample\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def pupil_sample_new(self):\u000a        global first_loop\u000a        global ps_n2 #n-2 pupil sample\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_d #derivative of pupil area\u000a        global ps_old #ps without changes \u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a                ps_old = ps\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a                ps_old = ps            \u000a\u000a            #if not first sample\u000a            if first_loop != True:\u000a                #calculating derivative of pupil area \u000a                ps_d = (ps - ps_n2)/(2*500)\u000a                self.moving_avg(lps)#moving average\u000a                if ps_d < -0.01 * ma or ps_d > 0.01 * ma or ps == 0:\u000a                    ps = ps_n1\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a                else:\u000a                    ps_n2 = ps_n1\u000a                    ps_n1 = ps \u000a                    return ps\u000a            else: #collect first sample \u000a                first_loop = False\u000a                ps_n2 = ps_n1\u000a                ps_n1 = ps \u000a                return ps\u000a\u000a    def set_eye_used(self):\u000a        eye_ = pylink.getEYELINK().eyeAvailable()\u000a        return eye_\u000a\u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        if baseline:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Block A%s Image %s.png'" %(blockNum,block_event)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID A%s'%(blockNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 512, self.h/2 - 384, self.w/2 + 512, self.h/2 + 384,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1) #Begin recording - (0,0,1,0): sends samples through link   \u000a        else:\u000a            pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a            pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a            pylink.getEYELINK().sendCommand("clear_screen 0")\u000a            pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a            pylink.beginRealTimeMode(100) #start realtime mode\u000a            pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a    \u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a\u000a    def tracker_time(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a\u000a    def min_max(self,lst):\u000a        _mean = sum(lst)/len(lst)\u000a        _stdev = stdev(lst)    \u000a        _max = _mean + (_stdev *2)\u000a        _min = _mean - (_stdev *2)\u000a        return _min,_max,_mean\u000a\u000a    def pupil_cue(self,p_ma,p_min,p_max):\u000a        less_ = p_ma < p_min\u000a        greater_ = p_ma > p_max\u000a        if less_: #pupil size less than 2SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than 2SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'red'\u000a        else: #pupil size within 2SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def moving_avg(self,lst):\u000a        global ma\u000a        rm = pandas.DataFrame(lst, columns=['samples']).rolling(3,center=False).mean() #moving average\u000a        ma = rm['samples'][rm.index[-1]] #last pupil sample\u000a        return ma\u000a   \u000a    def sample_time(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a    \u000a    def cue_time(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Block_event"\u000aBlock_eventClock = core.Clock()\u000acomposite_display = visual.ImageStim(win=win, name='composite_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000a\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "Block_event"-------\u000a    t = 0\u000a    Block_eventClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(5.000000)\u000a    # update component parameters for each repeat\u000a    blockNum = blockNum + 1 #trial count\u000a\u000a    #pupil\u000a    lps=[] #adjusted samples\u000a    ps_n1 = 0 #n-1 pupil sample\u000a    ps_n2 = 0 #n-2 pupil sample\u000a    st0=0 #time between samples (st1-st0)\u000a    Window = True #window to collect samples\u000a    first_loop = True\u000a    baseline = True #preparing start recording\u000a    \u000a    #eyelink\u000a    eye_used = eyelink.set_eye_used() #Set eye used\u000a    eyelink.start_recording() #start recording\u000a    \u000a    composite_display.setImage("instructions/"+block_event+".png")\u000a    image_size = composite_display.size[0],composite_display.size[1]\u000a    \u000a    #-------Start Routine "Block_event"-------       \u000a    #Block_event updates\u000a    composite_display.setAutoDraw(True)\u000a    win.flip()\u000a    \u000a    # update/draw components on each frame\u000a    #eyelink-pupil dilation baseline\u000a    while Window:\u000a        st1 = Block_eventClock.getTime()\u000a        if Block_eventClock.getTime() >= 0:\u000a            if Block_eventClock.getTime() >= 5:\u000a                composite_display.setAutoDraw(False)\u000a                break\u000a            else:\u000a                if eyelink.sample_time(st1,st0):\u000a                    ps_baseline = eyelink.pupil_sample_new()\u000a                    lps.append(ps_baseline)#adjusted pupil size\u000a                    st0 = st1      \u000a    \u000a    #-------Ending Routine "Block_event"-------\u000a    #eyelink-stop baseline recording  \u000a    eyelink.stop_recording()\u000a    composite_display.setAutoDraw(False)    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        Fixation = True\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a        Event_draw = False #marks the zero-time in a trial\u000a        baseline = False #preparing start recording\u000a        \u000a        while Fixation:\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            #while continueRoutine and routineTimer.getTime() > 0:\u000a            while FixationClock.getTime() < 2:\u000a                # get current time\u000a                t = FixationClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                \u000a                # *fixation_cross* updates\u000a                win.flip()\u000a                fixation_cross.draw()\u000a                \u000a                # update/draw components on each frame\u000a                #eyelink-gaze contingent fixation\u000a                if inbox != True:\u000a                    eyelink.gc_window()\u000a                \u000a                if t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    fixation_cross.setAutoDraw(False)\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a            \u000a            #if Fixation failed              \u000a            #if GAZE != True:\u000a            #    if DC >=2:#if drift correct failed twice run calibration\u000a            #        eyelink.calibrate()\u000a            #        DC = 0 #reset counter\u000a            #    else: # drift correct\u000a            #        eyelink.gc_drift_correct()\u000a            #        DC = DC + 1 #add counter\u000a        \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #debug for cross-validation\u000a            #loops\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            \u000a            #baseline pupil size\u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lps) #collect baseline min max mean and stdev (debug)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a\u000a            #trial pupil size            \u000a            Cue = True\u000a            old_cue = None\u000a            lps_old=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples \u000a            lps_d=[] #change in ps\u000a            ps_d = "nan" #providing dummy value for derivative\u000a            p_ma = "nan" #providing dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            ps_n2 = 0 #n-2 pupil size\u000a            \u000a            #computer performance\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a            \u000a            #time info\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            stimulus_offset = 20 #time (sec)\u000a            blank_offset = 22 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    iaps_display.tStart = t  # underestimates by a little under one frame\u000a                    iaps_display.frameNStart = frameN  # exact frame index\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.sample_time(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.pupil_sample_new()\u000a                            st0 = st1\u000a                            \u000a                            #start debug #sample level\u000a                            #timing\u000a                            tt = eyelink.tracker_time()#tracker time\u000a                            pp_t = IAPSClock.getTime()#psychopy time\u000a                            \u000a                            #creating variables for cross-validation\u000a                            lblock.append(blockNum)#block\u000a                            ltrial.append(trialNum)#trial\u000a                            ltt.append(tt)#tracker time\u000a                            lpp_t.append(pp_t) #psychopy time\u000a                            cpu_pc.append(cpu_s)#cpu\u000a                            ram_pc.append(ram_s)#ram\u000a                            lps_min.append(ps_min)#neg stdev from baseline mean\u000a                            lps_mean.append(ps_mean)#baseline mean\u000a                            lps_max.append(ps_max)#pos stdev from baseline mean\u000a                            lps_old.append(ps_old)#unadjusted pupil size\u000a                            lps_d.append(ps_d)#pupil size velocity\u000a                            lps.append(ps_new)#adjusted pupil size\u000a                            #end debug\u000a                            \u000a                        if eyelink.cue_time(ct1,ct0): #if time between cues > 250 msec\u000a                            ct0 = ct1\u000a                            break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 0.250 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(ma,ps_min,ps_max)\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a\u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a\u000a                if iaps_cue.status == STARTED and t >= (stimulus_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    blank.tStart = t  # underestimates by a little under one frame\u000a                    blank.frameNStart = frameN  # exact frame index\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= (blank_offset-win.monitorFramePeriod*0.75): #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file for following:\u000a        #timestamp #pupil size #pupil running average #trial\u000a        #outputting set_list procedure\u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,\u000a                                            ltt,lpp_t,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            lps_old,lps_d,lps))\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p513
sg333
(lp514
sg335
I392424912
sg10
g436
sg6
g337
sg338
I1
sg18
I01
sg19
g20
sg339
g1
(g340
g341
(dp515
g343
g344
(g345
g346
g347
S'b'
tRp516
(I1
(I1
I1
tg349
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg350
g344
(g345
g346
g347
S'b'
tRp517
(I1
(I1
I1
tg349
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g364
(g346
(I0
tS'b'
tRp518
(I1
(I1
I1
tg391
I00
(lp519
NatbstRp520
(dp521
g354
(dp522
g343
I01
sg350
I01
sg16
I00
ssg356
g511
sg357
(lp523
g343
ag350
ag16
asg359
(lp524
I1
aI1
asbsg361
g421
sg363
g364
(g346
(I0
tS'b'
tRp525
(I1
(I1
I1
tg58
I00
S'\x00\x00\x00\x00'
tbsg366
I01
sg367
I1
sg368
I-1
sg369
(lp526
Nasg376
Nsg377
g317
sg379
I1
sg380
I0
sg381
I1
sg382
I01
sbasS'savePickle'
p527
I00
sb.