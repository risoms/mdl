ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005csr38553\u005cDesktop\u005cnew task\u005ctask\u005c_data/csv/001_CGP
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'CGP'
p11
sS'dataNames'
p12
(lp13
S'block_key.keys'
p14
aS'block_key.rt'
p15
aS'Break_key.keys'
p16
aS'Break_key.rt'
p17
asS'autoLog'
p18
I01
sS'extraInfo'
p19
(dp20
S'date'
p21
V2016_Jun_24_1305
p22
sS'frameRate'
p23
cnumpy.core.multiarray
scalar
p24
(cnumpy
dtype
p25
(S'f8'
I0
I1
tRp26
(I3
S'<'
NNNI-1
I-1
I0
tbS'\xd6\xe3\xfea~\x04^@'
tRp27
sS'expName'
p28
g11
sVParticipant
p29
V001
p30
sVDominant Eye
p31
Vl
ssS'loopsUnfinished'
p32
(lp33
sS'saveWideText'
p34
I01
sS'thisEntry'
p35
(dp36
sS'version'
p37
S''
sS'_paramNamesSoFar'
p38
(lp39
S'block_event'
p40
aS'order'
p41
aS'block_display'
p42
aS'block_file'
p43
aS'break_display'
p44
aS'valmean'
p45
aS'valence'
p46
aS'scenestim'
p47
aS'arousal'
p48
aS'outliers'
p49
aS'blocknum'
p50
aS'arousalmean'
p51
asS'entries'
p52
(lp53
(dp54
S'Trial_Loop.thisTrialN'
p55
I0
sg29
g30
sg47
S'2120.bmp'
p56
sg40
S'comp_1'
p57
sS'Trial_Loop.thisIndex'
p58
g24
(g25
(S'i4'
I0
I1
tRp59
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x01\x00\x00\x00'
tRp60
sg23
g27
sg48
S'High'
p61
sS'Trial_Loop.thisRepN'
p62
I0
sg42
S'inst_2'
p63
sg50
g24
(g25
(S'i8'
I0
I1
tRp64
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp65
sg45
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\n@'
tRp66
sg49
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp67
sg15
F0.76677278184797615
sS'block_loop.thisIndex'
p68
g24
(g59
S'\x00\x00\x00\x00'
tRp69
sg14
S'return'
p70
sS'Trial_Loop.thisN'
p71
I0
sg44
S'break'
p72
sg21
g22
sg51
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x14@'
tRp73
sS'block_loop.thisRepN'
p74
I0
sS'block_loop.thisN'
p75
I0
sg31
Vl
sg43
S'procedure\\0.csv'
p76
sS'block_loop.thisTrialN'
p77
I0
sg28
g11
sg46
S'Negative'
p78
sg41
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp79
sa(dp80
S'Trial_Loop.thisTrialN'
p81
I1
sg50
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp82
sg47
S'2205.bmp'
p83
sg40
g57
sg44
g72
sg23
g27
sS'Trial_Loop.thisN'
p84
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p85
g24
(g59
S'\x02\x00\x00\x00'
tRp86
sg48
g61
sg29
g30
sS'Trial_Loop.thisRepN'
p87
I0
sg42
g63
sg51
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x12@'
tRp88
sS'block_loop.thisRepN'
p89
I0
sg49
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp90
sS'block_loop.thisIndex'
p91
g69
sS'block_loop.thisN'
p92
I0
sg31
Vl
sg43
g76
sS'block_loop.thisTrialN'
p93
I0
sg45
g24
(g26
S'333333\xff?'
tRp94
sg28
g11
sg46
g78
sg41
g79
sa(dp95
S'Trial_Loop.thisTrialN'
p96
I2
sg50
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp97
sg47
S'2030.bmp'
p98
sg40
g57
sg44
g72
sg23
g27
sS'Trial_Loop.thisN'
p99
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p100
g24
(g59
S'\x00\x00\x00\x00'
tRp101
sg48
g61
sg29
g30
sS'Trial_Loop.thisRepN'
p102
I0
sg42
g63
sg51
g24
(g26
S')\\\x8f\xc2\xf5(\x12@'
tRp103
sS'block_loop.thisRepN'
p104
I0
sg49
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp105
sS'block_loop.thisIndex'
p106
g69
sS'block_loop.thisN'
p107
I0
sg31
Vl
sg43
g76
sS'block_loop.thisTrialN'
p108
I0
sg45
g24
(g26
S'\xd7\xa3p=\n\xd7\x1a@'
tRp109
sg28
g11
sg46
S'Positive'
p110
sg41
g79
sa(dp111
S'Trial_Loop.thisTrialN'
p112
I3
sg50
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp113
sg47
S'2655.bmp'
p114
sg40
g57
sg44
g72
sg23
g27
sS'Trial_Loop.thisN'
p115
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p116
g24
(g59
S'\x03\x00\x00\x00'
tRp117
sg48
g61
sg29
g30
sS'Trial_Loop.thisRepN'
p118
I0
sg42
g63
sg51
g24
(g26
S'H\xe1z\x14\xaeG\x12@'
tRp119
sS'block_loop.thisRepN'
p120
I0
sg49
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp121
sS'block_loop.thisIndex'
p122
g69
sS'block_loop.thisN'
p123
I0
sg31
Vl
sg43
g76
sS'block_loop.thisTrialN'
p124
I0
sg45
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x1b@'
tRp125
sg28
g11
sg46
g110
sg41
g79
sa(dp126
S'block_loop.thisRepN'
p127
I0
sg28
g11
sS'Break_loop.thisTrialN'
p128
I0
sg42
g63
sS'block_loop.thisIndex'
p129
g69
sg16
S'space'
p130
sg40
g57
sg29
g30
sS'block_loop.thisN'
p131
I0
sg31
Vl
sg43
g76
sg41
g79
sS'Break_loop.thisRepN'
p132
I0
sg23
g27
sg44
g72
sg21
g22
sS'Break_loop.thisIndex'
p133
g24
(g59
S'\x00\x00\x00\x00'
tRp134
sS'Break_loop.thisN'
p135
I0
sg17
F3.141579506569542
sS'Break_loop.thisTrial'
p136
NsS'block_loop.thisTrialN'
p137
I0
sa(dp138
S'block_loop.thisRepN'
p139
I0
sg23
g27
sg42
g63
sS'block_loop.thisIndex'
p140
g69
sg40
g57
sS'block_loop.thisN'
p141
I0
sg43
g76
sg41
g79
sg28
g11
sg44
g72
sg21
g22
sg29
g30
sg31
Vl
sS'block_loop.thisTrialN'
p142
I0
sa(dp143
S'Trial_Loop.thisTrialN'
p144
I0
sg29
g30
sS'scenestim'
p145
S'2208.bmp'
p146
sg40
S'comp_2'
p147
sS'Trial_Loop.thisIndex'
p148
g24
(g59
S'\x00\x00\x00\x00'
tRp149
sg23
g27
sS'arousal'
p150
S'High'
p151
sS'Trial_Loop.thisRepN'
p152
I0
sg42
S'cont_inst'
p153
sS'blocknum'
p154
g24
(g64
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp155
sS'valmean'
p156
g24
(g26
S'ffffff\x1d@'
tRp157
sS'outliers'
p158
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp159
sg15
F0.45847905374830589
sS'block_loop.thisIndex'
p160
g24
(g59
S'\x01\x00\x00\x00'
tRp161
sg14
S'space'
p162
sS'Trial_Loop.thisN'
p163
I0
sg44
g72
sg21
g22
sS'arousalmean'
p164
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x16@'
tRp165
sS'block_loop.thisRepN'
p166
I0
sS'block_loop.thisN'
p167
I1
sg31
Vl
sg43
S'procedure\\1.csv'
p168
sS'block_loop.thisTrialN'
p169
I1
sg28
g11
sS'valence'
p170
S'Positive'
p171
sg41
g24
(g64
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp172
sa(dp173
S'Trial_Loop.thisTrialN'
p174
I1
sg154
g24
(g64
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp175
sg145
S'2278.bmp'
p176
sg40
g147
sg44
g72
sg23
g27
sS'Trial_Loop.thisN'
p177
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p178
g24
(g59
S'\x01\x00\x00\x00'
tRp179
sg150
g151
sg29
g30
sS'Trial_Loop.thisRepN'
p180
I0
sg42
g153
sg164
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x13@'
tRp181
sS'block_loop.thisRepN'
p182
I0
sg158
g24
(g64
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp183
sS'block_loop.thisIndex'
p184
g161
sS'block_loop.thisN'
p185
I1
sg31
Vl
sg43
g168
sS'block_loop.thisTrialN'
p186
I1
sg156
g24
(g26
S'\x1f\x85\xebQ\xb8\x1e\x14@'
tRp187
sg28
g11
sg170
S'Negative'
p188
sg41
g172
sa(dp189
S'Trial_Loop.thisTrialN'
p190
I2
sg154
g24
(g64
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp191
sg145
S'2550.bmp'
p192
sg40
g147
sg44
g72
sg23
g27
sS'Trial_Loop.thisN'
p193
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p194
g24
(g59
S'\x02\x00\x00\x00'
tRp195
sg150
g151
sg29
g30
sS'Trial_Loop.thisRepN'
p196
I0
sg42
g153
sg164
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\x12@'
tRp197
sS'block_loop.thisRepN'
p198
I0
sg158
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp199
sS'block_loop.thisIndex'
p200
g161
sS'block_loop.thisN'
p201
I1
sg31
Vl
sg43
g168
sS'block_loop.thisTrialN'
p202
I1
sg156
g24
(g26
S'\x14\xaeG\xe1z\x14\x1f@'
tRp203
sg28
g11
sg170
g171
sg41
g172
sa(dp204
S'Trial_Loop.thisTrialN'
p205
I3
sg154
g24
(g64
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp206
sg145
S'3180.bmp'
p207
sg40
g147
sg44
g72
sg23
g27
sS'Trial_Loop.thisN'
p208
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p209
g24
(g59
S'\x03\x00\x00\x00'
tRp210
sg150
g151
sg29
g30
sS'Trial_Loop.thisRepN'
p211
I0
sg42
g153
sg164
g24
(g26
S'\x14\xaeG\xe1z\x14\x17@'
tRp212
sS'block_loop.thisRepN'
p213
I0
sg158
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp214
sS'block_loop.thisIndex'
p215
g161
sS'block_loop.thisN'
p216
I1
sg31
Vl
sg43
g168
sS'block_loop.thisTrialN'
p217
I1
sg156
g24
(g26
S'\xb8\x1e\x85\xebQ\xb8\xfe?'
tRp218
sg28
g11
sg170
g188
sg41
g172
sa(dp219
S'block_loop.thisRepN'
p220
I0
sg28
g11
sS'Break_loop.thisTrialN'
p221
I0
sg42
g153
sS'block_loop.thisIndex'
p222
g161
sg16
S'space'
p223
sg40
g147
sg29
g30
sS'block_loop.thisN'
p224
I1
sg31
Vl
sg43
g168
sg41
g172
sS'Break_loop.thisRepN'
p225
I0
sg23
g27
sg44
g72
sg21
g22
sS'Break_loop.thisIndex'
p226
g24
(g59
S'\x00\x00\x00\x00'
tRp227
sS'Break_loop.thisN'
p228
I0
sg17
F1.291786972200498
sS'Break_loop.thisTrial'
p229
NsS'block_loop.thisTrialN'
p230
I1
sa(dp231
S'block_loop.thisRepN'
p232
I0
sg23
g27
sg42
g153
sS'block_loop.thisIndex'
p233
g161
sg40
g147
sS'block_loop.thisN'
p234
I1
sg43
g168
sg41
g172
sg28
g11
sg44
g72
sg21
g22
sg29
g30
sg31
Vl
sS'block_loop.thisTrialN'
p235
I1
sa(dp236
S'Trial_Loop.thisTrialN'
p237
I0
sg29
g30
sS'scenestim'
p238
S'2375.1.bmp'
p239
sg40
S'comp_3'
p240
sS'Trial_Loop.thisIndex'
p241
g24
(g59
S'\x02\x00\x00\x00'
tRp242
sg23
g27
sS'arousal'
p243
S'High'
p244
sS'Trial_Loop.thisRepN'
p245
I0
sg42
g153
sS'blocknum'
p246
g24
(g64
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp247
sS'valmean'
p248
g24
(g26
S'\x9a\x99\x99\x99\x99\x99\x01@'
tRp249
sS'outliers'
p250
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp251
sg15
F1.0584781128563918
sS'block_loop.thisIndex'
p252
g24
(g59
S'\x02\x00\x00\x00'
tRp253
sg14
S'space'
p254
sS'Trial_Loop.thisN'
p255
I0
sg44
S'blank'
p256
sg21
g22
sS'arousalmean'
p257
g24
(g26
S'\x85\xebQ\xb8\x1e\x85\x13@'
tRp258
sS'block_loop.thisRepN'
p259
I0
sS'block_loop.thisN'
p260
I2
sg31
Vl
sg43
S'procedure\\2.csv'
p261
sS'block_loop.thisTrialN'
p262
I2
sg28
g11
sS'valence'
p263
S'Negative'
p264
sg41
g24
(g64
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp265
sa(dp266
S'Trial_Loop.thisTrialN'
p267
I1
sg246
g24
(g64
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp268
sg238
S'2691.bmp'
p269
sg40
g240
sg44
g256
sg23
g27
sS'Trial_Loop.thisN'
p270
I1
sg21
g22
sS'Trial_Loop.thisIndex'
p271
g24
(g59
S'\x03\x00\x00\x00'
tRp272
sg243
g244
sg29
g30
sS'Trial_Loop.thisRepN'
p273
I0
sg42
g153
sg257
g24
(g26
S'ffffff\x17@'
tRp274
sS'block_loop.thisRepN'
p275
I0
sg250
g24
(g64
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp276
sS'block_loop.thisIndex'
p277
g253
sS'block_loop.thisN'
p278
I2
sg31
Vl
sg43
g261
sS'block_loop.thisTrialN'
p279
I2
sg248
g24
(g26
S'R\xb8\x1e\x85\xebQ\x08@'
tRp280
sg28
g11
sg263
g264
sg41
g265
sa(dp281
S'Trial_Loop.thisTrialN'
p282
I2
sg246
g24
(g64
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp283
sg238
S'2095.bmp'
p284
sg40
g240
sg44
g256
sg23
g27
sS'Trial_Loop.thisN'
p285
I2
sg21
g22
sS'Trial_Loop.thisIndex'
p286
g24
(g59
S'\x00\x00\x00\x00'
tRp287
sg243
g244
sg29
g30
sS'Trial_Loop.thisRepN'
p288
I0
sg42
g153
sg257
g24
(g26
S'\x00\x00\x00\x00\x00\x00\x15@'
tRp289
sS'block_loop.thisRepN'
p290
I0
sg250
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp291
sS'block_loop.thisIndex'
p292
g253
sS'block_loop.thisN'
p293
I2
sg31
Vl
sg43
g261
sS'block_loop.thisTrialN'
p294
I2
sg248
g24
(g26
S'\xa4p=\n\xd7\xa3\xfc?'
tRp295
sg28
g11
sg263
g264
sg41
g265
sa(dp296
S'Trial_Loop.thisTrialN'
p297
I3
sg246
g24
(g64
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp298
sg238
S'2278.bmp'
p299
sg40
g240
sg44
g256
sg23
g27
sS'Trial_Loop.thisN'
p300
I3
sg21
g22
sS'Trial_Loop.thisIndex'
p301
g24
(g59
S'\x01\x00\x00\x00'
tRp302
sg243
g244
sg29
g30
sS'Trial_Loop.thisRepN'
p303
I0
sg42
g153
sg257
g24
(g26
S'333333\x12@'
tRp304
sS'block_loop.thisRepN'
p305
I0
sg250
g24
(g64
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp306
sS'block_loop.thisIndex'
p307
g253
sS'block_loop.thisN'
p308
I2
sg31
Vl
sg43
g261
sS'block_loop.thisTrialN'
p309
I2
sg248
g24
(g26
S'\xe1z\x14\xaeG\xe1\n@'
tRp310
sg28
g11
sg263
g264
sg41
g265
sa(dp311
S'block_loop.thisRepN'
p312
I0
sg28
g11
sS'Break_loop.thisTrialN'
p313
I0
sg42
g153
sS'block_loop.thisIndex'
p314
g253
sg16
Nsg40
g240
sg29
g30
sS'block_loop.thisN'
p315
I2
sg43
g261
sg41
g265
sS'Break_loop.thisRepN'
p316
I0
sg23
g27
sg44
g256
sg21
g22
sS'Break_loop.thisIndex'
p317
g24
(g59
S'\x00\x00\x00\x00'
tRp318
sS'Break_loop.thisN'
p319
I0
sg31
Vl
sS'Break_loop.thisTrial'
p320
NsS'block_loop.thisTrialN'
p321
I2
sa(dp322
S'block_loop.thisRepN'
p323
I0
sg23
g27
sg42
g153
sS'block_loop.thisIndex'
p324
g253
sg40
g240
sS'block_loop.thisN'
p325
I2
sg43
g261
sg41
g265
sg28
g11
sg44
g256
sg21
g22
sg29
g30
sg31
Vl
sS'block_loop.thisTrialN'
p326
I2
sasS'loops'
p327
(lp328
g1
(cpsychopy.data
TrialHandler
p329
g3
NtRp330
(dp331
S'origin'
p332
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ps <= (1.01*ps_n1) and ps >= (.99*ps_n1):\u000a                    if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *1)\u000a        _min = _mean - (_stdev *1)\u000a        return _min,_max,_mean\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def pupil_cue(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=150) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","cue","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,\u000a                                            ltt,time_,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a    \u000a    def t_csv(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a        else:\u000a            #timing\u000a            tt = eyelink.t_tracker()#tracker time\u000a            pp_t = event.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            lblock.append(blockNum)#block\u000a            ltrial.append(trialNum)#trial\u000a            levent.append(event_type)#baseline or stimulus\u000a            ltt.append(tt)#tracker time\u000a            lpp_t.append(pp_t)#psychopy time\u000a            cpu_pc.append(cpu_s)#cpu\u000a            ram_pc.append(ram_s)#ram\u000a            lps_min.append(ps_min)#neg stdev from baseline mean\u000a            lps_mean.append(ps_mean)#baseline mean\u000a            lps_max.append(ps_max)#pos stdev from baseline mean\u000a            lps_uadj.append(ps_o)#unadjusted pupil size\u000a            lps_d.append(maV)#pupil size velocity\u000a            lps.append(ps_n)#adjusted pupil size\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blink_event) #debug\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating block count\u000a    blockNum = blockNum + 1 #trial count    \u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #pupil\u000a            lpb_uadj=[] #list of unadjusted pupil samples \u000a            lpb=[]#list of adjusted pupil samples\u000a            lpb_d=[] #change in ps\u000a            ps_n1 = 0 #n-1 pupil sample\u000a            st0=0 #time between samples (st1-st0)\u000a            first_loop = True #first pupil sample\u000a            ps_dn1 = 0\u000a            ma_min = False #less than 3 samples for moving average\u000a            maV=0 #velocity\u000a             \u000a            #timing\u000a            baseline = True\u000a            Window = True #gc window\u000a            Event_draw = False #marks the zero-time in a trial\u000a            event_type='baseline' #stimulus event label\u000a            levent=[]#list of event order\u000a            lblock=[]#list of block num\u000a            ltrial=[]#list of trial num\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            lblink=[] #debug blink event\u000a            \u000a            #dummy values\u000a            old_cue = 'nan'\u000a            blank_event='nan'\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a        \u000a\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    # eyelink-gaze contingent fixation\u000a                    if eyelink.t_sample(st1,st0): #if at least 2msec between samples\u000a                        if inbox != True: #if gaze window not achived\u000a                            eyelink.gc_window()   \u000a                        #eyelink-collect pupil size\u000a                        ps_old = eyelink.pupil_sample()\u000a                        if len(lpb_uadj) >= 2:\u000a                            maV = lpb_uadj[-1]-lpb_uadj[-2]\u000a                        st0 = st1\u000a                        eyelink.t_csv(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #gc window \u000a            #if Fixation failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect baseline min max mean and stdev        \u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lpb_uadj)\u000a            #check if any pupil size during baseline collection was less than 75% of baseline mean\u000a            blink_threshold = (.75*ps_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a            \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a            event_type='stimulus' #stimulus event label\u000a            old_cue = 'nan' #dummy values for time before first cue presentation\u000a            p_ma = 'nan' #dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            stimulus_offset = 10 #time (sec)\u000a            blank_offset = 12 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            baseline = False #end of baseline samples\u000a            blink = False #blink occuring\u000a            ma_min = False #less than 3 samples for moving average\u000a            Cue = True #present cue\u000a            \u000a            #list\u000a            lblink=[] #list of blink events\u000a            levent=[] #list of event types (baseline,trial)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lps_uadj=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples\u000a            lps_d=[] #change in ps\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.t_sample(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.blink_correction(lps_uadj)\u000a                            st0 = st1\u000a                            eyelink.t_csv(IAPSClock,ps_old,ps_new)\u000a                        #if blink hasn't occured                        \u000a                        if blink != True:    \u000a                            if eyelink.t_cue(ct1,ct0): #if time between cues > 250 msec\u000a                                ct0 = ct1\u000a                                break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 2 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(lps,125,ps_min,ps_max)\u000a                    \u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a                    #output to Spyder\u000a                    print('Time = %s'%(t))\u000a                    print('Total Samples = %s'%(Total_Samples))#debug\u000a                    print('Cue Samples = %s'%(Cue_Samples))#debug\u000a                    print('Cue Color = %s'%(old_cue))#debug\u000a                    #print('Running Average = %s'%(ma))#debug\u000a                    print('min = %s, baseline mean, = %s max = %s'%(ps_min,ps_mean,ps_max))#debug\u000a                    print('CPU = %s, RAM = %s'%(cpu_s,ram_s))\u000a\u000a                if iaps_cue.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p333
sS'thisTrial'
p334
(lp335
sS'_exp'
p336
I402330128
sg10
S'Introduction_Loop'
p337
sg6
S'C:/Users/sr38553/Desktop/new task/task/6.7.03.py'
p338
sS'thisRepN'
p339
I1
sg18
I01
sg19
g20
sS'data'
p340
g1
(cpsychopy.data
DataHandler
p341
c__builtin__
dict
p342
(dp343
S'ran'
p344
cnumpy.ma.core
_mareconstruct
p345
(cnumpy.ma.core
MaskedArray
p346
cnumpy
ndarray
p347
(I0
tp348
S'b'
tRp349
(I1
(I1
I1
tg25
(S'f4'
I0
I1
tRp350
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?'
S'\x00'
NtbsS'order'
p351
g345
(g346
g347
g348
S'b'
tRp352
(I1
(I1
I1
tg350
I00
S'\x00\x00\x00\x00'
S'\x00'
NtbstRp353
(dp354
S'isNumeric'
p355
(dp356
g344
I01
sg351
I01
ssS'trials'
p357
g330
sS'dataTypes'
p358
(lp359
g344
ag351
asS'dataShape'
p360
(lp361
I1
aI1
asbsS'method'
p362
S'sequential'
p363
sS'sequenceIndices'
p364
cnumpy.core.multiarray
_reconstruct
p365
(g347
(I0
tS'b'
tRp366
(I1
(I1
I1
tg59
I00
S'\x00\x00\x00\x00'
tbsS'finished'
p367
I01
sS'nReps'
p368
I1
sS'nRemaining'
p369
I-1
sS'trialList'
p370
(lp371
g1
(cpsychopy.data
TrialType
p372
g342
(dp373
S'Introduction_image'
p374
S'inst_1'
p375
stRp376
asS'seed'
p377
NsS'thisIndex'
p378
g24
(g59
S'\x00\x00\x00\x00'
tRp379
sS'thisN'
p380
I1
sS'thisTrialN'
p381
I0
sS'nTotal'
p382
I1
sS'_warnUseOfNext'
p383
I01
sbag1
(g329
g3
NtRp384
(dp385
g332
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ps <= (1.01*ps_n1) and ps >= (.99*ps_n1):\u000a                    if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *1)\u000a        _min = _mean - (_stdev *1)\u000a        return _min,_max,_mean\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def pupil_cue(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=150) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","cue","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,\u000a                                            ltt,time_,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a    \u000a    def t_csv(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a        else:\u000a            #timing\u000a            tt = eyelink.t_tracker()#tracker time\u000a            pp_t = event.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            lblock.append(blockNum)#block\u000a            ltrial.append(trialNum)#trial\u000a            levent.append(event_type)#baseline or stimulus\u000a            ltt.append(tt)#tracker time\u000a            lpp_t.append(pp_t)#psychopy time\u000a            cpu_pc.append(cpu_s)#cpu\u000a            ram_pc.append(ram_s)#ram\u000a            lps_min.append(ps_min)#neg stdev from baseline mean\u000a            lps_mean.append(ps_mean)#baseline mean\u000a            lps_max.append(ps_max)#pos stdev from baseline mean\u000a            lps_uadj.append(ps_o)#unadjusted pupil size\u000a            lps_d.append(maV)#pupil size velocity\u000a            lps.append(ps_n)#adjusted pupil size\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blink_event) #debug\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating block count\u000a    blockNum = blockNum + 1 #trial count    \u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #pupil\u000a            lpb_uadj=[] #list of unadjusted pupil samples \u000a            lpb=[]#list of adjusted pupil samples\u000a            lpb_d=[] #change in ps\u000a            ps_n1 = 0 #n-1 pupil sample\u000a            st0=0 #time between samples (st1-st0)\u000a            first_loop = True #first pupil sample\u000a            ps_dn1 = 0\u000a            ma_min = False #less than 3 samples for moving average\u000a            maV=0 #velocity\u000a             \u000a            #timing\u000a            baseline = True\u000a            Window = True #gc window\u000a            Event_draw = False #marks the zero-time in a trial\u000a            event_type='baseline' #stimulus event label\u000a            levent=[]#list of event order\u000a            lblock=[]#list of block num\u000a            ltrial=[]#list of trial num\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            lblink=[] #debug blink event\u000a            \u000a            #dummy values\u000a            old_cue = 'nan'\u000a            blank_event='nan'\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a        \u000a\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    # eyelink-gaze contingent fixation\u000a                    if eyelink.t_sample(st1,st0): #if at least 2msec between samples\u000a                        if inbox != True: #if gaze window not achived\u000a                            eyelink.gc_window()   \u000a                        #eyelink-collect pupil size\u000a                        ps_old = eyelink.pupil_sample()\u000a                        if len(lpb_uadj) >= 2:\u000a                            maV = lpb_uadj[-1]-lpb_uadj[-2]\u000a                        st0 = st1\u000a                        eyelink.t_csv(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #gc window \u000a            #if Fixation failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect baseline min max mean and stdev        \u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lpb_uadj)\u000a            #check if any pupil size during baseline collection was less than 75% of baseline mean\u000a            blink_threshold = (.75*ps_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a            \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a            event_type='stimulus' #stimulus event label\u000a            old_cue = 'nan' #dummy values for time before first cue presentation\u000a            p_ma = 'nan' #dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            stimulus_offset = 10 #time (sec)\u000a            blank_offset = 12 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            baseline = False #end of baseline samples\u000a            blink = False #blink occuring\u000a            ma_min = False #less than 3 samples for moving average\u000a            Cue = True #present cue\u000a            \u000a            #list\u000a            lblink=[] #list of blink events\u000a            levent=[] #list of event types (baseline,trial)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lps_uadj=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples\u000a            lps_d=[] #change in ps\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.t_sample(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.blink_correction(lps_uadj)\u000a                            st0 = st1\u000a                            eyelink.t_csv(IAPSClock,ps_old,ps_new)\u000a                        #if blink hasn't occured                        \u000a                        if blink != True:    \u000a                            if eyelink.t_cue(ct1,ct0): #if time between cues > 250 msec\u000a                                ct0 = ct1\u000a                                break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 2 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(lps,125,ps_min,ps_max)\u000a                    \u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a                    #output to Spyder\u000a                    print('Time = %s'%(t))\u000a                    print('Total Samples = %s'%(Total_Samples))#debug\u000a                    print('Cue Samples = %s'%(Cue_Samples))#debug\u000a                    print('Cue Color = %s'%(old_cue))#debug\u000a                    #print('Running Average = %s'%(ma))#debug\u000a                    print('min = %s, baseline mean, = %s max = %s'%(ps_min,ps_mean,ps_max))#debug\u000a                    print('CPU = %s, RAM = %s'%(cpu_s,ram_s))\u000a\u000a                if iaps_cue.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p386
sg334
(lp387
sg336
I402330128
sg10
S'block_loop'
p388
sg6
g338
sg339
I1
sg18
I01
sg19
g20
sg340
g1
(g341
g342
(dp389
g344
g345
(g346
g347
g348
S'b'
tRp390
(I1
(I3
I1
tg350
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00'
Ntbsg14
g365
(g347
(I0
tS'b'
tRp391
(I1
(I3
I1
tg25
(S'O4'
I0
I1
tRp392
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp393
g70
ag162
ag254
atbsg351
g345
(g346
g347
g348
S'b'
tRp394
(I1
(I3
I1
tg350
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@'
S'\x00\x00\x00'
Ntbsg15
g345
(g346
g347
g348
S'b'
tRp395
(I1
(I3
I1
tg350
I00
S'9KD?\xc4\xbd\xea>6|\x87?'
S'\x00\x00\x00'
NtbstRp396
(dp397
g355
(dp398
g344
I01
sg14
I00
sg351
I01
sg15
I01
ssg357
g384
sg358
(lp399
g344
ag351
ag14
ag15
asg360
(lp400
I3
aI1
asbsg362
g363
sg364
g365
(g347
(I0
tS'b'
tRp401
(I1
(I3
I1
tg59
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00'
tbsg367
I01
sg368
I1
sg369
I-1
sg370
(lp402
g1
(g372
g342
(dp403
g40
g57
sg44
g72
sg41
g79
sg43
g76
sg42
g63
stRp404
ag1
(g372
g342
(dp405
g40
g147
sg44
g72
sg41
g172
sg43
g168
sg42
g153
stRp406
ag1
(g372
g342
(dp407
g40
g240
sg44
g256
sg41
g265
sg43
g261
sg42
g153
stRp408
asg377
Nsg378
g253
sg380
I3
sg381
I0
sg382
I3
sg383
I01
sbag1
(g329
g3
NtRp409
(dp410
g332
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ps <= (1.01*ps_n1) and ps >= (.99*ps_n1):\u000a                    if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *1)\u000a        _min = _mean - (_stdev *1)\u000a        return _min,_max,_mean\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def pupil_cue(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=150) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","cue","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,\u000a                                            ltt,time_,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a    \u000a    def t_csv(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a        else:\u000a            #timing\u000a            tt = eyelink.t_tracker()#tracker time\u000a            pp_t = event.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            lblock.append(blockNum)#block\u000a            ltrial.append(trialNum)#trial\u000a            levent.append(event_type)#baseline or stimulus\u000a            ltt.append(tt)#tracker time\u000a            lpp_t.append(pp_t)#psychopy time\u000a            cpu_pc.append(cpu_s)#cpu\u000a            ram_pc.append(ram_s)#ram\u000a            lps_min.append(ps_min)#neg stdev from baseline mean\u000a            lps_mean.append(ps_mean)#baseline mean\u000a            lps_max.append(ps_max)#pos stdev from baseline mean\u000a            lps_uadj.append(ps_o)#unadjusted pupil size\u000a            lps_d.append(maV)#pupil size velocity\u000a            lps.append(ps_n)#adjusted pupil size\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blink_event) #debug\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating block count\u000a    blockNum = blockNum + 1 #trial count    \u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #pupil\u000a            lpb_uadj=[] #list of unadjusted pupil samples \u000a            lpb=[]#list of adjusted pupil samples\u000a            lpb_d=[] #change in ps\u000a            ps_n1 = 0 #n-1 pupil sample\u000a            st0=0 #time between samples (st1-st0)\u000a            first_loop = True #first pupil sample\u000a            ps_dn1 = 0\u000a            ma_min = False #less than 3 samples for moving average\u000a            maV=0 #velocity\u000a             \u000a            #timing\u000a            baseline = True\u000a            Window = True #gc window\u000a            Event_draw = False #marks the zero-time in a trial\u000a            event_type='baseline' #stimulus event label\u000a            levent=[]#list of event order\u000a            lblock=[]#list of block num\u000a            ltrial=[]#list of trial num\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            lblink=[] #debug blink event\u000a            \u000a            #dummy values\u000a            old_cue = 'nan'\u000a            blank_event='nan'\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a        \u000a\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    # eyelink-gaze contingent fixation\u000a                    if eyelink.t_sample(st1,st0): #if at least 2msec between samples\u000a                        if inbox != True: #if gaze window not achived\u000a                            eyelink.gc_window()   \u000a                        #eyelink-collect pupil size\u000a                        ps_old = eyelink.pupil_sample()\u000a                        if len(lpb_uadj) >= 2:\u000a                            maV = lpb_uadj[-1]-lpb_uadj[-2]\u000a                        st0 = st1\u000a                        eyelink.t_csv(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #gc window \u000a            #if Fixation failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect baseline min max mean and stdev        \u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lpb_uadj)\u000a            #check if any pupil size during baseline collection was less than 75% of baseline mean\u000a            blink_threshold = (.75*ps_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a            \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a            event_type='stimulus' #stimulus event label\u000a            old_cue = 'nan' #dummy values for time before first cue presentation\u000a            p_ma = 'nan' #dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            stimulus_offset = 10 #time (sec)\u000a            blank_offset = 12 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            baseline = False #end of baseline samples\u000a            blink = False #blink occuring\u000a            ma_min = False #less than 3 samples for moving average\u000a            Cue = True #present cue\u000a            \u000a            #list\u000a            lblink=[] #list of blink events\u000a            levent=[] #list of event types (baseline,trial)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lps_uadj=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples\u000a            lps_d=[] #change in ps\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.t_sample(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.blink_correction(lps_uadj)\u000a                            st0 = st1\u000a                            eyelink.t_csv(IAPSClock,ps_old,ps_new)\u000a                        #if blink hasn't occured                        \u000a                        if blink != True:    \u000a                            if eyelink.t_cue(ct1,ct0): #if time between cues > 250 msec\u000a                                ct0 = ct1\u000a                                break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 2 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(lps,125,ps_min,ps_max)\u000a                    \u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a                    #output to Spyder\u000a                    print('Time = %s'%(t))\u000a                    print('Total Samples = %s'%(Total_Samples))#debug\u000a                    print('Cue Samples = %s'%(Cue_Samples))#debug\u000a                    print('Cue Color = %s'%(old_cue))#debug\u000a                    #print('Running Average = %s'%(ma))#debug\u000a                    print('min = %s, baseline mean, = %s max = %s'%(ps_min,ps_mean,ps_max))#debug\u000a                    print('CPU = %s, RAM = %s'%(cpu_s,ram_s))\u000a\u000a                if iaps_cue.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p411
sg334
(lp412
sg336
I402330128
sg10
S'Trial_Loop'
p413
sg6
g338
sg339
I1
sg18
I01
sg19
g20
sg340
g1
(g341
g342
(dp414
g344
g345
(g346
g347
g348
S'b'
tRp415
(I1
(I4
I1
tg350
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg351
g345
(g346
g347
g348
S'b'
tRp416
(I1
(I4
I1
tg350
I00
S'\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x80?\x00\x00@@'
S'\x00\x00\x00\x00'
NtbstRp417
(dp418
g355
(dp419
g344
I01
sg351
I01
ssg357
g409
sg358
(lp420
g344
ag351
asg360
(lp421
I4
aI1
asbsg362
S'random'
p422
sg364
g365
(g347
(I0
tS'b'
tRp423
(I1
(I4
I1
tg59
I01
S'\x01\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00'
tbsg367
I01
sg368
I1
sg369
I-1
sg370
(lp424
g1
(g372
g342
(dp425
g45
g109
sg49
g105
sg47
g98
sg48
g61
sg46
g110
sg50
g97
sg51
g103
stRp426
ag1
(g372
g342
(dp427
g45
g66
sg49
g67
sg47
g56
sg48
g61
sg46
g78
sg50
g65
sg51
g73
stRp428
ag1
(g372
g342
(dp429
g45
g94
sg49
g90
sg47
g83
sg48
g61
sg46
g78
sg50
g82
sg51
g88
stRp430
ag1
(g372
g342
(dp431
g45
g125
sg49
g121
sg47
g114
sg48
g61
sg46
g110
sg50
g113
sg51
g119
stRp432
asg377
Nsg378
g117
sg380
I4
sg381
I0
sg382
I4
sg383
I01
sbag1
(g329
g3
NtRp433
(dp434
g332
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ps <= (1.01*ps_n1) and ps >= (.99*ps_n1):\u000a                    if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *1)\u000a        _min = _mean - (_stdev *1)\u000a        return _min,_max,_mean\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def pupil_cue(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=150) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","cue","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,\u000a                                            ltt,time_,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a    \u000a    def t_csv(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a        else:\u000a            #timing\u000a            tt = eyelink.t_tracker()#tracker time\u000a            pp_t = event.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            lblock.append(blockNum)#block\u000a            ltrial.append(trialNum)#trial\u000a            levent.append(event_type)#baseline or stimulus\u000a            ltt.append(tt)#tracker time\u000a            lpp_t.append(pp_t)#psychopy time\u000a            cpu_pc.append(cpu_s)#cpu\u000a            ram_pc.append(ram_s)#ram\u000a            lps_min.append(ps_min)#neg stdev from baseline mean\u000a            lps_mean.append(ps_mean)#baseline mean\u000a            lps_max.append(ps_max)#pos stdev from baseline mean\u000a            lps_uadj.append(ps_o)#unadjusted pupil size\u000a            lps_d.append(maV)#pupil size velocity\u000a            lps.append(ps_n)#adjusted pupil size\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blink_event) #debug\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating block count\u000a    blockNum = blockNum + 1 #trial count    \u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #pupil\u000a            lpb_uadj=[] #list of unadjusted pupil samples \u000a            lpb=[]#list of adjusted pupil samples\u000a            lpb_d=[] #change in ps\u000a            ps_n1 = 0 #n-1 pupil sample\u000a            st0=0 #time between samples (st1-st0)\u000a            first_loop = True #first pupil sample\u000a            ps_dn1 = 0\u000a            ma_min = False #less than 3 samples for moving average\u000a            maV=0 #velocity\u000a             \u000a            #timing\u000a            baseline = True\u000a            Window = True #gc window\u000a            Event_draw = False #marks the zero-time in a trial\u000a            event_type='baseline' #stimulus event label\u000a            levent=[]#list of event order\u000a            lblock=[]#list of block num\u000a            ltrial=[]#list of trial num\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            lblink=[] #debug blink event\u000a            \u000a            #dummy values\u000a            old_cue = 'nan'\u000a            blank_event='nan'\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a        \u000a\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    # eyelink-gaze contingent fixation\u000a                    if eyelink.t_sample(st1,st0): #if at least 2msec between samples\u000a                        if inbox != True: #if gaze window not achived\u000a                            eyelink.gc_window()   \u000a                        #eyelink-collect pupil size\u000a                        ps_old = eyelink.pupil_sample()\u000a                        if len(lpb_uadj) >= 2:\u000a                            maV = lpb_uadj[-1]-lpb_uadj[-2]\u000a                        st0 = st1\u000a                        eyelink.t_csv(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #gc window \u000a            #if Fixation failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect baseline min max mean and stdev        \u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lpb_uadj)\u000a            #check if any pupil size during baseline collection was less than 75% of baseline mean\u000a            blink_threshold = (.75*ps_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a            \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a            event_type='stimulus' #stimulus event label\u000a            old_cue = 'nan' #dummy values for time before first cue presentation\u000a            p_ma = 'nan' #dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            stimulus_offset = 10 #time (sec)\u000a            blank_offset = 12 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            baseline = False #end of baseline samples\u000a            blink = False #blink occuring\u000a            ma_min = False #less than 3 samples for moving average\u000a            Cue = True #present cue\u000a            \u000a            #list\u000a            lblink=[] #list of blink events\u000a            levent=[] #list of event types (baseline,trial)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lps_uadj=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples\u000a            lps_d=[] #change in ps\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.t_sample(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.blink_correction(lps_uadj)\u000a                            st0 = st1\u000a                            eyelink.t_csv(IAPSClock,ps_old,ps_new)\u000a                        #if blink hasn't occured                        \u000a                        if blink != True:    \u000a                            if eyelink.t_cue(ct1,ct0): #if time between cues > 250 msec\u000a                                ct0 = ct1\u000a                                break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 2 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(lps,125,ps_min,ps_max)\u000a                    \u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a                    #output to Spyder\u000a                    print('Time = %s'%(t))\u000a                    print('Total Samples = %s'%(Total_Samples))#debug\u000a                    print('Cue Samples = %s'%(Cue_Samples))#debug\u000a                    print('Cue Color = %s'%(old_cue))#debug\u000a                    #print('Running Average = %s'%(ma))#debug\u000a                    print('min = %s, baseline mean, = %s max = %s'%(ps_min,ps_mean,ps_max))#debug\u000a                    print('CPU = %s, RAM = %s'%(cpu_s,ram_s))\u000a\u000a                if iaps_cue.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p435
sg334
(lp436
sg336
I402330128
sg10
S'Break_loop'
p437
sg6
g338
sg339
I1
sg18
I01
sg19
g20
sg340
g1
(g341
g342
(dp438
g344
g345
(g346
g347
g348
S'b'
tRp439
(I1
(I1
I1
tg350
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg17
g345
(g346
g347
g348
S'b'
tRp440
(I1
(I1
I1
tg350
I00
S'\xa3\x0fI@'
S'\x00'
Ntbsg351
g345
(g346
g347
g348
S'b'
tRp441
(I1
(I1
I1
tg350
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g365
(g347
(I0
tS'b'
tRp442
(I1
(I1
I1
tg392
I00
(lp443
g130
atbstRp444
(dp445
g355
(dp446
g344
I01
sg17
I01
sg351
I01
sg16
I00
ssg357
g433
sg358
(lp447
g344
ag351
ag16
ag17
asg360
(lp448
I1
aI1
asbsg362
g422
sg364
g365
(g347
(I0
tS'b'
tRp449
(I1
(I1
I1
tg59
I00
S'\x00\x00\x00\x00'
tbsg367
I01
sg368
I1
sg369
I-1
sg370
(lp450
Nasg377
Nsg378
g134
sg380
I1
sg381
I0
sg382
I1
sg383
I01
sbag1
(g329
g3
NtRp451
(dp452
g332
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ps <= (1.01*ps_n1) and ps >= (.99*ps_n1):\u000a                    if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *1)\u000a        _min = _mean - (_stdev *1)\u000a        return _min,_max,_mean\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def pupil_cue(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=150) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","cue","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,\u000a                                            ltt,time_,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a    \u000a    def t_csv(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a        else:\u000a            #timing\u000a            tt = eyelink.t_tracker()#tracker time\u000a            pp_t = event.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            lblock.append(blockNum)#block\u000a            ltrial.append(trialNum)#trial\u000a            levent.append(event_type)#baseline or stimulus\u000a            ltt.append(tt)#tracker time\u000a            lpp_t.append(pp_t)#psychopy time\u000a            cpu_pc.append(cpu_s)#cpu\u000a            ram_pc.append(ram_s)#ram\u000a            lps_min.append(ps_min)#neg stdev from baseline mean\u000a            lps_mean.append(ps_mean)#baseline mean\u000a            lps_max.append(ps_max)#pos stdev from baseline mean\u000a            lps_uadj.append(ps_o)#unadjusted pupil size\u000a            lps_d.append(maV)#pupil size velocity\u000a            lps.append(ps_n)#adjusted pupil size\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blink_event) #debug\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating block count\u000a    blockNum = blockNum + 1 #trial count    \u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #pupil\u000a            lpb_uadj=[] #list of unadjusted pupil samples \u000a            lpb=[]#list of adjusted pupil samples\u000a            lpb_d=[] #change in ps\u000a            ps_n1 = 0 #n-1 pupil sample\u000a            st0=0 #time between samples (st1-st0)\u000a            first_loop = True #first pupil sample\u000a            ps_dn1 = 0\u000a            ma_min = False #less than 3 samples for moving average\u000a            maV=0 #velocity\u000a             \u000a            #timing\u000a            baseline = True\u000a            Window = True #gc window\u000a            Event_draw = False #marks the zero-time in a trial\u000a            event_type='baseline' #stimulus event label\u000a            levent=[]#list of event order\u000a            lblock=[]#list of block num\u000a            ltrial=[]#list of trial num\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            lblink=[] #debug blink event\u000a            \u000a            #dummy values\u000a            old_cue = 'nan'\u000a            blank_event='nan'\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a        \u000a\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    # eyelink-gaze contingent fixation\u000a                    if eyelink.t_sample(st1,st0): #if at least 2msec between samples\u000a                        if inbox != True: #if gaze window not achived\u000a                            eyelink.gc_window()   \u000a                        #eyelink-collect pupil size\u000a                        ps_old = eyelink.pupil_sample()\u000a                        if len(lpb_uadj) >= 2:\u000a                            maV = lpb_uadj[-1]-lpb_uadj[-2]\u000a                        st0 = st1\u000a                        eyelink.t_csv(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #gc window \u000a            #if Fixation failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect baseline min max mean and stdev        \u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lpb_uadj)\u000a            #check if any pupil size during baseline collection was less than 75% of baseline mean\u000a            blink_threshold = (.75*ps_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a            \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a            event_type='stimulus' #stimulus event label\u000a            old_cue = 'nan' #dummy values for time before first cue presentation\u000a            p_ma = 'nan' #dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            stimulus_offset = 10 #time (sec)\u000a            blank_offset = 12 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            baseline = False #end of baseline samples\u000a            blink = False #blink occuring\u000a            ma_min = False #less than 3 samples for moving average\u000a            Cue = True #present cue\u000a            \u000a            #list\u000a            lblink=[] #list of blink events\u000a            levent=[] #list of event types (baseline,trial)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lps_uadj=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples\u000a            lps_d=[] #change in ps\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.t_sample(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.blink_correction(lps_uadj)\u000a                            st0 = st1\u000a                            eyelink.t_csv(IAPSClock,ps_old,ps_new)\u000a                        #if blink hasn't occured                        \u000a                        if blink != True:    \u000a                            if eyelink.t_cue(ct1,ct0): #if time between cues > 250 msec\u000a                                ct0 = ct1\u000a                                break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 2 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(lps,125,ps_min,ps_max)\u000a                    \u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a                    #output to Spyder\u000a                    print('Time = %s'%(t))\u000a                    print('Total Samples = %s'%(Total_Samples))#debug\u000a                    print('Cue Samples = %s'%(Cue_Samples))#debug\u000a                    print('Cue Color = %s'%(old_cue))#debug\u000a                    #print('Running Average = %s'%(ma))#debug\u000a                    print('min = %s, baseline mean, = %s max = %s'%(ps_min,ps_mean,ps_max))#debug\u000a                    print('CPU = %s, RAM = %s'%(cpu_s,ram_s))\u000a\u000a                if iaps_cue.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p453
sg334
(lp454
sg336
I402330128
sg10
g413
sg6
g338
sg339
I1
sg18
I01
sg19
g20
sg340
g1
(g341
g342
(dp455
g344
g345
(g346
g347
g348
S'b'
tRp456
(I1
(I4
I1
tg350
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg351
g345
(g346
g347
g348
S'b'
tRp457
(I1
(I4
I1
tg350
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@'
S'\x00\x00\x00\x00'
NtbstRp458
(dp459
g355
(dp460
g344
I01
sg351
I01
ssg357
g451
sg358
(lp461
g344
ag351
asg360
(lp462
I4
aI1
asbsg362
g422
sg364
g365
(g347
(I0
tS'b'
tRp463
(I1
(I4
I1
tg59
I01
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'
tbsg367
I01
sg368
I1
sg369
I-1
sg370
(lp464
g1
(g372
g342
(dp465
g156
g157
sg158
g159
sg145
g146
sg150
g151
sg170
g171
sg154
g155
sg164
g165
stRp466
ag1
(g372
g342
(dp467
g156
g187
sg158
g183
sg145
g176
sg150
g151
sg170
g188
sg154
g175
sg164
g181
stRp468
ag1
(g372
g342
(dp469
g156
g203
sg158
g199
sg145
g192
sg150
g151
sg170
g171
sg154
g191
sg164
g197
stRp470
ag1
(g372
g342
(dp471
g156
g218
sg158
g214
sg145
g207
sg150
g151
sg170
g188
sg154
g206
sg164
g212
stRp472
asg377
Nsg378
g210
sg380
I4
sg381
I0
sg382
I4
sg383
I01
sbag1
(g329
g3
NtRp473
(dp474
g332
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ps <= (1.01*ps_n1) and ps >= (.99*ps_n1):\u000a                    if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *1)\u000a        _min = _mean - (_stdev *1)\u000a        return _min,_max,_mean\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def pupil_cue(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=150) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","cue","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,\u000a                                            ltt,time_,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a    \u000a    def t_csv(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a        else:\u000a            #timing\u000a            tt = eyelink.t_tracker()#tracker time\u000a            pp_t = event.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            lblock.append(blockNum)#block\u000a            ltrial.append(trialNum)#trial\u000a            levent.append(event_type)#baseline or stimulus\u000a            ltt.append(tt)#tracker time\u000a            lpp_t.append(pp_t)#psychopy time\u000a            cpu_pc.append(cpu_s)#cpu\u000a            ram_pc.append(ram_s)#ram\u000a            lps_min.append(ps_min)#neg stdev from baseline mean\u000a            lps_mean.append(ps_mean)#baseline mean\u000a            lps_max.append(ps_max)#pos stdev from baseline mean\u000a            lps_uadj.append(ps_o)#unadjusted pupil size\u000a            lps_d.append(maV)#pupil size velocity\u000a            lps.append(ps_n)#adjusted pupil size\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blink_event) #debug\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating block count\u000a    blockNum = blockNum + 1 #trial count    \u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #pupil\u000a            lpb_uadj=[] #list of unadjusted pupil samples \u000a            lpb=[]#list of adjusted pupil samples\u000a            lpb_d=[] #change in ps\u000a            ps_n1 = 0 #n-1 pupil sample\u000a            st0=0 #time between samples (st1-st0)\u000a            first_loop = True #first pupil sample\u000a            ps_dn1 = 0\u000a            ma_min = False #less than 3 samples for moving average\u000a            maV=0 #velocity\u000a             \u000a            #timing\u000a            baseline = True\u000a            Window = True #gc window\u000a            Event_draw = False #marks the zero-time in a trial\u000a            event_type='baseline' #stimulus event label\u000a            levent=[]#list of event order\u000a            lblock=[]#list of block num\u000a            ltrial=[]#list of trial num\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            lblink=[] #debug blink event\u000a            \u000a            #dummy values\u000a            old_cue = 'nan'\u000a            blank_event='nan'\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a        \u000a\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    # eyelink-gaze contingent fixation\u000a                    if eyelink.t_sample(st1,st0): #if at least 2msec between samples\u000a                        if inbox != True: #if gaze window not achived\u000a                            eyelink.gc_window()   \u000a                        #eyelink-collect pupil size\u000a                        ps_old = eyelink.pupil_sample()\u000a                        if len(lpb_uadj) >= 2:\u000a                            maV = lpb_uadj[-1]-lpb_uadj[-2]\u000a                        st0 = st1\u000a                        eyelink.t_csv(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #gc window \u000a            #if Fixation failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect baseline min max mean and stdev        \u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lpb_uadj)\u000a            #check if any pupil size during baseline collection was less than 75% of baseline mean\u000a            blink_threshold = (.75*ps_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a            \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a            event_type='stimulus' #stimulus event label\u000a            old_cue = 'nan' #dummy values for time before first cue presentation\u000a            p_ma = 'nan' #dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            stimulus_offset = 10 #time (sec)\u000a            blank_offset = 12 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            baseline = False #end of baseline samples\u000a            blink = False #blink occuring\u000a            ma_min = False #less than 3 samples for moving average\u000a            Cue = True #present cue\u000a            \u000a            #list\u000a            lblink=[] #list of blink events\u000a            levent=[] #list of event types (baseline,trial)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lps_uadj=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples\u000a            lps_d=[] #change in ps\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.t_sample(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.blink_correction(lps_uadj)\u000a                            st0 = st1\u000a                            eyelink.t_csv(IAPSClock,ps_old,ps_new)\u000a                        #if blink hasn't occured                        \u000a                        if blink != True:    \u000a                            if eyelink.t_cue(ct1,ct0): #if time between cues > 250 msec\u000a                                ct0 = ct1\u000a                                break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 2 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(lps,125,ps_min,ps_max)\u000a                    \u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a                    #output to Spyder\u000a                    print('Time = %s'%(t))\u000a                    print('Total Samples = %s'%(Total_Samples))#debug\u000a                    print('Cue Samples = %s'%(Cue_Samples))#debug\u000a                    print('Cue Color = %s'%(old_cue))#debug\u000a                    #print('Running Average = %s'%(ma))#debug\u000a                    print('min = %s, baseline mean, = %s max = %s'%(ps_min,ps_mean,ps_max))#debug\u000a                    print('CPU = %s, RAM = %s'%(cpu_s,ram_s))\u000a\u000a                if iaps_cue.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p475
sg334
(lp476
sg336
I402330128
sg10
g437
sg6
g338
sg339
I1
sg18
I01
sg19
g20
sg340
g1
(g341
g342
(dp477
g344
g345
(g346
g347
g348
S'b'
tRp478
(I1
(I1
I1
tg350
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg17
g345
(g346
g347
g348
S'b'
tRp479
(I1
(I1
I1
tg350
I00
S'GY\xa5?'
S'\x00'
Ntbsg351
g345
(g346
g347
g348
S'b'
tRp480
(I1
(I1
I1
tg350
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g365
(g347
(I0
tS'b'
tRp481
(I1
(I1
I1
tg392
I00
(lp482
g223
atbstRp483
(dp484
g355
(dp485
g344
I01
sg17
I01
sg351
I01
sg16
I00
ssg357
g473
sg358
(lp486
g344
ag351
ag16
ag17
asg360
(lp487
I1
aI1
asbsg362
g422
sg364
g365
(g347
(I0
tS'b'
tRp488
(I1
(I1
I1
tg59
I00
S'\x00\x00\x00\x00'
tbsg367
I01
sg368
I1
sg369
I-1
sg370
(lp489
Nasg377
Nsg378
g227
sg380
I1
sg381
I0
sg382
I1
sg383
I01
sbag1
(g329
g3
NtRp490
(dp491
g332
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ps <= (1.01*ps_n1) and ps >= (.99*ps_n1):\u000a                    if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *1)\u000a        _min = _mean - (_stdev *1)\u000a        return _min,_max,_mean\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def pupil_cue(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=150) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","cue","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,\u000a                                            ltt,time_,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a    \u000a    def t_csv(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a        else:\u000a            #timing\u000a            tt = eyelink.t_tracker()#tracker time\u000a            pp_t = event.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            lblock.append(blockNum)#block\u000a            ltrial.append(trialNum)#trial\u000a            levent.append(event_type)#baseline or stimulus\u000a            ltt.append(tt)#tracker time\u000a            lpp_t.append(pp_t)#psychopy time\u000a            cpu_pc.append(cpu_s)#cpu\u000a            ram_pc.append(ram_s)#ram\u000a            lps_min.append(ps_min)#neg stdev from baseline mean\u000a            lps_mean.append(ps_mean)#baseline mean\u000a            lps_max.append(ps_max)#pos stdev from baseline mean\u000a            lps_uadj.append(ps_o)#unadjusted pupil size\u000a            lps_d.append(maV)#pupil size velocity\u000a            lps.append(ps_n)#adjusted pupil size\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blink_event) #debug\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating block count\u000a    blockNum = blockNum + 1 #trial count    \u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #pupil\u000a            lpb_uadj=[] #list of unadjusted pupil samples \u000a            lpb=[]#list of adjusted pupil samples\u000a            lpb_d=[] #change in ps\u000a            ps_n1 = 0 #n-1 pupil sample\u000a            st0=0 #time between samples (st1-st0)\u000a            first_loop = True #first pupil sample\u000a            ps_dn1 = 0\u000a            ma_min = False #less than 3 samples for moving average\u000a            maV=0 #velocity\u000a             \u000a            #timing\u000a            baseline = True\u000a            Window = True #gc window\u000a            Event_draw = False #marks the zero-time in a trial\u000a            event_type='baseline' #stimulus event label\u000a            levent=[]#list of event order\u000a            lblock=[]#list of block num\u000a            ltrial=[]#list of trial num\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            lblink=[] #debug blink event\u000a            \u000a            #dummy values\u000a            old_cue = 'nan'\u000a            blank_event='nan'\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a        \u000a\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    # eyelink-gaze contingent fixation\u000a                    if eyelink.t_sample(st1,st0): #if at least 2msec between samples\u000a                        if inbox != True: #if gaze window not achived\u000a                            eyelink.gc_window()   \u000a                        #eyelink-collect pupil size\u000a                        ps_old = eyelink.pupil_sample()\u000a                        if len(lpb_uadj) >= 2:\u000a                            maV = lpb_uadj[-1]-lpb_uadj[-2]\u000a                        st0 = st1\u000a                        eyelink.t_csv(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #gc window \u000a            #if Fixation failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect baseline min max mean and stdev        \u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lpb_uadj)\u000a            #check if any pupil size during baseline collection was less than 75% of baseline mean\u000a            blink_threshold = (.75*ps_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a            \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a            event_type='stimulus' #stimulus event label\u000a            old_cue = 'nan' #dummy values for time before first cue presentation\u000a            p_ma = 'nan' #dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            stimulus_offset = 10 #time (sec)\u000a            blank_offset = 12 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            baseline = False #end of baseline samples\u000a            blink = False #blink occuring\u000a            ma_min = False #less than 3 samples for moving average\u000a            Cue = True #present cue\u000a            \u000a            #list\u000a            lblink=[] #list of blink events\u000a            levent=[] #list of event types (baseline,trial)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lps_uadj=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples\u000a            lps_d=[] #change in ps\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.t_sample(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.blink_correction(lps_uadj)\u000a                            st0 = st1\u000a                            eyelink.t_csv(IAPSClock,ps_old,ps_new)\u000a                        #if blink hasn't occured                        \u000a                        if blink != True:    \u000a                            if eyelink.t_cue(ct1,ct0): #if time between cues > 250 msec\u000a                                ct0 = ct1\u000a                                break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 2 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(lps,125,ps_min,ps_max)\u000a                    \u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a                    #output to Spyder\u000a                    print('Time = %s'%(t))\u000a                    print('Total Samples = %s'%(Total_Samples))#debug\u000a                    print('Cue Samples = %s'%(Cue_Samples))#debug\u000a                    print('Cue Color = %s'%(old_cue))#debug\u000a                    #print('Running Average = %s'%(ma))#debug\u000a                    print('min = %s, baseline mean, = %s max = %s'%(ps_min,ps_mean,ps_max))#debug\u000a                    print('CPU = %s, RAM = %s'%(cpu_s,ram_s))\u000a\u000a                if iaps_cue.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p492
sg334
(lp493
sg336
I402330128
sg10
g413
sg6
g338
sg339
I1
sg18
I01
sg19
g20
sg340
g1
(g341
g342
(dp494
g344
g345
(g346
g347
g348
S'b'
tRp495
(I1
(I4
I1
tg350
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00'
Ntbsg351
g345
(g346
g347
g348
S'b'
tRp496
(I1
(I4
I1
tg350
I00
S'\x00\x00\x00@\x00\x00@@\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00'
NtbstRp497
(dp498
g355
(dp499
g344
I01
sg351
I01
ssg357
g490
sg358
(lp500
g344
ag351
asg360
(lp501
I4
aI1
asbsg362
g422
sg364
g365
(g347
(I0
tS'b'
tRp502
(I1
(I4
I1
tg59
I01
S'\x02\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00'
tbsg367
I01
sg368
I1
sg369
I-1
sg370
(lp503
g1
(g372
g342
(dp504
g248
g295
sg250
g291
sg238
g284
sg243
g244
sg263
g264
sg246
g283
sg257
g289
stRp505
ag1
(g372
g342
(dp506
g248
g310
sg250
g306
sg238
g299
sg243
g244
sg263
g264
sg246
g298
sg257
g304
stRp507
ag1
(g372
g342
(dp508
g248
g249
sg250
g251
sg238
g239
sg243
g244
sg263
g264
sg246
g247
sg257
g258
stRp509
ag1
(g372
g342
(dp510
g248
g280
sg250
g276
sg238
g269
sg243
g244
sg263
g264
sg246
g268
sg257
g274
stRp511
asg377
Nsg378
g302
sg380
I4
sg381
I0
sg382
I4
sg383
I01
sbag1
(g329
g3
NtRp512
(dp513
g332
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.83.04), April 26, 2016, at 11:02\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a\u000a\u000aArticles:\u000aUsing Eye tracking technology to study the effects of cognition on pupil size\u000aPupillometry A Window to the Preconscious?\u000aThe pupillary light response reflects exogenous attention and inhibition of return\u000a\u000a6.7.03 (6/23)\u000achanges:\u000a    critical\u000a    - Removed Block level fixation. Sticking with trial fixation\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a    \u000a    efficency\u000a    - created functions for: list appending, csv updates. this will prevent changes to be missed between fixation and stimulus code\u000a    - changed duration of stimulus presentation to 10 sec. prevent fatigue\u000a\u000ato do:\u000a    - automating delay of stimulus onset until 1 sec of blink-free fixation occured\u000a    - Improve overcorrecting non-blink events (dips in blink onset)\u000a\u000a\u000ato include in later update:\u000a    - progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000a\u000a\u000a\u000a6.7.02 (6/9)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000ato change\u000a\u000aadded\u000a- include pupil and corneal keyboard commands in experimental computer\u000a- clean up of obsolete confusing variables\u000a- collect samples during entire 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- updated min_max to use numpy insted of python.statistics: improved speed\u000a- added baseline pupil sizes, event label to CSV output\u000a\u000a6.7.01 (6/6)\u000ato include in later update\u000a- progressive change in cue threshold, contigent on performance in green_cue during block\u000a    - if cue_green > .8:\u000a        next_sd_multiplier = sd_multiplier/2\u000a\u000ato do here\u000a- filter blink presence out of task\u000a\u000achanges\u000a- lower intensity of color (from .5 to .25)\u000a- collect samples during 5 sec baseline\u000a- delay cue onset until 2 sec after stimulus onset\u000a- change moving average to 10 sample window\u000a- change moving average from moving_median to moving_mean\u000a\u000aput back\u000a- turned off drift_correct and cue\u000a\u000a6.6.03 (5/23)\u000aupdates\u000a- output trial data for comparison with eyelink recordings (cross-validate)\u000a- output baseline data for comparison with eyelink recordings (cross-validate)\u000a- removed neutral images \u000a- added composite image\u000a    * Use composite image once per block to collect baseline\u000a    * this will serve as baseline pupil size\u000a- started blink detection (pupil_samplexy)\u000ato do\u000a- Task:\u000a    - drop pupil size recording if gaze is not detected and in stimulus window\u000a    - find filtering technique for blinks (wait for chris email)\u000a    - possible solution:\u000a        - try to somehow get possible mininum and maxinum pupil size and drop values that are outside of this range before each cue presentation\u000a        - if gaze is non-existant drop value\u000a- Block:\u000a    - record baseline for last 1000ms\u000a\u000asee:for more information on blink and online data: https://www.sr-support.com/showthread.php?4845-Plotting-the-change-in-pupil-size-throughout-the-trial&highlight=blink \u000a\u000a6.6.02 (5/18)\u000aupdates\u000a- updated instructions to be task relevant\u000a- improved instruction image quality \u000a\u000ato do\u000a- automatic calibration after 2x failed drift correct\u000a- test timing of new iaps onset message +\u000a- test dropping of samples (50%)\u000a- test if working: mouse pointer disappear\u000a- test if working: final break screen dissapears and ends task +\u000a- test: accuracy of all collected variables (e.g. time, pupil size, pupil mean, pupil moving average.....)\u000a- fix: correct save time for edf files\u000a\u000a6.6.01 (5/17)\u000a- task uses moving median instead of moving average\u000a- stimulus display is 20sec\u000a- cue shift is in intervals of 250msec\u000a- isoluminant baseline is -250msec after stimulus onset\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'CGP'  # from the Builder filename that created this script\u000aexpInfo = {u'Participant': u'001',u'Dominant Eye': u'Right'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + '_data/csv/%s_%s' %(expInfo['Participant'],expName)\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.DEBUG)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000aNOT_STARTED = 0\u000aPLAYING = 1\u000aSTARTED = PLAYING\u000aPAUSED = 2\u000aSTOPPED = -1\u000aFINISHED = STOPPED\u000a\u000a# Setup the Window\u000awin = visual.Window(size=[1920, 1080], fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='Experiment', color=[-0.137,-0.137,-0.137], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='pix')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "Calibration_Verification"\u000aCalibration_VerificationClock = core.Clock()\u000a\u000a#eye tracking\u000aimport pylink\u000afrom _script import eyelink_display\u000a#os\u000afrom win32api import GetSystemMetrics\u000aimport time\u000aimport re\u000a#visual\u000afrom PIL import Image\u000a#analysis\u000aimport pandas\u000aimport numpy as np\u000aimport csv\u000aimport itertools\u000aimport scipy.ndimage\u000a#hardware\u000afrom psychopy.hardware import joystick\u000a#for debugging\u000afrom pycallgraph import PyCallGraph\u000afrom pycallgraph.output import GraphvizOutput\u000aimport psutil\u000a\u000a#mouse invisible\u000awin.mouseVisible = False\u000a\u000a#constants\u000atrialNum = 0\u000ablockNum = 0\u000aheader = True #if header doesn't exist - used for outputing pupil samples\u000a\u000aclass libeyelink():\u000a    def __init__(self,edfsubject):\u000a        # Make filename\u000a        self.fname = os.path.splitext(edfsubject)[0]  # strip away extension if present\u000a        assert re.match(r'\u005cw+$', self.fname), 'Name must only include A-Z, 0-9, or _'\u000a        assert len(self.fname) <= 8, 'Name must be <= 8 characters.'\u000a        # Make filename \u000a        self.edfname = self.fname + '.edf'\u000a    \u000a        # Initialize connection with eyetracker\u000a        try:\u000a            self.tracker = pylink.EyeLink()\u000a            self.realconnect = True\u000a        except RuntimeError:\u000a            self.tracker = pylink.EyeLink(None)\u000a            self.realconnect = False\u000a        \u000a        #properties\u000a        #screen\u000a        self.w = GetSystemMetrics(0)\u000a        self.h = GetSystemMetrics(1)        \u000a        #find out which eye\u000a        self.left_eye = 0\u000a        self.right_eye = 1    \u000a        #gaze-timing\u000a        self.GCWINDOW = .5 #500 msec\u000a        self.DURATION = 2 #2000 msec\u000a        self.gbox = 200 #gaze boundary\u000a        self.inbox = False\u000a        self.Finished = False     \u000a        #gaze-bounding box\u000a        self.sc = [self.w / 2.0, self.h / 2.0] #center of screen\u000a        self.size = 100 #Length of one side of box\u000a        self.xbdr = [self.sc[0] - self.size, self.sc[0] + self.size]\u000a        self.ybdr = [self.sc[1] - self.size, self.sc[1] + self.size]\u000a        #calibration\u000a        self.cnum = 13 # 13 pt calibration\u000a        self.paval = 1000 #Pacing of calibration, t in milliseconds        \u000a        #pupil\u000a        self.red = 'red'\u000a        self.green = 'green'\u000a        self.blue = 'blue'\u000a        \u000a        # Open EDF\u000a        pylink.getEYELINK().openDataFile(self.edfname)\u000a        pylink.flushGetkeyQueue()\u000a\u000a        # notify eyelink of display resolution        \u000a        pylink.getEYELINK().sendCommand("screen_pixel_coords =  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        pylink.getEYELINK().sendMessage("DISPLAY_COORDS  0 0 %d %d" %(self.w - 1, self.h - 1))\u000a        \u000a        # Set content of edf file\u000a        pylink.getEYELINK().sendCommand(\u000a            'file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT')        \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'link_sample_data = LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,HTARGET')    \u000a        pylink.getEYELINK().sendCommand(\u000a            'file_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES,STATUS,HTARGET,INPUT')\u000a        \u000a        #select sound for calibration and drift correct\u000a        pylink.setCalibrationSounds("off", "off", "off")\u000a        pylink.setDriftCorrectSounds("off", "off", "off")\u000a\u000a        #Places EyeLink tracker in offline (idle) mode        \u000a        pylink.getEYELINK().setOfflineMode()\u000a\u000a    def blink_correction(self,lst):\u000a        global ps_n1 #n-1 pupil sample\u000a        global ps_old #ps without changes\u000a        global maV #1st derivative of pupil area\u000a        global ma_min #there are more than 3 samples\u000a        global lma #moving average list\u000a        global blink\u000a        global blink_event\u000a        win = 20 #moving average window\u000a        #collect pupil sample, save unaltered (ps_old)\u000a        ps = ps_old = self.pupil_sample()\u000a          \u000a        #if sample > 3:\u000a        if len(lst) > 4:\u000a            #more than enough samples\u000a            if ma_min:\u000a                lma = self.moving_avg(lst,win) #moving average \u000a                maV = lst[-1]-lst[-2] #1st derivative of pupil area (velocity)\u000a                #if not blinking\u000a                if blink != True:\u000a                    #check if blink started\u000a                    if ps <= (.98*lst[-1]) and ps <= (.98*lma[-1]):\u000a                        blink = True #blink started\u000a                        blink_event = 'blink_start' #debug #create variable for csv\u000a                        return ps_n1\u000a                    #not blinking\u000a                    else:\u000a                        ps_n1 = ps #update ps n-1\u000a                        return ps\u000a                #after blink started\u000a                else:\u000a                    #if pupil size has returned to pre-blinking state\u000a                    #if ps <= (1.01*ps_n1) and ps >= (.99*ps_n1):\u000a                    if ((ps <= (1.02*ps_n1)) and (ps >= (.98*ps_n1))) and (maV < 1 and maV >= -1):\u000a                        blink = False\u000a                        blink_event = 'blink_end' #debug #create variable for csv\u000a                        return ps_n1\u000a                    else:\u000a                        return ps_n1\u000a            #too few samples\u000a            else:\u000a                #check if samples > moving average window\u000a                if len(lst) > (win+3):\u000a                    ma_min = True\u000a                    ps_n1 = ps\u000a                    return ps\u000a                #less than 3 samples\u000a                else:\u000a                    ps_n1 = ps\u000a                    return ps\u000a        #collect inital samples\u000a        else:\u000a            ps_n1 = ps \u000a            return ps\u000a    \u000a    def calibrate(self):\u000a        """\u000a        Calibrates eyetracker using psychopy stimuli.\u000a        """\u000a        if DC>=2: #if drift correct failed 3 times in a row\u000a            pylink.getEYELINK().sendMessage("Drift_failed") #send failure message\u000a            self.stop_recording()\u000a        \u000a        if self.realconnect:\u000a            # Generate custom calibration stimuli\u000a            self.genv = eyelink_display.calibration_display(self.w,self.h,self.tracker,win)\u000a             \u000a            pylink.getEYELINK().setCalibrationType('HV%d'%(self.cnum))# Set calibration type\u000a            pylink.getEYELINK().setAutoCalibrationPacing(self.paval)# Set calibraiton pacing\u000a            pylink.openGraphicsEx(self.genv)# Execute custom calibration display\u000a            pylink.getEYELINK().doTrackerSetup(self.w, self.h)# Calibrate\u000a\u000a    def close(self,spath):\u000a        # Generate file path\u000a        self.fpath = os.path.join(spath, self.edfname)\u000a        \u000a        # Close the file and transfer it to Display PC\u000a        pylink.endRealTimeMode()\u000a        pylink.getEYELINK().closeDataFile()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().receiveDataFile(self.edfname, self.fpath) #copy EDF file to Display PC\u000a        pylink.getEYELINK().close() #Close connection to tracker\u000a  \u000a    def gc_window(self):\u000a        global inbox\u000a        global GAZE\u000a        global Fixation\u000a        global gaze_timer\u000a        #check for new sample update\u000a        dt = pylink.getEYELINK().getNewestSample() \u000a        if(dt != None): # Gets the gaze position of the latest sample\u000a            if eye_used == self.right_eye:\u000a                gx,gy = dt.getRightEye().getGaze()\u000a            else:\u000a                gx,gy = dt.getLeftEye().getGaze()\u000a    \u000a        if self.xbdr[0] < gx < self.xbdr[1] and self.ybdr[0] < gy < self.ybdr[1]: #is gaze congingent fixation within the update region\u000a            if (time.clock() - gaze_timer) > self.GCWINDOW: #if YES: compare current time and gcwindow onset against GCDURATION\u000a                pylink.getEYELINK().sendMessage('WindowOffset')\u000a                print('window finished = %s'%(FixationClock.getTime()))\u000a                inbox = True\u000a                GAZE = True #allows skipping of gc_drift()\u000a                Fixation = False\u000a        else:\u000a            gaze_timer = time.clock()\u000a    \u000a    def gc_drift_correct(self):\u000a        pylink.getEYELINK().sendMessage("Fixation_failed") #send failure message\u000a        self.stop_recording()\u000a        pylink.getEYELINK().doDriftCorrect(int(self.sc[0]), int(self.sc[1]), 0, 0)\u000a\u000a    def min_max(self,lst):\u000a        lps_array = np.array(lst)\u000a        _mean = np.mean(lps_array)\u000a        _stdev = np.std(lps_array, axis=0, ddof=1) #sample population stdev\u000a        _max = _mean + (_stdev *1)\u000a        _min = _mean - (_stdev *1)\u000a        return _min,_max,_mean\u000a\u000a    def moving_avg(self,lst,window):\u000a        lps_array = np.array(lst)  #convert to array\u000a        cumsum = np.cumsum(lps_array,dtype=float) #running average\u000a        ma = (cumsum[window:] - cumsum[:-window]) / window \u000a        return ma\u000a\u000a    def pupil_cue(self,lst,win,p_min,p_max):\u000a        #lma = self.moving_avg(lst,win) #old\u000a        lps_array = np.array(lst)  #convert to array\u000a        smooth = scipy.ndimage.filters.median_filter(lps_array,size=150) #median filter\u000a        ma = smooth[-1]\u000a        less_ = ma < p_min\u000a        greater_ = ma > p_max\u000a        if less_: #pupil size less than SD from baseline\u000a            if old_cue == self.blue:\u000a                return 'blue'\u000a            else:\u000a                iaps_cue.setImage("blue.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('blue image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'blue'\u000a        elif greater_:#pupil size greater than SD from baseline    \u000a            if old_cue == self.red:\u000a                return 'red'\u000a            else:\u000a                iaps_cue.setImage("red.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('red image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))              \u000a                return 'red'\u000a        else: #pupil size within SD from baseline\u000a            if old_cue == self.green:\u000a                return 'green'\u000a            else:\u000a                iaps_cue.setImage("green.png")\u000a                iaps_cue.setAutoDraw(True)\u000a                print('green image, moving_avg=%s, min=%s, max=%s'%(p_ma,p_min,p_max))\u000a                return 'green'\u000a\u000a    def pupil_sample(self):\u000a        #check for new sample update\u000a        s = pylink.getEYELINK().getNewestSample() # check for new sample update\u000a        if(s != None): # Gets the gaze position of the latest sample\u000a            #pupil area\u000a            if eye_used == self.right_eye:\u000a                ps = s.getRightEye().getPupilSize()\u000a            else:\u000a                ps = s.getLeftEye().getPupilSize()\u000a            return ps\u000a\u000a    def save_csv(self,old_,vel_,new_,time_):\u000a        global header      \u000a        if baseline:        \u000a            #outputting baseline to csv\u000a            #reverse time\u000a            time_.reverse()\u000a            time_ = [ -x for x in time_]\u000a        \u000a        with open('_data\u005cgaze\u005c%s.csv'%(subno), 'a') as cross_val:\u000a            writer = csv.writer(cross_val,lineterminator='\u005cn')\u000a            if header:\u000a                s_header=["block","trial","event",\u000a                          "eyelink_timestamp","psychopy_timestamp",\u000a                          "cpu","ram",\u000a                          "pupil_baseline_min","pupil_baseline_mean","pupil_baseline_max",\u000a                          "old_pupil_sample","pupil_velocity","new_pupil_sample","cue","blink"]\u000a                writer.writerow(s_header)\u000a                header=False\u000a            writer.writerows(itertools.izip(lblock,ltrial,levent,\u000a                                            ltt,time_,\u000a                                            cpu_pc,ram_pc,\u000a                                            lps_min,lps_mean,lps_max,\u000a                                            old_,vel_,new_,lcue,lblink))\u000a\u000a    def set_eye_used(self):\u000a        eye_entered = str(expInfo['Dominant Eye'])\u000a        if eye_entered in ('Left','LEFT','left','l','L'):\u000a            eye_used = self.left_eye\u000a        else:\u000a            eye_used = self.right_eye\u000a        return eye_used\u000a            \u000a    def start_recording(self):\u000a        """\u000a        Comments: Recording may take 10 to 30 milliseconds to begin from this command.\u000a        Parameters:\u000a            file_samples  If 1, writes samples to EDF file. If 0, disables sample recording.  \u000a            file_events  If 1, writes events to EDF file. If 0, disables event recording.  \u000a            link_samples  If 1, sends samples through link. If 0, disables link sample access.  \u000a            link_events  If 1, sends events through link. If 0, disables link event access.  \u000a        Returns: 0 if successful, else trial return code. \u000a        """\u000a        global trialNum\u000a        global scenestim\u000a        pylink.getEYELINK().sendCommand("record_status_message 'Trial %s Image %s'" %(trialNum,scenestim)) #send message to Eyelink viewer\u000a        pylink.getEYELINK().sendMessage('TRIALID %s'%(trialNum))\u000a        pylink.getEYELINK().sendCommand("clear_screen 0")\u000a        pylink.getEYELINK().sendCommand("draw_box %s %s %s %s %s" %(self.w/2 - 100, self.h/2 - 100, self.w/2 + 100, self.h/2 + 100,  7))\u000a        pylink.beginRealTimeMode(100) #start realtime mode\u000a        pylink.getEYELINK().startRecording(1, 1, 1, 1)# Begin recording\u000a\u000a    def stop_recording(self):\u000a        pylink.endRealTimeMode()\u000a        pylink.msecDelay(100) #Allow Windows to clean up while we record additional 100 msec of data\u000a        pylink.getEYELINK().stopRecording()\u000a        pylink.msecDelay(50)\u000a        pylink.getEYELINK().setOfflineMode() #Places EyeLink tracker in off-line (idle) mode\u000a\u000a    def t_cue(self,c1,c0): #create new cue only if more than 250 msec has gone by since old cue\u000a        cu = (c1 - c0) >= 0.250\u000a        return cu\u000a    \u000a    def t_csv(self,event,ps_o,ps_n):\u000a        if baseline:\u000a            #timing\u000a            pp_t = FixationClock.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            levent.append(event_type)\u000a            lblock.append(blockNum)\u000a            ltrial.append(trialNum)\u000a            lpp_t.append(pp_t) #psychopy time      \u000a            lpb_uadj.append(ps_o)#unadjusted pupil size\u000a            lpb_d.append(maV)#pupil size velocity\u000a            lpb.append(ps_n)#adjusted pupil size\u000a            \u000a            #dummy variables\u000a            ltt.append(blank_event)#tracker time\u000a            cpu_pc.append(blank_event)#cpu\u000a            ram_pc.append(blank_event)#ram\u000a            lps_min.append(blank_event)#neg stdev from baseline mean\u000a            lps_mean.append(blank_event)#baseline mean\u000a            lps_max.append(blank_event)#pos stdev from baseline mean\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blank_event) #debug\u000a        else:\u000a            #timing\u000a            tt = eyelink.t_tracker()#tracker time\u000a            pp_t = event.getTime()#psychopy time\u000a            \u000a            #creating variables for cross-validation\u000a            lblock.append(blockNum)#block\u000a            ltrial.append(trialNum)#trial\u000a            levent.append(event_type)#baseline or stimulus\u000a            ltt.append(tt)#tracker time\u000a            lpp_t.append(pp_t)#psychopy time\u000a            cpu_pc.append(cpu_s)#cpu\u000a            ram_pc.append(ram_s)#ram\u000a            lps_min.append(ps_min)#neg stdev from baseline mean\u000a            lps_mean.append(ps_mean)#baseline mean\u000a            lps_max.append(ps_max)#pos stdev from baseline mean\u000a            lps_uadj.append(ps_o)#unadjusted pupil size\u000a            lps_d.append(maV)#pupil size velocity\u000a            lps.append(ps_n)#adjusted pupil size\u000a            lcue.append(old_cue) #cue color\u000a            lblink.append(blink_event) #debug\u000a\u000a    def t_sample(self,s_1,s_0):  #collect new sample only if more than 2 msec has gone by since old sample (Eyelink-500Hz)\u000a        su = (s_1 - s_0) >= .002\u000a        return su\u000a\u000a    def t_tracker(self):\u000a        #Returns the current tracker time (in milliseconds) since the tracker application started\u000a        tt = pylink.getEYELINK().trackerTimeUsec()\u000a        return tt\u000a        \u000amouse = event.Mouse(win=win)\u000agamepad_available = False #debug - turn on if task is ready for implimentation\u000aif gamepad_available:\u000a    gamepad = joystick.Joystick(0)\u000a\u000a# Initialize components for Routine "Introduction"\u000aIntroductionClock = core.Clock()\u000atask_instr_image = visual.ImageStim(win=win, name='task_instr_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Initialize components for Routine "Block_Instructions"\u000aBlock_InstructionsClock = core.Clock()\u000aBlock_image = visual.ImageStim(win=win, name='Block_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "Fixation"\u000aFixationClock = core.Clock()\u000afixation_cross = visual.ImageStim(win=win, name='fixation_cross',\u000a    image="Instructions/fixation.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000a\u000a# Initialize components for Routine "IAPS"\u000aIAPSClock = core.Clock()\u000aiaps_cue = visual.ImageStim(win=win, name='iaps_cue',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=.25,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aiaps_display = visual.ImageStim(win=win, name='iaps_display',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000ablank = visual.ImageStim(win=win, name='blank',\u000a    image="Instructions/blank.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000a\u000a# Initialize components for Routine "Break"\u000aBreakClock = core.Clock()\u000abreak_image = visual.ImageStim(win=win, name='break_image',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aBreak_end = 0\u000a\u000a# Initialize components for Routine "Finish"\u000aFinishClock = core.Clock()\u000aEnd_Screen = visual.ImageStim(win=win, name='End_Screen',\u000a    image="Instructions/finished.png", mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "Calibration_Verification"-------\u000at = 0\u000aCalibration_VerificationClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a#EyeLink-1 Prepare\u000asubno = (expInfo['Participant'])\u000a\u000a# Prepare eyetracker link and open EDF\u000aeyelink=libeyelink(subno)\u000a\u000a#eye used\u000aeye_used = eyelink.set_eye_used()\u000a\u000a# Calibrate eyetracker\u000aDC = 0\u000aeyelink.calibrate()\u000a\u000a# keep track of which components have finished\u000aCalibration_VerificationComponents = []\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Calibration_Verification"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = Calibration_VerificationClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in Calibration_VerificationComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Calibration_Verification"-------\u000afor thisComponent in Calibration_VerificationComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# the Routine "Calibration_Verification" was not non-slip safe, so reset the non-slip timer\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000aIntroduction_Loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005cIntroduction_list.csv'),\u000a    seed=None, name='Introduction_Loop')\u000athisExp.addLoop(Introduction_Loop)  # add the loop to the experiment\u000athisIntroduction_Loop = Introduction_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisIntroduction_Loop.rgb)\u000aif thisIntroduction_Loop != None:\u000a    for paramName in thisIntroduction_Loop.keys():\u000a        exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a\u000afor thisIntroduction_Loop in Introduction_Loop:\u000a    currentLoop = Introduction_Loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisIntroduction_Loop.rgb)\u000a    if thisIntroduction_Loop != None:\u000a        for paramName in thisIntroduction_Loop.keys():\u000a            exec(paramName + '= thisIntroduction_Loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Introduction"-------\u000a    t = 0\u000a    IntroductionClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    task_instr_image.setImage("Instructions/"+Introduction_image+".png")\u000a    Inst__Key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    Inst__Key.status = NOT_STARTED\u000a    \u000a    # keep track of which components have finished\u000a    IntroductionComponents = []\u000a    IntroductionComponents.append(task_instr_image)\u000a    IntroductionComponents.append(Inst__Key)\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Introduction"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = IntroductionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *task_instr_image* updates\u000a        if t >= 0.0 and task_instr_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            task_instr_image.tStart = t  # underestimates by a little under one frame\u000a            task_instr_image.frameNStart = frameN  # exact frame index\u000a            task_instr_image.setAutoDraw(True)\u000a        \u000a        # *Inst__Key* updates\u000a        if t >= 0.0 and Inst__Key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Inst__Key.tStart = t  # underestimates by a little under one frame\u000a            Inst__Key.frameNStart = frameN  # exact frame index\u000a            Inst__Key.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if Inst__Key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a           \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in IntroductionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Introduction"-------\u000a    for thisComponent in IntroductionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "Introduction" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'Introduction_Loop'\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions('procedure\u005c\u005c#set_list.csv'),\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    #------Prepare to start Routine "Block_Instructions"-------\u000a    t = 0\u000a    Block_InstructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    block_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    block_key.status = NOT_STARTED\u000a    Block_image.setImage("Instructions/"+block_display+".png")\u000a    # keep track of which components have finished\u000a    Block_InstructionsComponents = []\u000a    Block_InstructionsComponents.append(block_key)\u000a    Block_InstructionsComponents.append(Block_image)\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "Block_Instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = Block_InstructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *block_key* updates\u000a        if t >= 0.0 and block_key.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            block_key.tStart = t  # underestimates by a little under one frame\u000a            block_key.frameNStart = frameN  # exact frame index\u000a            block_key.status = STARTED\u000a            # keyboard checking is just starting\u000a            win.callOnFlip(block_key.clock.reset)  # t=0 on next screen flip\u000a            event.clearEvents(None)\u000a            event.mouseButtons = [0, 0, 0]\u000a        if block_key.status == STARTED:\u000a            theseKeys = event.getKeys(None)\u000a            buttons = mouse.getPressed()\u000a            if gamepad_available:\u000a                pressed = gamepad.getAllButtons()\u000a                if sum(buttons) > 0:  # ie if any button is pressed\u000a                    # abort routine on response\u000a                    continueRoutine = False\u000a                for anyState in pressed:\u000a                    if anyState == True:\u000a                        continueRoutine = False\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                block_key.keys = theseKeys[-1]  # just the last key pressed\u000a                block_key.rt = block_key.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *Block_image* updates\u000a        if t >= 0.0 and Block_image.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            Block_image.tStart = t  # underestimates by a little under one frame\u000a            Block_image.frameNStart = frameN  # exact frame index\u000a            Block_image.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in Block_InstructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "Block_Instructions"-------\u000a    for thisComponent in Block_InstructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if block_key.keys in ['', [], None]:  # No response was made\u000a       block_key.keys=None\u000a    # store data for block_loop (TrialHandler)\u000a    block_loop.addData('block_key.keys',block_key.keys)\u000a    if block_key.keys != None:  # we had a response\u000a        block_loop.addData('block_key.rt', block_key.rt)\u000a    # the Routine "Block_Instructions" was not non-slip safe, so reset the non-slip timer\u000a	routineTimer.reset()\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    Trial_Loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(block_file),\u000a        seed=None, name='Trial_Loop')\u000a    thisExp.addLoop(Trial_Loop)  # add the loop to the experiment\u000a    thisTrial_Loop = Trial_Loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_Loop.rgb)\u000a    if thisTrial_Loop != None:\u000a        for paramName in thisTrial_Loop.keys():\u000a            exec(paramName + '= thisTrial_Loop.' + paramName)\u000a    \u000a    #updating block count\u000a    blockNum = blockNum + 1 #trial count    \u000a    \u000a    for thisTrial_Loop in Trial_Loop:\u000a        currentLoop = Trial_Loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_Loop.rgb)\u000a        if thisTrial_Loop != None:\u000a            for paramName in thisTrial_Loop.keys():\u000a                exec(paramName + '= thisTrial_Loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Fixation"-------\u000a        #eyelink-initalize per block\u000a        trialNum = trialNum + 1 #trial count\u000a        DC = 0 #force calibration if drift correct is failed 3 times in a row\u000a\u000a        Fixation = True #Fixation event\u000a        while Fixation:\u000a            #pupil\u000a            lpb_uadj=[] #list of unadjusted pupil samples \u000a            lpb=[]#list of adjusted pupil samples\u000a            lpb_d=[] #change in ps\u000a            ps_n1 = 0 #n-1 pupil sample\u000a            st0=0 #time between samples (st1-st0)\u000a            first_loop = True #first pupil sample\u000a            ps_dn1 = 0\u000a            ma_min = False #less than 3 samples for moving average\u000a            maV=0 #velocity\u000a             \u000a            #timing\u000a            baseline = True\u000a            Window = True #gc window\u000a            Event_draw = False #marks the zero-time in a trial\u000a            event_type='baseline' #stimulus event label\u000a            levent=[]#list of event order\u000a            lblock=[]#list of block num\u000a            ltrial=[]#list of trial num\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            lblink=[] #debug blink event\u000a            \u000a            #dummy values\u000a            old_cue = 'nan'\u000a            blank_event='nan'\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a        \u000a\u000a            # update component parameters for each repeat\u000a            inbox = False\u000a            GAZE = False\u000a            t = 0\u000a            FixationClock.reset()  # clock \u000a            frameN = -1\u000a            \u000a            #eyelink-start recording\u000a            eyelink.start_recording()\u000a            \u000a            #-------Start Routine "Fixation"-------\u000a            gaze_timer = time.clock()\u000a            # *fixation_cross* updates\u000a            fixation_cross.setAutoDraw(True)\u000a            win.flip()\u000a\u000a            # update/draw components on each frame\u000a            while Window:\u000a                if FixationClock.getTime() >= 2:\u000a                    fixation_cross.setAutoDraw(False)\u000a                    break\u000a                else:\u000a                    st1 = FixationClock.getTime()\u000a                    # eyelink-gaze contingent fixation\u000a                    if eyelink.t_sample(st1,st0): #if at least 2msec between samples\u000a                        if inbox != True: #if gaze window not achived\u000a                            eyelink.gc_window()   \u000a                        #eyelink-collect pupil size\u000a                        ps_old = eyelink.pupil_sample()\u000a                        if len(lpb_uadj) >= 2:\u000a                            maV = lpb_uadj[-1]-lpb_uadj[-2]\u000a                        st0 = st1\u000a                        eyelink.t_csv(FixationClock,ps_old,blank_event)\u000a                \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            #gc window \u000a            #if Fixation failed              \u000a            if GAZE != True:\u000a                if DC >=2:#if drift correct failed twice run calibration\u000a                    eyelink.calibrate()\u000a                    DC = 0 #reset counter\u000a                else: # drift correct\u000a                    eyelink.gc_drift_correct()\u000a                    DC = DC + 1 #add counter\u000a        \u000a            #blink detection \u000a            #collect baseline min max mean and stdev        \u000a            ps_min,ps_max,ps_mean = eyelink.min_max(lpb_uadj)\u000a            #check if any pupil size during baseline collection was less than 75% of baseline mean\u000a            blink_threshold = (.75*ps_mean)\u000a            low_pupil = min(float(s) for s in lpb_uadj)\u000a            if low_pupil < blink_threshold: \u000a                Fixation = True #if so, restart fixation \u000a\u000a        #outputting baseline to csv\u000a        eyelink.save_csv(lpb_uadj,lpb_d,lpb,lpp_t)\u000a            \u000a        #------Prepare to start Routine "IAPS"-------\u000a        with PyCallGraph(output=GraphvizOutput()):\u000a            t = 0\u000a            IAPSClock.reset()  # clock \u000a            frameN = -1\u000a\u000a            #constants\u000a            blink_event = 'nan' #debug #dummy value for blink onset/offset\u000a            event_type='stimulus' #stimulus event label\u000a            old_cue = 'nan' #dummy values for time before first cue presentation\u000a            p_ma = 'nan' #dummy value for moving average\u000a            ps_n1 = 0 #n-1 pupil size\u000a            st0=0 #time between samples (st1-st0)\u000a            ct0=0 #time between cues (ct1-ct0)\u000a            stimulus_offset = 10 #time (sec)\u000a            blank_offset = 12 #time (sec)\u000a            Total_Samples_old=0 #no. of samples\u000a            \u000a            #functions\u000a            cpu_s = psutil.cpu_percent(interval=None)\u000a            ram_s = psutil.virtual_memory().percent\u000a\u000a            #boolean\u000a            first_loop = True # is first pupil sample\u000a            Window = True #window to collect samples\u000a            baseline = False #end of baseline samples\u000a            blink = False #blink occuring\u000a            ma_min = False #less than 3 samples for moving average\u000a            Cue = True #present cue\u000a            \u000a            #list\u000a            lblink=[] #list of blink events\u000a            levent=[] #list of event types (baseline,trial)\u000a            lps_max=[]#list of pupil baseline max\u000a            lps_min=[]#list of pupil baseline min\u000a            lps_mean=[]#list of pupil baseline mean\u000a            lps_uadj=[] #list of unadjusted pupil samples \u000a            lps=[]#list of adjusted pupil samples\u000a            lps_d=[] #change in ps\u000a            lcue=[] #list of cue colors\u000a            ltt=[] #time stamp of each cue onset (eyelink)\u000a            lpp_t=[]#time stamp of each cue onset (psychopy)\u000a            ltrial=[]#list of trials at each cue\u000a            lblock=[]#list of trials at each cue\u000a            cpu_pc=[]#list of cpu usage, by %\u000a            ram_pc=[]#list of ram usage, by %\u000a\u000a            # update component parameters for each repeat       \u000a            iaps_display.setImage("stimulus/"+scenestim)\u000a            image_size = iaps_display.size[0],iaps_display.size[1]\u000a            color_list = ["blue","red","green"]\u000a            for color_image in color_list:\u000a                im = Image.new("RGB", (image_size), color_image)\u000a                im.save("%s.png"%(color_image))\u000a            \u000a            # keep track of which components have finished\u000a            IAPSComponents = []\u000a            IAPSComponents.append(iaps_display)\u000a            IAPSComponents.append(iaps_cue)\u000a            IAPSComponents.append(blank)\u000a            for thisComponent in IAPSComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "IAPS"-------\u000a            continueRoutine = True\u000a            print('trial start')#debug\u000a            pylink.getEYELINK().sendMessage('baseline %s min %s max %s'%(ps_mean,ps_min,ps_max))#debug\u000a            while continueRoutine and IAPSClock.getTime() < blank_offset:\u000a                # get current time\u000a                t = IAPSClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                # *iaps_display* updates\u000a                if t >= 0 and iaps_display.status == NOT_STARTED:\u000a                    iaps_display.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('IAPS Onset')\u000a                if iaps_display.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_display.setAutoDraw(False)\u000a    \u000a                #eyelink-pupil dilation sampling\u000a                if IAPSClock.getTime() >= 0 and iaps_display.status == STARTED: #collect samples 5ms after stimulus onset\u000a                    while Window:\u000a                        st1 = IAPSClock.getTime()\u000a                        ct1 = IAPSClock.getTime()\u000a                        if eyelink.t_sample(st1,st0): #if time between samples > 2 msec                      \u000a                            ps_new = eyelink.blink_correction(lps_uadj)\u000a                            st0 = st1\u000a                            eyelink.t_csv(IAPSClock,ps_old,ps_new)\u000a                        #if blink hasn't occured                        \u000a                        if blink != True:    \u000a                            if eyelink.t_cue(ct1,ct0): #if time between cues > 250 msec\u000a                                ct0 = ct1\u000a                                break\u000a    \u000a                #eyelink-iaps_cue* updates\u000a                if IAPSClock.getTime() >= 2 and iaps_display.status == STARTED: #run while stimulus is being displayed\u000a                    Total_Samples = len(lps) #sample count\u000a                    Cue_Samples = Total_Samples - Total_Samples_old #sample count at current cue\u000a                    Total_Samples_old = Total_Samples #update current sample list\u000a                    old_cue = eyelink.pupil_cue(lps,125,ps_min,ps_max)\u000a                    \u000a                    #debug #creating variables for cross-validation #cue level\u000a                    cpu_s = psutil.cpu_percent(interval=None) #update cpu at each cue. this will avoid error with psutil where cpu=0\u000a                    ram_s = psutil.virtual_memory().percent  #update ram at each cue. ram doesnt appear to change during task, so less samples may be better\u000a                    \u000a                    #output to Spyder\u000a                    print('Time = %s'%(t))\u000a                    print('Total Samples = %s'%(Total_Samples))#debug\u000a                    print('Cue Samples = %s'%(Cue_Samples))#debug\u000a                    print('Cue Color = %s'%(old_cue))#debug\u000a                    #print('Running Average = %s'%(ma))#debug\u000a                    print('min = %s, baseline mean, = %s max = %s'%(ps_min,ps_mean,ps_max))#debug\u000a                    print('CPU = %s, RAM = %s'%(cpu_s,ram_s))\u000a\u000a                if iaps_cue.status == STARTED and t >= stimulus_offset: #most of one frame period left\u000a                    iaps_cue.setAutoDraw(False)\u000a                \u000a                # *blank* updates\u000a                if t >= stimulus_offset and blank.status == NOT_STARTED:\u000a                    blank.setAutoDraw(True)\u000a                    pylink.getEYELINK().sendMessage('Blank Onset')\u000a                if blank.status == STARTED and t >= blank_offset: #most of one frame period left\u000a                    blank.setAutoDraw(False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in IAPSComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a                \u000a        #-------Ending Routine "IAPS"-------\u000a        for thisComponent in IAPSComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        #EyeLink-4 End Trial\u000a        #creating csv file\u000a        eyelink.save_csv(lps_uadj,lps_d,lps,lpp_t)\u000a\u000a        #end of trial message\u000a        pylink.getEYELINK().sendMessage('Ending Recording')\u000a        \u000a        #The IMGLOAD command is used to show an overlay image in Data Viewer.  This will code the time that the PictureTrial image should appear.\u000a        pylink.getEYELINK().sendMessage("!V IMGLOAD CENTER  %s" %(scenestim))\u000a        \u000a        #stop recording\u000a        eyelink.stop_recording()\u000a        \u000a        #VARIABLES\u000a        msg = "!V TRIAL_VAR picture %s" %(scenestim) #scenestim\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valence %s" %(valence) #valence\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR valmean %s" %(valmean) #valmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousal %s" %(arousal) #arousal\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR arousalmean %s" %(arousalmean) #arousalmean\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR BlockVar %s" %(blockNum) #blocknum\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        msg = "!V TRIAL_VAR outlier %s" %(outliers) #outliers\u000a        pylink.getEYELINK().sendMessage(msg)\u000a        \u000a        #TRIAL RESULTS\u000a        pylink.getEYELINK().sendMessage("TRIAL_RESULT 1")\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Trial_Loop'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    Break_loop = data.TrialHandler(nReps=1, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='Break_loop')\u000a    thisExp.addLoop(Break_loop)  # add the loop to the experiment\u000a    thisBreak_loop = Break_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisBreak_loop.rgb)\u000a    if thisBreak_loop != None:\u000a        for paramName in thisBreak_loop.keys():\u000a            exec(paramName + '= thisBreak_loop.' + paramName)\u000a    \u000a    for thisBreak_loop in Break_loop:\u000a        currentLoop = Break_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisBreak_loop.rgb)\u000a        if thisBreak_loop != None:\u000a            for paramName in thisBreak_loop.keys():\u000a                exec(paramName + '= thisBreak_loop.' + paramName)\u000a        \u000a        #------Prepare to start Routine "Break"-------\u000a        t = 0\u000a        BreakClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        Break_key = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        Break_key.status = NOT_STARTED\u000a        break_image.setImage("Instructions/"+break_display+".png")\u000a        Break_end = Break_end + 1 #block count\u000a        if Break_end > 2:\u000a            Break_loop.finished = True\u000a        # keep track of which components have finished\u000a        BreakComponents = []\u000a        BreakComponents.append(Break_key)\u000a        BreakComponents.append(break_image)\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Break"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = BreakClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *Break_key* updates\u000a            if t >= 0.0 and Break_key.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                Break_key.tStart = t  # underestimates by a little under one frame\u000a                Break_key.frameNStart = frameN  # exact frame index\u000a                Break_key.status = STARTED\u000a                # keyboard checking is just starting\u000a                win.callOnFlip(Break_key.clock.reset)  # t=0 on next screen flip\u000a                event.clearEvents(None)\u000a                event.mouseButtons = [0, 0, 0]\u000a            if Break_key.status == STARTED:\u000a                theseKeys = event.getKeys(None)\u000a                buttons = mouse.getPressed()\u000a                if gamepad_available:\u000a                    pressed = gamepad.getAllButtons()\u000a                    if sum(buttons) > 0:  # ie if any button is pressed\u000a                        # abort routine on response\u000a                        continueRoutine = False\u000a                    for anyState in pressed:\u000a                        if anyState == True:\u000a                            continueRoutine = False\u000a\u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    Break_key.keys = theseKeys[-1]  # just the last key pressed\u000a                    Break_key.rt = Break_key.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a                if Break_end > 2:\u000a                    continueRoutine = False                  \u000a            \u000a            # *break_image* updates\u000a            if t >= 0.0 and break_image.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                break_image.tStart = t  # underestimates by a little under one frame\u000a                break_image.frameNStart = frameN  # exact frame index\u000a                break_image.setAutoDraw(True)\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in BreakComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Break"-------\u000a        for thisComponent in BreakComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if Break_key.keys in ['', [], None]:  # No response was made\u000a           Break_key.keys=None\u000a        # store data for Break_loop (TrialHandler)\u000a        Break_loop.addData('Break_key.keys',Break_key.keys)\u000a        if Break_key.keys != None:  # we had a response\u000a            Break_loop.addData('Break_key.rt', Break_key.rt)\u000a        \u000a        # the Routine "Break" was not non-slip safe, so reset the non-slip timer\u000a        thisExp.nextEntry()\u000a        \u000a    # completed 1 repeats of 'Break_loop'\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block_loop'\u000a\u000a\u000a#------Prepare to start Routine "Finish"-------\u000at = 0\u000aFinishClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000aFinishComponents = []\u000aFinishComponents.append(End_Screen)\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "Finish"-------\u000acontinueRoutine = True\u000awhile continueRoutine and FinishClock.getTime() < 5:\u000a    # get current time\u000a    t = FinishClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *End_Screen* updates\u000a    if t >= 0.0 and End_Screen.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        End_Screen.tStart = t  # underestimates by a little under one frame\u000a        End_Screen.frameNStart = frameN  # exact frame index\u000a        End_Screen.setAutoDraw(True)\u000a    if End_Screen.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        End_Screen.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in FinishComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "Finish"-------\u000afor thisComponent in FinishComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#EyeLink-4 Close\u000a#set offline mode so we can transfer file\u000aedfpath = _thisDir + os.sep + '_data/edf'\u000aeyelink.close(edfpath)\u000a\u000a# these shouldn't be strictly necessary (should auto-save)\u000athisExp.saveAsWideText(filename+'.csv')\u000athisExp.saveAsPickle(filename)\u000alogging.flush()\u000a# make sure everything is closed down\u000athisExp.abort() # or data files will save again on exit\u000awin.close()\u000acore.quit()\u000a
p514
sg334
(lp515
sg336
I402330128
sg10
g437
sg6
g338
sg339
I1
sg18
I01
sg19
g20
sg340
g1
(g341
g342
(dp516
g344
g345
(g346
g347
g348
S'b'
tRp517
(I1
(I1
I1
tg350
I00
S'\x00\x00\x80?'
S'\x00'
Ntbsg351
g345
(g346
g347
g348
S'b'
tRp518
(I1
(I1
I1
tg350
I00
S'\x00\x00\x00\x00'
S'\x00'
Ntbsg16
g365
(g347
(I0
tS'b'
tRp519
(I1
(I1
I1
tg392
I00
(lp520
NatbstRp521
(dp522
g355
(dp523
g344
I01
sg351
I01
sg16
I00
ssg357
g512
sg358
(lp524
g344
ag351
ag16
asg360
(lp525
I1
aI1
asbsg362
g422
sg364
g365
(g347
(I0
tS'b'
tRp526
(I1
(I1
I1
tg59
I00
S'\x00\x00\x00\x00'
tbsg367
I01
sg368
I1
sg369
I-1
sg370
(lp527
Nasg377
Nsg378
g318
sg380
I1
sg381
I0
sg382
I1
sg383
I01
sbasS'savePickle'
p528
I00
sb.